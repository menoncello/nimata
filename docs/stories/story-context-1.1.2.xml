<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.2</storyId>
    <title>Configuration System</title>
    <status>Ready</status>
    <generatedAt>2025-10-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-1.2.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer using Nìmata</asA>
    <iWant>a flexible configuration system that supports project-specific and global settings</iWant>
    <soThat>I can customize tool behavior, quality levels, and AI assistant integration while maintaining team standards through project configuration that overrides personal preferences</soThat>
    <tasks>
      <!-- P0 - Security & Performance (NFR Assessment) -->
      <task priority="P0" category="Security">
        <id>P0-1</id>
        <title>YAML parsing security limits</title>
        <subtasks>
          <subtask>Add YAML file size limit validation (max 1MB)</subtask>
          <subtask>Add YAML nesting depth limit (max 10 levels)</subtask>
          <subtask>Add error handling for malicious YAML (anchors, recursion)</subtask>
          <subtask>Unit test: Reject YAML with excessive nesting</subtask>
          <subtask>Unit test: Reject YAML files exceeding size limit</subtask>
          <subtask>Unit test: Handle YAML anchor bombs gracefully</subtask>
        </subtasks>
      </task>
      <task priority="P0" category="Performance">
        <id>P0-2</id>
        <title>Performance SLO and benchmarks</title>
        <subtasks>
          <subtask>Define performance target: Config load &lt;50ms (p95) for 100-key config</subtask>
          <subtask>Add performance test in packages/adapters/tests/unit/yaml-config-repository.test.ts</subtask>
          <subtask>Document cache invalidation strategy (per-process lifetime)</subtask>
          <subtask>Benchmark deep merge with 5-level nested structures</subtask>
          <subtask>Add Big-O complexity comment for deep merge algorithm</subtask>
        </subtasks>
      </task>
      <task priority="P0" category="Maintainability">
        <id>P0-3</id>
        <title>Deep merge utility with full coverage</title>
        <subtasks>
          <subtask>Create packages/core/src/utils/deep-merge.ts with type-safe implementation</subtask>
          <subtask>Add unit tests for deep merge (100% coverage target)</subtask>
          <subtask>Add mutation tests for deep merge (80%+ score target)</subtask>
          <subtask>Document algorithm complexity (time and space)</subtask>
          <subtask>Add edge case tests: circular refs, null/undefined handling, array replacement</subtask>
        </subtasks>
      </task>
      <!-- P1 - Observability & Testing -->
      <task priority="P1" category="Maintainability">
        <id>P1-1</id>
        <title>Structured logging for config operations</title>
      </task>
      <task priority="P1" category="Maintainability">
        <id>P1-2</id>
        <title>Expand E2E test coverage</title>
      </task>
      <!-- Core Implementation -->
      <task priority="Core">
        <title>Define configuration schema and data models</title>
        <ac>All</ac>
      </task>
      <task priority="Core">
        <title>Implement IConfigRepository interface</title>
        <ac>6</ac>
      </task>
      <task priority="Core">
        <title>Implement YAMLConfigRepository adapter</title>
        <ac>1, 2, 3</ac>
      </task>
      <task priority="Core">
        <title>Implement configuration validation</title>
        <ac>4</ac>
      </task>
      <task priority="Core">
        <title>Implement default configuration</title>
        <ac>5</ac>
      </task>
      <task priority="Core">
        <title>Implement configuration cascade logic</title>
        <ac>3</ac>
      </task>
      <task priority="Core">
        <title>Add configuration tests</title>
        <ac>All</ac>
      </task>
      <task priority="Core">
        <title>Create example configuration files</title>
        <ac>1, 2</ac>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">Reads `.nimatarc` file from project root (YAML format)</criterion>
    <criterion id="AC2">Supports global config in `~/.nimata/config.yaml`</criterion>
    <criterion id="AC3">Project config overrides global config (deep merge strategy)</criterion>
    <criterion id="AC4">Configuration schema validation with clear error messages</criterion>
    <criterion id="AC5">Default values for all optional settings</criterion>
    <criterion id="AC6">Config can be programmatically loaded and validated</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture</title>
        <section>ADR-011: Configuration Cascade with Deep Merge and Project Override</section>
        <snippet>Deep merge with project config overriding user config. User config = developer preferences, Project config = team standards. Team standards should override individual preferences for consistency. Deep merge allows partial overrides (not all-or-nothing).</snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture</title>
        <section>ADR-001: Use Bun Native YAML Parsing</section>
        <snippet>Use Bun.file().yaml() instead of js-yaml. Native Bun YAML parsing eliminates dependency, provides better performance. Part of strategy to use Bun 1.3+ native features for 40-60% performance improvement.</snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture</title>
        <section>3.2 Configuration Cascade Strategy</section>
        <snippet>Three-level cascade: (1) Defaults hardcoded in packages/core/src/config/defaults.ts, (2) User Config ~/.nimata/config.yaml merges with defaults, (3) Project Config project-root/.nimata/config.yaml has highest priority, overrides user + defaults.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-1.md</path>
        <title>Tech Spec Epic 1</title>
        <section>4.1.4 IConfigRepository Interface</section>
        <snippet>Interface with three methods: load(projectRoot?) returns merged config with cascade, save(config, projectRoot) saves project config, merge(base, override) performs deep merge of configurations.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR013: Configuration Management</section>
        <snippet>User can store and modify Nìmata configuration in local .nimatarc file within project, enabling version control of quality settings and project-specific customizations.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>NFR002: Reliability - Cache Invalidation</section>
        <snippet>Cache invalidation must be reliable - never serve stale results when file has been modified. Trust is paramount - developers must be confident that Nìmata won't provide incorrect validation results.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>apps/cli/src/container.ts</path>
        <kind>di-container</kind>
        <symbol>configureContainer</symbol>
        <lines>22-35</lines>
        <reason>TSyringe DI container setup - Story 1.2 will register IConfigRepository → YAMLConfigRepository binding here</reason>
      </artifact>
      <artifact>
        <path>packages/core/src/index.ts</path>
        <kind>package-entry</kind>
        <symbol>CORE_VERSION</symbol>
        <lines>1-20</lines>
        <reason>Core package placeholder - Story 1.2 will add config types and interfaces exports</reason>
      </artifact>
      <artifact>
        <path>packages/adapters/src/index.ts</path>
        <kind>package-entry</kind>
        <symbol>ADAPTERS_VERSION</symbol>
        <lines>1-19</lines>
        <reason>Adapters package placeholder - Story 1.2 will add YAMLConfigRepository export</reason>
      </artifact>
    </code>
    <dependencies>
      <node>
        <package>tsyringe</package>
        <version>4.x</version>
        <purpose>Dependency injection container (already in use)</purpose>
      </node>
      <node>
        <package>reflect-metadata</package>
        <version>latest</version>
        <purpose>Required by TSyringe for DI</purpose>
      </node>
      <node>
        <package>zod</package>
        <version>3.x</version>
        <purpose>Schema validation for config (to be added)</purpose>
      </node>
      <bun>
        <api>Bun.file().yaml()</api>
        <version>1.3+</version>
        <purpose>Native YAML parsing for config files</purpose>
      </bun>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Use Clean Architecture Lite (3 layers): CLI → Use Cases → Adapters</constraint>
    <constraint>Manual TSyringe DI registration (no decorators) - explicit bindings in apps/cli/src/container.ts</constraint>
    <constraint>Configuration types in packages/core/src/types/ (domain layer)</constraint>
    <constraint>YAMLConfigRepository in packages/adapters/src/repositories/ (adapter layer)</constraint>
    <constraint>IConfigRepository interface in packages/core/src/interfaces/ (port)</constraint>
    <constraint>Deep merge utility in packages/core/src/utils/deep-merge.ts</constraint>
    <constraint>All relative paths in config files (security: prevent path traversal)</constraint>
    <constraint>YAML format for human-friendly configuration with comments supported</constraint>
    <constraint>Bun native APIs only - NO js-yaml dependency</constraint>
    <constraint>Security: YAML file size max 1MB, nesting depth max 10 levels</constraint>
    <constraint>Performance: Config load &lt;50ms (p95) for 100-key config</constraint>
    <constraint>ESLint compliance from day one (max-lines 300, no-empty-function)</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>IConfigRepository</name>
      <kind>port-interface</kind>
      <signature>
interface IConfigRepository {
  load(projectRoot?: string): Promise&lt;Config&gt;;
  save(config: Config, projectRoot: string): Promise&lt;void&gt;;
  merge(base: Config, override: Partial&lt;Config&gt;): Config;
}
      </signature>
      <path>packages/core/src/interfaces/i-config-repository.ts</path>
    </interface>
    <interface>
      <name>Config</name>
      <kind>domain-type</kind>
      <signature>
interface Config {
  version: number;
  qualityLevel: 'light' | 'medium' | 'strict';
  aiAssistants: ('claude-code' | 'copilot' | 'windsurf')[];
  tools: ToolsConfig;
  scaffolding: ScaffoldingConfig;
  validation: ValidationConfig;
  refactoring: RefactoringConfig;
  logging: LoggingConfig;
}
      </signature>
      <path>packages/core/src/types/config.ts</path>
    </interface>
    <interface>
      <name>deepMerge</name>
      <kind>utility-function</kind>
      <signature>
function deepMerge&lt;T&gt;(base: T, override: Partial&lt;T&gt;): T;
      </signature>
      <path>packages/core/src/utils/deep-merge.ts</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
Bun Test framework with strict TDD approach. Unit tests: 100% isolation with fresh mocks in beforeEach(), AAA pattern (Arrange-Act-Assert), one assertion per test. Integration tests use real YAML files with temp directories. Mutation testing with Stryker (80%+ mutation score target for deep merge logic). Performance tests validate &lt;50ms config load (p95). Security tests validate YAML limits (max 1MB file size, max 10 nesting depth), rejection of malicious YAML (anchors, recursion), and absolute path rejection. ESLint compliance enforced (max-lines 300, no-empty-function). Test locations: packages/core/tests/unit/ for config logic, packages/adapters/tests/unit/ for repository, packages/adapters/tests/integration/ for file I/O, apps/cli/tests/e2e/ for CLI integration.
    </standards>
    <locations>
      <location>packages/core/tests/unit/config-defaults.test.ts</location>
      <location>packages/core/tests/unit/config-cascade.test.ts</location>
      <location>packages/core/tests/unit/deep-merge.test.ts</location>
      <location>packages/adapters/tests/unit/yaml-config-repository.test.ts</location>
      <location>packages/adapters/tests/unit/yaml-config-repository.perf.test.ts</location>
      <location>packages/adapters/tests/unit/config-validation.test.ts</location>
      <location>packages/adapters/tests/unit/yaml-security.test.ts</location>
      <location>packages/adapters/tests/integration/config-file-loading.test.ts</location>
      <location>packages/adapters/tests/integration/config-merge.test.ts</location>
      <location>apps/cli/tests/e2e/config-loading.e2e.test.ts</location>
    </locations>
    <ideas>
      <idea ac="AC1">Integration test: Load .nimatarc from project root using Bun.file().yaml(), verify YAML parsing works correctly</idea>
      <idea ac="AC2">Integration test: Load ~/.nimata/config.yaml from user home directory, verify global config loads successfully</idea>
      <idea ac="AC3">Unit test: Deep merge defaults + global + project configs, verify project values override global values, verify nested objects merge correctly (not replaced), verify arrays are replaced (not merged)</idea>
      <idea ac="AC4">Unit test: Validate config with Zod schema, test invalid qualityLevel enum, test invalid aiAssistants values, test absolute paths rejected, verify clear error messages with field path</idea>
      <idea ac="AC5">Unit test: Load config with missing fields, verify defaults fill in (qualityLevel='strict', aiAssistants=['claude-code'], all tool configs enabled)</idea>
      <idea ac="AC6">Unit test: Programmatically call configRepo.load(), verify returns Config type, verify save() works, verify merge() works</idea>
      <idea ac="P0-1">Security test: Reject YAML file exceeding 1MB, reject YAML with nesting depth &gt; 10 levels, handle YAML anchor bombs gracefully without crashing</idea>
      <idea ac="P0-2">Performance test: Benchmark config load time, verify &lt;50ms (p95) for 100-key config, benchmark deep merge with 5-level nested structures, document cache invalidation strategy</idea>
      <idea ac="P0-3">Mutation test: Deep merge utility achieves 80%+ mutation score, test edge cases (circular refs, null/undefined handling, array replacement), verify 100% code coverage</idea>
      <idea ac="P1-1">Log test: Verify config load success logged at debug level with source (defaults/global/project), verify validation errors logged at warn level with field path, verify no sensitive data in logs</idea>
      <idea ac="P1-2">E2E test: CLI execution with project .nimatarc overrides global config, invalid config shows clear error with field path, CLI respects qualityLevel from .nimatarc</idea>
    </ideas>
  </tests>
</story-context>

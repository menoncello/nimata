#!/usr/bin/env bun
// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to =
    isNodeMode || !mod || !mod.__esModule
      ? __defProp(target, 'default', { value: mod, enumerable: true })
      : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true,
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => (all[name] = () => newValue),
    });
};
var __legacyDecorateClassTS = function (decorators, target, key, desc) {
  var c = arguments.length,
    r =
      c < 3 ? target : desc === null ? (desc = Object.getOwnPropertyDescriptor(target, key)) : desc,
    d;
  if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if ((d = decorators[i])) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return (c > 3 && r && Object.defineProperty(target, key, r), r);
};
var __legacyDecorateParamTS = (index, decorator) => (target, key) => decorator(target, key, index);
var __legacyMetadataTS = (k, v) => {
  if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
    return Reflect.metadata(k, v);
};
var __esm = (fn, res) => () => (fn && (res = fn((fn = 0))), res);
var __require = import.meta.require;

// ../../node_modules/.bun/reflect-metadata@0.2.2/node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS(() => {
  /*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var Reflect2;
  (function (Reflect3) {
    (function (factory) {
      var root =
        typeof globalThis === 'object'
          ? globalThis
          : typeof global === 'object'
            ? global
            : typeof self === 'object'
              ? self
              : typeof this === 'object'
                ? this
                : sloppyModeThis();
      var exporter = makeExporter(Reflect3);
      if (typeof root.Reflect !== 'undefined') {
        exporter = makeExporter(root.Reflect, exporter);
      }
      factory(exporter, root);
      if (typeof root.Reflect === 'undefined') {
        root.Reflect = Reflect3;
      }
      function makeExporter(target, previous) {
        return function (key, value) {
          Object.defineProperty(target, key, { configurable: true, writable: true, value });
          if (previous) previous(key, value);
        };
      }
      function functionThis() {
        try {
          return Function('return this;')();
        } catch (_) {}
      }
      function indirectEvalThis() {
        try {
          return (undefined, eval)('(function() { return this; })()');
        } catch (_) {}
      }
      function sloppyModeThis() {
        return functionThis() || indirectEvalThis();
      }
    })(function (exporter, root) {
      var hasOwn = Object.prototype.hasOwnProperty;
      var supportsSymbol = typeof Symbol === 'function';
      var toPrimitiveSymbol =
        supportsSymbol && typeof Symbol.toPrimitive !== 'undefined'
          ? Symbol.toPrimitive
          : '@@toPrimitive';
      var iteratorSymbol =
        supportsSymbol && typeof Symbol.iterator !== 'undefined' ? Symbol.iterator : '@@iterator';
      var supportsCreate = typeof Object.create === 'function';
      var supportsProto = { __proto__: [] } instanceof Array;
      var downLevel = !supportsCreate && !supportsProto;
      var HashMap = {
        create: supportsCreate
          ? function () {
              return MakeDictionary(Object.create(null));
            }
          : supportsProto
            ? function () {
                return MakeDictionary({ __proto__: null });
              }
            : function () {
                return MakeDictionary({});
              },
        has: downLevel
          ? function (map, key) {
              return hasOwn.call(map, key);
            }
          : function (map, key) {
              return key in map;
            },
        get: downLevel
          ? function (map, key) {
              return hasOwn.call(map, key) ? map[key] : undefined;
            }
          : function (map, key) {
              return map[key];
            },
      };
      var functionPrototype = Object.getPrototypeOf(Function);
      var _Map =
        typeof Map === 'function' && typeof Map.prototype.entries === 'function'
          ? Map
          : CreateMapPolyfill();
      var _Set =
        typeof Set === 'function' && typeof Set.prototype.entries === 'function'
          ? Set
          : CreateSetPolyfill();
      var _WeakMap = typeof WeakMap === 'function' ? WeakMap : CreateWeakMapPolyfill();
      var registrySymbol = supportsSymbol ? Symbol.for('@reflect-metadata:registry') : undefined;
      var metadataRegistry = GetOrCreateMetadataRegistry();
      var metadataProvider = CreateMetadataProvider(metadataRegistry);
      function decorate(decorators, target, propertyKey, attributes) {
        if (!IsUndefined(propertyKey)) {
          if (!IsArray(decorators)) throw new TypeError();
          if (!IsObject(target)) throw new TypeError();
          if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
            throw new TypeError();
          if (IsNull(attributes)) attributes = undefined;
          propertyKey = ToPropertyKey(propertyKey);
          return DecorateProperty(decorators, target, propertyKey, attributes);
        } else {
          if (!IsArray(decorators)) throw new TypeError();
          if (!IsConstructor(target)) throw new TypeError();
          return DecorateConstructor(decorators, target);
        }
      }
      exporter('decorate', decorate);
      function metadata(metadataKey, metadataValue) {
        function decorator(target, propertyKey) {
          if (!IsObject(target)) throw new TypeError();
          if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();
          OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        return decorator;
      }
      exporter('metadata', metadata);
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      exporter('defineMetadata', defineMetadata);
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      exporter('hasMetadata', hasMetadata);
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter('hasOwnMetadata', hasOwnMetadata);
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      exporter('getMetadata', getMetadata);
      function getOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
      }
      exporter('getOwnMetadata', getOwnMetadata);
      function getMetadataKeys(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryMetadataKeys(target, propertyKey);
      }
      exporter('getMetadataKeys', getMetadataKeys);
      function getOwnMetadataKeys(target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        return OrdinaryOwnMetadataKeys(target, propertyKey);
      }
      exporter('getOwnMetadataKeys', getOwnMetadataKeys);
      function deleteMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        if (!IsObject(target)) throw new TypeError();
        if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);
        var provider = GetMetadataProvider(target, propertyKey, false);
        if (IsUndefined(provider)) return false;
        return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
      }
      exporter('deleteMetadata', deleteMetadata);
      function DecorateConstructor(decorators, target) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsConstructor(decorated)) throw new TypeError();
            target = decorated;
          }
        }
        return target;
      }
      function DecorateProperty(decorators, target, propertyKey, descriptor) {
        for (var i = decorators.length - 1; i >= 0; --i) {
          var decorator = decorators[i];
          var decorated = decorator(target, propertyKey, descriptor);
          if (!IsUndefined(decorated) && !IsNull(decorated)) {
            if (!IsObject(decorated)) throw new TypeError();
            descriptor = decorated;
          }
        }
        return descriptor;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2) return true;
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);
        return false;
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider)) return false;
        return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn2) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);
        return;
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (IsUndefined(provider)) return;
        return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        var provider = GetMetadataProvider(O, P, true);
        provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);
      }
      function OrdinaryMetadataKeys(O, P) {
        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        if (parent === null) return ownKeys;
        var parentKeys = OrdinaryMetadataKeys(parent, P);
        if (parentKeys.length <= 0) return ownKeys;
        if (ownKeys.length <= 0) return parentKeys;
        var set = new _Set();
        var keys = [];
        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
          var key = ownKeys_1[_i];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
          var key = parentKeys_1[_a];
          var hasKey = set.has(key);
          if (!hasKey) {
            set.add(key);
            keys.push(key);
          }
        }
        return keys;
      }
      function OrdinaryOwnMetadataKeys(O, P) {
        var provider = GetMetadataProvider(O, P, false);
        if (!provider) {
          return [];
        }
        return provider.OrdinaryOwnMetadataKeys(O, P);
      }
      function Type(x) {
        if (x === null) return 1;
        switch (typeof x) {
          case 'undefined':
            return 0;
          case 'boolean':
            return 2;
          case 'string':
            return 3;
          case 'symbol':
            return 4;
          case 'number':
            return 5;
          case 'object':
            return x === null ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x) {
        return x === undefined;
      }
      function IsNull(x) {
        return x === null;
      }
      function IsSymbol(x) {
        return typeof x === 'symbol';
      }
      function IsObject(x) {
        return typeof x === 'object' ? x !== null : typeof x === 'function';
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
            return input;
          case 1:
            return input;
          case 2:
            return input;
          case 3:
            return input;
          case 4:
            return input;
          case 5:
            return input;
        }
        var hint = PreferredType === 3 ? 'string' : PreferredType === 5 ? 'number' : 'default';
        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (exoticToPrim !== undefined) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result)) throw new TypeError();
          return result;
        }
        return OrdinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
        if (hint === 'string') {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result)) return result;
          }
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result)) return result;
          }
        } else {
          var valueOf = O.valueOf;
          if (IsCallable(valueOf)) {
            var result = valueOf.call(O);
            if (!IsObject(result)) return result;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var result = toString_2.call(O);
            if (!IsObject(result)) return result;
          }
        }
        throw new TypeError();
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return '' + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3);
        if (IsSymbol(key)) return key;
        return ToString(key);
      }
      function IsArray(argument) {
        return Array.isArray
          ? Array.isArray(argument)
          : argument instanceof Object
            ? argument instanceof Array
            : Object.prototype.toString.call(argument) === '[object Array]';
      }
      function IsCallable(argument) {
        return typeof argument === 'function';
      }
      function IsConstructor(argument) {
        return typeof argument === 'function';
      }
      function IsPropertyKey(argument) {
        switch (Type(argument)) {
          case 3:
            return true;
          case 4:
            return true;
          default:
            return false;
        }
      }
      function SameValueZero(x, y) {
        return x === y || (x !== x && y !== y);
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (func === undefined || func === null) return;
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }
      function GetIterator(obj) {
        var method = GetMethod(obj, iteratorSymbol);
        if (!IsCallable(method)) throw new TypeError();
        var iterator = method.call(obj);
        if (!IsObject(iterator)) throw new TypeError();
        return iterator;
      }
      function IteratorValue(iterResult) {
        return iterResult.value;
      }
      function IteratorStep(iterator) {
        var result = iterator.next();
        return result.done ? false : result;
      }
      function IteratorClose(iterator) {
        var f = iterator['return'];
        if (f) f.call(iterator);
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if (typeof O !== 'function' || O === functionPrototype) return proto;
        if (proto !== functionPrototype) return proto;
        var prototype = O.prototype;
        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (prototypeProto == null || prototypeProto === Object.prototype) return proto;
        var constructor = prototypeProto.constructor;
        if (typeof constructor !== 'function') return proto;
        if (constructor === O) return proto;
        return constructor;
      }
      function CreateMetadataRegistry() {
        var fallback;
        if (
          !IsUndefined(registrySymbol) &&
          typeof root.Reflect !== 'undefined' &&
          !(registrySymbol in root.Reflect) &&
          typeof root.Reflect.defineMetadata === 'function'
        ) {
          fallback = CreateFallbackProvider(root.Reflect);
        }
        var first;
        var second;
        var rest;
        var targetProviderMap = new _WeakMap();
        var registry = {
          registerProvider,
          getProvider,
          setProvider,
        };
        return registry;
        function registerProvider(provider) {
          if (!Object.isExtensible(registry)) {
            throw new Error('Cannot add provider to a frozen registry.');
          }
          switch (true) {
            case fallback === provider:
              break;
            case IsUndefined(first):
              first = provider;
              break;
            case first === provider:
              break;
            case IsUndefined(second):
              second = provider;
              break;
            case second === provider:
              break;
            default:
              if (rest === undefined) rest = new _Set();
              rest.add(provider);
              break;
          }
        }
        function getProviderNoCache(O, P) {
          if (!IsUndefined(first)) {
            if (first.isProviderFor(O, P)) return first;
            if (!IsUndefined(second)) {
              if (second.isProviderFor(O, P)) return first;
              if (!IsUndefined(rest)) {
                var iterator = GetIterator(rest);
                while (true) {
                  var next = IteratorStep(iterator);
                  if (!next) {
                    return;
                  }
                  var provider = IteratorValue(next);
                  if (provider.isProviderFor(O, P)) {
                    IteratorClose(iterator);
                    return provider;
                  }
                }
              }
            }
          }
          if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {
            return fallback;
          }
          return;
        }
        function getProvider(O, P) {
          var providerMap = targetProviderMap.get(O);
          var provider;
          if (!IsUndefined(providerMap)) {
            provider = providerMap.get(P);
          }
          if (!IsUndefined(provider)) {
            return provider;
          }
          provider = getProviderNoCache(O, P);
          if (!IsUndefined(provider)) {
            if (IsUndefined(providerMap)) {
              providerMap = new _Map();
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return provider;
        }
        function hasProvider(provider) {
          if (IsUndefined(provider)) throw new TypeError();
          return (
            first === provider || second === provider || (!IsUndefined(rest) && rest.has(provider))
          );
        }
        function setProvider(O, P, provider) {
          if (!hasProvider(provider)) {
            throw new Error('Metadata provider not registered.');
          }
          var existingProvider = getProvider(O, P);
          if (existingProvider !== provider) {
            if (!IsUndefined(existingProvider)) {
              return false;
            }
            var providerMap = targetProviderMap.get(O);
            if (IsUndefined(providerMap)) {
              providerMap = new _Map();
              targetProviderMap.set(O, providerMap);
            }
            providerMap.set(P, provider);
          }
          return true;
        }
      }
      function GetOrCreateMetadataRegistry() {
        var metadataRegistry2;
        if (
          !IsUndefined(registrySymbol) &&
          IsObject(root.Reflect) &&
          Object.isExtensible(root.Reflect)
        ) {
          metadataRegistry2 = root.Reflect[registrySymbol];
        }
        if (IsUndefined(metadataRegistry2)) {
          metadataRegistry2 = CreateMetadataRegistry();
        }
        if (
          !IsUndefined(registrySymbol) &&
          IsObject(root.Reflect) &&
          Object.isExtensible(root.Reflect)
        ) {
          Object.defineProperty(root.Reflect, registrySymbol, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: metadataRegistry2,
          });
        }
        return metadataRegistry2;
      }
      function CreateMetadataProvider(registry) {
        var metadata2 = new _WeakMap();
        var provider = {
          isProviderFor: function (O, P) {
            var targetMetadata = metadata2.get(O);
            if (IsUndefined(targetMetadata)) return false;
            return targetMetadata.has(P);
          },
          OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
          OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
          OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
          OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
          OrdinaryDeleteMetadata,
        };
        metadataRegistry.registerProvider(provider);
        return provider;
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = metadata2.get(O);
          var createdTargetMetadata = false;
          if (IsUndefined(targetMetadata)) {
            if (!Create) return;
            targetMetadata = new _Map();
            metadata2.set(O, targetMetadata);
            createdTargetMetadata = true;
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create) return;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
            if (!registry.setProvider(O, P, provider)) {
              targetMetadata.delete(P);
              if (createdTargetMetadata) {
                metadata2.delete(O);
              }
              throw new Error('Wrong provider for target.');
            }
          }
          return metadataMap;
        }
        function OrdinaryHasOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap)) return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetOwnMetadata2(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap)) return;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryOwnMetadataKeys2(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap)) return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function OrdinaryDeleteMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap)) return false;
          if (!metadataMap.delete(MetadataKey)) return false;
          if (metadataMap.size === 0) {
            var targetMetadata = metadata2.get(O);
            if (!IsUndefined(targetMetadata)) {
              targetMetadata.delete(P);
              if (targetMetadata.size === 0) {
                metadata2.delete(targetMetadata);
              }
            }
          }
          return true;
        }
      }
      function CreateFallbackProvider(reflect) {
        var {
          defineMetadata: defineMetadata2,
          hasOwnMetadata: hasOwnMetadata2,
          getOwnMetadata: getOwnMetadata2,
          getOwnMetadataKeys: getOwnMetadataKeys2,
          deleteMetadata: deleteMetadata2,
        } = reflect;
        var metadataOwner = new _WeakMap();
        var provider = {
          isProviderFor: function (O, P) {
            var metadataPropertySet = metadataOwner.get(O);
            if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P)) {
              return true;
            }
            if (getOwnMetadataKeys2(O, P).length) {
              if (IsUndefined(metadataPropertySet)) {
                metadataPropertySet = new _Set();
                metadataOwner.set(O, metadataPropertySet);
              }
              metadataPropertySet.add(P);
              return true;
            }
            return false;
          },
          OrdinaryDefineOwnMetadata: defineMetadata2,
          OrdinaryHasOwnMetadata: hasOwnMetadata2,
          OrdinaryGetOwnMetadata: getOwnMetadata2,
          OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
          OrdinaryDeleteMetadata: deleteMetadata2,
        };
        return provider;
      }
      function GetMetadataProvider(O, P, Create) {
        var registeredProvider = metadataRegistry.getProvider(O, P);
        if (!IsUndefined(registeredProvider)) {
          return registeredProvider;
        }
        if (Create) {
          if (metadataRegistry.setProvider(O, P, metadataProvider)) {
            return metadataProvider;
          }
          throw new Error('Illegal state.');
        }
        return;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {};
        var arraySentinel = [];
        var MapIterator = (function () {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype['@@iterator'] = function () {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function () {
            return this;
          };
          MapIterator2.prototype.next = function () {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: undefined, done: true };
          };
          MapIterator2.prototype.throw = function (error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function (value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        })();
        var Map2 = (function () {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, 'size', {
            get: function () {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true,
          });
          Map3.prototype.has = function (key) {
            return this._find(key, false) >= 0;
          };
          Map3.prototype.get = function (key) {
            var index = this._find(key, false);
            return index >= 0 ? this._values[index] : undefined;
          };
          Map3.prototype.set = function (key, value) {
            var index = this._find(key, true);
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function (key) {
            var index = this._find(key, false);
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1; i < size; i++) {
                this._keys[i - 1] = this._keys[i];
                this._values[i - 1] = this._values[i];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function () {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function () {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function () {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function () {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype['@@iterator'] = function () {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function () {
            return this.entries();
          };
          Map3.prototype._find = function (key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i = 0; i < this._keys.length; i++) {
                if (SameValueZero(this._keys[i], key)) {
                  this._cacheIndex = i;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(undefined);
            }
            return this._cacheIndex;
          };
          return Map3;
        })();
        return Map2;
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        var Set2 = (function () {
          function Set3() {
            this._map = new _Map();
          }
          Object.defineProperty(Set3.prototype, 'size', {
            get: function () {
              return this._map.size;
            },
            enumerable: true,
            configurable: true,
          });
          Set3.prototype.has = function (value) {
            return this._map.has(value);
          };
          Set3.prototype.add = function (value) {
            return (this._map.set(value, value), this);
          };
          Set3.prototype.delete = function (value) {
            return this._map.delete(value);
          };
          Set3.prototype.clear = function () {
            this._map.clear();
          };
          Set3.prototype.keys = function () {
            return this._map.keys();
          };
          Set3.prototype.values = function () {
            return this._map.keys();
          };
          Set3.prototype.entries = function () {
            return this._map.entries();
          };
          Set3.prototype['@@iterator'] = function () {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function () {
            return this.keys();
          };
          return Set3;
        })();
        return Set2;
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16;
        var keys = HashMap.create();
        var rootKey = CreateUniqueKey();
        return (function () {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function (target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function (target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? HashMap.get(table, this._key) : undefined;
          };
          WeakMap2.prototype.set = function (target, value) {
            var table = GetOrCreateWeakMapTable(target, true);
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function (target) {
            var table = GetOrCreateWeakMapTable(target, false);
            return table !== undefined ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function () {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        })();
        function CreateUniqueKey() {
          var key;
          do key = '@@WeakMap@@' + CreateUUID();
          while (HashMap.has(keys, key));
          keys[key] = true;
          return key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create) return;
            Object.defineProperty(target, rootKey, { value: HashMap.create() });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i = 0; i < size; ++i) buffer[i] = (Math.random() * 255) | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          if (typeof Uint8Array === 'function') {
            var array = new Uint8Array(size);
            if (typeof crypto !== 'undefined') {
              crypto.getRandomValues(array);
            } else if (typeof msCrypto !== 'undefined') {
              msCrypto.getRandomValues(array);
            } else {
              FillRandomBytes(array, size);
            }
            return array;
          }
          return FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = (data[6] & 79) | 64;
          data[8] = (data[8] & 191) | 128;
          var result = '';
          for (var offset = 0; offset < UUID_SIZE; ++offset) {
            var byte = data[offset];
            if (offset === 4 || offset === 6 || offset === 8) result += '-';
            if (byte < 16) result += '0';
            result += byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        obj.__ = undefined;
        delete obj.__;
        return obj;
      }
    });
  })(Reflect2 || (Reflect2 = {}));
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/lifecycle.js
var Lifecycle, lifecycle_default;
var init_lifecycle = __esm(() => {
  (function (Lifecycle2) {
    Lifecycle2[(Lifecycle2['Transient'] = 0)] = 'Transient';
    Lifecycle2[(Lifecycle2['Singleton'] = 1)] = 'Singleton';
    Lifecycle2[(Lifecycle2['ResolutionScoped'] = 2)] = 'ResolutionScoped';
    Lifecycle2[(Lifecycle2['ContainerScoped'] = 3)] = 'ContainerScoped';
  })(Lifecycle || (Lifecycle = {}));
  lifecycle_default = Lifecycle;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/index.js
var init_types = __esm(() => {
  init_lifecycle();
});

// ../../node_modules/.bun/tslib@1.14.1/node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function (factory) {
    var root =
      typeof global === 'object'
        ? global
        : typeof self === 'object'
          ? self
          : typeof this === 'object'
            ? this
            : {};
    if (typeof define === 'function' && define.amd) {
      define('tslib', ['exports'], function (exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === 'object' && typeof exports === 'object') {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === 'function') {
          Object.defineProperty(exports2, '__esModule', { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function (id, v) {
        return (exports2[id] = previous ? previous(id, v) : v);
      };
    }
  })(function (exporter) {
    var extendStatics =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (d, b) {
          d.__proto__ = b;
        }) ||
      function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };
    __extends = function (d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
    };
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    __rest = function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function (decorators, target, key, desc) {
      var c = arguments.length,
        r =
          c < 3
            ? target
            : desc === null
              ? (desc = Object.getOwnPropertyDescriptor(target, key))
              : desc,
        d;
      if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if ((d = decorators[i]))
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return (c > 3 && r && Object.defineProperty(target, key, r), r);
    };
    __param = function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function (metadataKey, metadataValue) {
      if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function (thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P
          ? value
          : new P(function (resolve) {
              resolve(value);
            });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator['throw'](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function (thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: [],
        },
        f,
        y,
        t,
        g;
      return (
        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
        typeof Symbol === 'function' &&
          (g[Symbol.iterator] = function () {
            return this;
          }),
        g
      );
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError('Generator is already executing.');
        while (_)
          try {
            if (
              ((f = 1),
              y &&
                (t =
                  op[0] & 2
                    ? y['return']
                    : op[0]
                      ? y['throw'] || ((t = y['return']) && t.call(y), 0)
                      : y.next) &&
                !(t = t.call(y, op[1])).done)
            )
              return t;
            if (((y = 0), t)) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (
                  !((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
                  (op[0] === 6 || op[0] === 2)
                ) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __createBinding = function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    };
    __exportStar = function (m, exports2) {
      for (var p in m) if (p !== 'default' && !exports2.hasOwnProperty(p)) exports2[p] = m[p];
    };
    __values = function (o) {
      var s = typeof Symbol === 'function' && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === 'number')
        return {
          next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
          },
        };
      throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
    };
    __read = function (o, n) {
      var m = typeof Symbol === 'function' && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i['return'])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spread = function () {
      for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function () {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
      return r;
    };
    __await = function (v) {
      return this instanceof __await ? ((this.v = v), this) : new __await(v);
    };
    __asyncGenerator = function (thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
      var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
      return (
        (i = {}),
        verb('next'),
        verb('throw'),
        verb('return'),
        (i[Symbol.asyncIterator] = function () {
          return this;
        }),
        i
      );
      function verb(n) {
        if (g[n])
          i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await
          ? Promise.resolve(r.value.v).then(fulfill, reject)
          : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume('next', value);
      }
      function reject(value) {
        resume('throw', value);
      }
      function settle(f, v) {
        if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function (o) {
      var i, p;
      return (
        (i = {}),
        verb('next'),
        verb('throw', function (e) {
          throw e;
        }),
        verb('return'),
        (i[Symbol.iterator] = function () {
          return this;
        }),
        i
      );
      function verb(n, f) {
        i[n] = o[n]
          ? function (v) {
              return (p = !p) ? { value: __await(o[n](v)), done: n === 'return' } : f ? f(v) : v;
            }
          : f;
      }
    };
    __asyncValues = function (o) {
      if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
      var m = o[Symbol.asyncIterator],
        i;
      return m
        ? m.call(o)
        : ((o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator]()),
          (i = {}),
          verb('next'),
          verb('throw'),
          verb('return'),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i);
      function verb(n) {
        i[n] =
          o[n] &&
          function (v) {
            return new Promise(function (resolve, reject) {
              ((v = o[n](v)), settle(resolve, reject, v.done, v.value));
            });
          };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function (cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, 'raw', { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      }
      result['default'] = mod;
      return result;
    };
    __importDefault = function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function (receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError('attempted to get private field on non-instance');
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet = function (receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError('attempted to set private field on non-instance');
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter('__extends', __extends);
    exporter('__assign', __assign);
    exporter('__rest', __rest);
    exporter('__decorate', __decorate);
    exporter('__param', __param);
    exporter('__metadata', __metadata);
    exporter('__awaiter', __awaiter);
    exporter('__generator', __generator);
    exporter('__exportStar', __exportStar);
    exporter('__createBinding', __createBinding);
    exporter('__values', __values);
    exporter('__read', __read);
    exporter('__spread', __spread);
    exporter('__spreadArrays', __spreadArrays);
    exporter('__await', __await);
    exporter('__asyncGenerator', __asyncGenerator);
    exporter('__asyncDelegator', __asyncDelegator);
    exporter('__asyncValues', __asyncValues);
    exporter('__makeTemplateObject', __makeTemplateObject);
    exporter('__importStar', __importStar);
    exporter('__importDefault', __importDefault);
    exporter('__classPrivateFieldGet', __classPrivateFieldGet);
    exporter('__classPrivateFieldSet', __classPrivateFieldSet);
  });
});

// ../../node_modules/.bun/tslib@1.14.1/node_modules/tslib/modules/index.js
var import_tslib,
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet;
var init_modules = __esm(() => {
  import_tslib = __toESM(require_tslib(), 1);
  ({
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
  } = import_tslib.default);
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/reflection-helpers.js
function getParamInfo(target) {
  var params = Reflect.getMetadata('design:paramtypes', target) || [];
  var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
  Object.keys(injectionTokens).forEach(function (key) {
    params[+key] = injectionTokens[key];
  });
  return params;
}
function defineInjectionTokenMetadata(data, transform) {
  return function (target, _propertyKey, parameterIndex) {
    var descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    descriptors[parameterIndex] = transform
      ? {
          token: data,
          transform: transform.transformToken,
          transformArgs: transform.args || [],
        }
      : data;
    Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);
  };
}
var INJECTION_TOKEN_METADATA_KEY = 'injectionTokens';

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/class-provider.js
function isClassProvider(provider) {
  return !!provider.useClass;
}

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/factory-provider.js
function isFactoryProvider(provider) {
  return !!provider.useFactory;
}

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/lazy-helpers.js
var DelayedConstructor;
var init_lazy_helpers = __esm(() => {
  init_modules();
  DelayedConstructor = (function () {
    function DelayedConstructor2(wrap) {
      this.wrap = wrap;
      this.reflectMethods = [
        'get',
        'getPrototypeOf',
        'setPrototypeOf',
        'getOwnPropertyDescriptor',
        'defineProperty',
        'has',
        'set',
        'deleteProperty',
        'apply',
        'construct',
        'ownKeys',
      ];
    }
    DelayedConstructor2.prototype.createProxy = function (createObject) {
      var _this = this;
      var target = {};
      var init = false;
      var value;
      var delayedObject = function () {
        if (!init) {
          value = createObject(_this.wrap());
          init = true;
        }
        return value;
      };
      return new Proxy(target, this.createHandler(delayedObject));
    };
    DelayedConstructor2.prototype.createHandler = function (delayedObject) {
      var handler = {};
      var install = function (name) {
        handler[name] = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          args[0] = delayedObject();
          var method = Reflect[name];
          return method.apply(undefined, __spread(args));
        };
      };
      this.reflectMethods.forEach(install);
      return handler;
    };
    return DelayedConstructor2;
  })();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/injection-token.js
function isNormalToken(token) {
  return typeof token === 'string' || typeof token === 'symbol';
}
function isTokenDescriptor(descriptor) {
  return typeof descriptor === 'object' && 'token' in descriptor && 'multiple' in descriptor;
}
function isTransformDescriptor(descriptor) {
  return typeof descriptor === 'object' && 'token' in descriptor && 'transform' in descriptor;
}
function isConstructorToken(token) {
  return typeof token === 'function' || token instanceof DelayedConstructor;
}
var init_injection_token = __esm(() => {
  init_lazy_helpers();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/token-provider.js
function isTokenProvider(provider) {
  return !!provider.useToken;
}

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/value-provider.js
function isValueProvider(provider) {
  return provider.useValue != null;
}

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/index.js
var init_providers = __esm(() => {
  init_injection_token();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/providers/provider.js
function isProvider(provider) {
  return (
    isClassProvider(provider) ||
    isValueProvider(provider) ||
    isTokenProvider(provider) ||
    isFactoryProvider(provider)
  );
}
var init_provider = () => {};

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry-base.js
var RegistryBase, registry_base_default;
var init_registry_base = __esm(() => {
  RegistryBase = (function () {
    function RegistryBase2() {
      this._registryMap = new Map();
    }
    RegistryBase2.prototype.entries = function () {
      return this._registryMap.entries();
    };
    RegistryBase2.prototype.getAll = function (key) {
      this.ensure(key);
      return this._registryMap.get(key);
    };
    RegistryBase2.prototype.get = function (key) {
      this.ensure(key);
      var value = this._registryMap.get(key);
      return value[value.length - 1] || null;
    };
    RegistryBase2.prototype.set = function (key, value) {
      this.ensure(key);
      this._registryMap.get(key).push(value);
    };
    RegistryBase2.prototype.setAll = function (key, value) {
      this._registryMap.set(key, value);
    };
    RegistryBase2.prototype.has = function (key) {
      this.ensure(key);
      return this._registryMap.get(key).length > 0;
    };
    RegistryBase2.prototype.clear = function () {
      this._registryMap.clear();
    };
    RegistryBase2.prototype.ensure = function (key) {
      if (!this._registryMap.has(key)) {
        this._registryMap.set(key, []);
      }
    };
    return RegistryBase2;
  })();
  registry_base_default = RegistryBase;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/registry.js
var Registry, registry_default;
var init_registry = __esm(() => {
  init_modules();
  init_registry_base();
  Registry = (function (_super) {
    __extends(Registry2, _super);
    function Registry2() {
      return (_super !== null && _super.apply(this, arguments)) || this;
    }
    return Registry2;
  })(registry_base_default);
  registry_default = Registry;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/resolution-context.js
var ResolutionContext, resolution_context_default;
var init_resolution_context = __esm(() => {
  ResolutionContext = (function () {
    function ResolutionContext2() {
      this.scopedResolutions = new Map();
    }
    return ResolutionContext2;
  })();
  resolution_context_default = ResolutionContext;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/error-helpers.js
function formatDependency(params, idx) {
  if (params === null) {
    return 'at position #' + idx;
  }
  var argName = params.split(',')[idx].trim();
  return '"' + argName + '" at position #' + idx;
}
function composeErrorMessage(msg, e, indent) {
  if (indent === undefined) {
    indent = '    ';
  }
  return __spread(
    [msg],
    e.message
      .split(
        `
`
      )
      .map(function (l) {
        return indent + l;
      })
  ).join(`
`);
}
function formatErrorCtor(ctor, paramIdx, error) {
  var _a = __read(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2),
    _b = _a[1],
    params = _b === undefined ? null : _b;
  var dep = formatDependency(params, paramIdx);
  return composeErrorMessage(
    'Cannot inject the dependency ' + dep + ' of "' + ctor.name + '" constructor. Reason:',
    error
  );
}
var init_error_helpers = __esm(() => {
  init_modules();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/types/disposable.js
function isDisposable(value) {
  if (typeof value.dispose !== 'function') return false;
  var disposeFun = value.dispose;
  if (disposeFun.length > 0) {
    return false;
  }
  return true;
}

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/interceptors.js
var PreResolutionInterceptors, PostResolutionInterceptors, Interceptors, interceptors_default;
var init_interceptors = __esm(() => {
  init_modules();
  init_registry_base();
  PreResolutionInterceptors = (function (_super) {
    __extends(PreResolutionInterceptors2, _super);
    function PreResolutionInterceptors2() {
      return (_super !== null && _super.apply(this, arguments)) || this;
    }
    return PreResolutionInterceptors2;
  })(registry_base_default);
  PostResolutionInterceptors = (function (_super) {
    __extends(PostResolutionInterceptors2, _super);
    function PostResolutionInterceptors2() {
      return (_super !== null && _super.apply(this, arguments)) || this;
    }
    return PostResolutionInterceptors2;
  })(registry_base_default);
  Interceptors = (function () {
    function Interceptors2() {
      this.preResolution = new PreResolutionInterceptors();
      this.postResolution = new PostResolutionInterceptors();
    }
    return Interceptors2;
  })();
  interceptors_default = Interceptors;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/dependency-container.js
var typeInfo, InternalDependencyContainer, instance;
var init_dependency_container = __esm(() => {
  init_modules();
  init_providers();
  init_provider();
  init_injection_token();
  init_registry();
  init_lifecycle();
  init_resolution_context();
  init_error_helpers();
  init_lazy_helpers();
  init_interceptors();
  typeInfo = new Map();
  InternalDependencyContainer = (function () {
    function InternalDependencyContainer2(parent) {
      this.parent = parent;
      this._registry = new registry_default();
      this.interceptors = new interceptors_default();
      this.disposed = false;
      this.disposables = new Set();
    }
    InternalDependencyContainer2.prototype.register = function (
      token,
      providerOrConstructor,
      options
    ) {
      if (options === undefined) {
        options = { lifecycle: lifecycle_default.Transient };
      }
      this.ensureNotDisposed();
      var provider;
      if (!isProvider(providerOrConstructor)) {
        provider = { useClass: providerOrConstructor };
      } else {
        provider = providerOrConstructor;
      }
      if (isTokenProvider(provider)) {
        var path = [token];
        var tokenProvider = provider;
        while (tokenProvider != null) {
          var currentToken = tokenProvider.useToken;
          if (path.includes(currentToken)) {
            throw new Error(
              'Token registration cycle detected! ' + __spread(path, [currentToken]).join(' -> ')
            );
          }
          path.push(currentToken);
          var registration = this._registry.get(currentToken);
          if (registration && isTokenProvider(registration.provider)) {
            tokenProvider = registration.provider;
          } else {
            tokenProvider = null;
          }
        }
      }
      if (
        options.lifecycle === lifecycle_default.Singleton ||
        options.lifecycle == lifecycle_default.ContainerScoped ||
        options.lifecycle == lifecycle_default.ResolutionScoped
      ) {
        if (isValueProvider(provider) || isFactoryProvider(provider)) {
          throw new Error(
            'Cannot use lifecycle "' +
              lifecycle_default[options.lifecycle] +
              '" with ValueProviders or FactoryProviders'
          );
        }
      }
      this._registry.set(token, { provider, options });
      return this;
    };
    InternalDependencyContainer2.prototype.registerType = function (from, to) {
      this.ensureNotDisposed();
      if (isNormalToken(to)) {
        return this.register(from, {
          useToken: to,
        });
      }
      return this.register(from, {
        useClass: to,
      });
    };
    InternalDependencyContainer2.prototype.registerInstance = function (token, instance) {
      this.ensureNotDisposed();
      return this.register(token, {
        useValue: instance,
      });
    };
    InternalDependencyContainer2.prototype.registerSingleton = function (from, to) {
      this.ensureNotDisposed();
      if (isNormalToken(from)) {
        if (isNormalToken(to)) {
          return this.register(
            from,
            {
              useToken: to,
            },
            { lifecycle: lifecycle_default.Singleton }
          );
        } else if (to) {
          return this.register(
            from,
            {
              useClass: to,
            },
            { lifecycle: lifecycle_default.Singleton }
          );
        }
        throw new Error('Cannot register a type name as a singleton without a "to" token');
      }
      var useClass = from;
      if (to && !isNormalToken(to)) {
        useClass = to;
      }
      return this.register(
        from,
        {
          useClass,
        },
        { lifecycle: lifecycle_default.Singleton }
      );
    };
    InternalDependencyContainer2.prototype.resolve = function (token, context, isOptional) {
      if (context === undefined) {
        context = new resolution_context_default();
      }
      if (isOptional === undefined) {
        isOptional = false;
      }
      this.ensureNotDisposed();
      var registration = this.getRegistration(token);
      if (!registration && isNormalToken(token)) {
        if (isOptional) {
          return;
        }
        throw new Error(
          'Attempted to resolve unregistered dependency token: "' + token.toString() + '"'
        );
      }
      this.executePreResolutionInterceptor(token, 'Single');
      if (registration) {
        var result = this.resolveRegistration(registration, context);
        this.executePostResolutionInterceptor(token, result, 'Single');
        return result;
      }
      if (isConstructorToken(token)) {
        var result = this.construct(token, context);
        this.executePostResolutionInterceptor(token, result, 'Single');
        return result;
      }
      throw new Error(
        'Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.'
      );
    };
    InternalDependencyContainer2.prototype.executePreResolutionInterceptor = function (
      token,
      resolutionType
    ) {
      var e_1, _a;
      if (this.interceptors.preResolution.has(token)) {
        var remainingInterceptors = [];
        try {
          for (
            var _b = __values(this.interceptors.preResolution.getAll(token)), _c = _b.next();
            !_c.done;
            _c = _b.next()
          ) {
            var interceptor = _c.value;
            if (interceptor.options.frequency != 'Once') {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, resolutionType);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        this.interceptors.preResolution.setAll(token, remainingInterceptors);
      }
    };
    InternalDependencyContainer2.prototype.executePostResolutionInterceptor = function (
      token,
      result,
      resolutionType
    ) {
      var e_2, _a;
      if (this.interceptors.postResolution.has(token)) {
        var remainingInterceptors = [];
        try {
          for (
            var _b = __values(this.interceptors.postResolution.getAll(token)), _c = _b.next();
            !_c.done;
            _c = _b.next()
          ) {
            var interceptor = _c.value;
            if (interceptor.options.frequency != 'Once') {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, result, resolutionType);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        this.interceptors.postResolution.setAll(token, remainingInterceptors);
      }
    };
    InternalDependencyContainer2.prototype.resolveRegistration = function (registration, context) {
      this.ensureNotDisposed();
      if (
        registration.options.lifecycle === lifecycle_default.ResolutionScoped &&
        context.scopedResolutions.has(registration)
      ) {
        return context.scopedResolutions.get(registration);
      }
      var isSingleton = registration.options.lifecycle === lifecycle_default.Singleton;
      var isContainerScoped = registration.options.lifecycle === lifecycle_default.ContainerScoped;
      var returnInstance = isSingleton || isContainerScoped;
      var resolved;
      if (isValueProvider(registration.provider)) {
        resolved = registration.provider.useValue;
      } else if (isTokenProvider(registration.provider)) {
        resolved = returnInstance
          ? registration.instance ||
            (registration.instance = this.resolve(registration.provider.useToken, context))
          : this.resolve(registration.provider.useToken, context);
      } else if (isClassProvider(registration.provider)) {
        resolved = returnInstance
          ? registration.instance ||
            (registration.instance = this.construct(registration.provider.useClass, context))
          : this.construct(registration.provider.useClass, context);
      } else if (isFactoryProvider(registration.provider)) {
        resolved = registration.provider.useFactory(this);
      } else {
        resolved = this.construct(registration.provider, context);
      }
      if (registration.options.lifecycle === lifecycle_default.ResolutionScoped) {
        context.scopedResolutions.set(registration, resolved);
      }
      return resolved;
    };
    InternalDependencyContainer2.prototype.resolveAll = function (token, context, isOptional) {
      var _this = this;
      if (context === undefined) {
        context = new resolution_context_default();
      }
      if (isOptional === undefined) {
        isOptional = false;
      }
      this.ensureNotDisposed();
      var registrations = this.getAllRegistrations(token);
      if (!registrations && isNormalToken(token)) {
        if (isOptional) {
          return [];
        }
        throw new Error(
          'Attempted to resolve unregistered dependency token: "' + token.toString() + '"'
        );
      }
      this.executePreResolutionInterceptor(token, 'All');
      if (registrations) {
        var result_1 = registrations.map(function (item) {
          return _this.resolveRegistration(item, context);
        });
        this.executePostResolutionInterceptor(token, result_1, 'All');
        return result_1;
      }
      var result = [this.construct(token, context)];
      this.executePostResolutionInterceptor(token, result, 'All');
      return result;
    };
    InternalDependencyContainer2.prototype.isRegistered = function (token, recursive) {
      if (recursive === undefined) {
        recursive = false;
      }
      this.ensureNotDisposed();
      return (
        this._registry.has(token) ||
        (recursive && (this.parent || false) && this.parent.isRegistered(token, true))
      );
    };
    InternalDependencyContainer2.prototype.reset = function () {
      this.ensureNotDisposed();
      this._registry.clear();
      this.interceptors.preResolution.clear();
      this.interceptors.postResolution.clear();
    };
    InternalDependencyContainer2.prototype.clearInstances = function () {
      var e_3, _a;
      this.ensureNotDisposed();
      try {
        for (
          var _b = __values(this._registry.entries()), _c = _b.next();
          !_c.done;
          _c = _b.next()
        ) {
          var _d = __read(_c.value, 2),
            token = _d[0],
            registrations = _d[1];
          this._registry.setAll(
            token,
            registrations
              .filter(function (registration) {
                return !isValueProvider(registration.provider);
              })
              .map(function (registration) {
                registration.instance = undefined;
                return registration;
              })
          );
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
    };
    InternalDependencyContainer2.prototype.createChildContainer = function () {
      var e_4, _a;
      this.ensureNotDisposed();
      var childContainer = new InternalDependencyContainer2(this);
      try {
        for (
          var _b = __values(this._registry.entries()), _c = _b.next();
          !_c.done;
          _c = _b.next()
        ) {
          var _d = __read(_c.value, 2),
            token = _d[0],
            registrations = _d[1];
          if (
            registrations.some(function (_a2) {
              var options = _a2.options;
              return options.lifecycle === lifecycle_default.ContainerScoped;
            })
          ) {
            childContainer._registry.setAll(
              token,
              registrations.map(function (registration) {
                if (registration.options.lifecycle === lifecycle_default.ContainerScoped) {
                  return {
                    provider: registration.provider,
                    options: registration.options,
                  };
                }
                return registration;
              })
            );
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
      return childContainer;
    };
    InternalDependencyContainer2.prototype.beforeResolution = function (token, callback, options) {
      if (options === undefined) {
        options = { frequency: 'Always' };
      }
      this.interceptors.preResolution.set(token, {
        callback,
        options,
      });
    };
    InternalDependencyContainer2.prototype.afterResolution = function (token, callback, options) {
      if (options === undefined) {
        options = { frequency: 'Always' };
      }
      this.interceptors.postResolution.set(token, {
        callback,
        options,
      });
    };
    InternalDependencyContainer2.prototype.dispose = function () {
      return __awaiter(this, undefined, undefined, function () {
        var promises;
        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              this.disposed = true;
              promises = [];
              this.disposables.forEach(function (disposable) {
                var maybePromise = disposable.dispose();
                if (maybePromise) {
                  promises.push(maybePromise);
                }
              });
              return [4, Promise.all(promises)];
            case 1:
              _a.sent();
              return [2];
          }
        });
      });
    };
    InternalDependencyContainer2.prototype.getRegistration = function (token) {
      if (this.isRegistered(token)) {
        return this._registry.get(token);
      }
      if (this.parent) {
        return this.parent.getRegistration(token);
      }
      return null;
    };
    InternalDependencyContainer2.prototype.getAllRegistrations = function (token) {
      if (this.isRegistered(token)) {
        return this._registry.getAll(token);
      }
      if (this.parent) {
        return this.parent.getAllRegistrations(token);
      }
      return null;
    };
    InternalDependencyContainer2.prototype.construct = function (ctor, context) {
      var _this = this;
      if (ctor instanceof DelayedConstructor) {
        return ctor.createProxy(function (target) {
          return _this.resolve(target, context);
        });
      }
      var instance = (function () {
        var paramInfo = typeInfo.get(ctor);
        if (!paramInfo || paramInfo.length === 0) {
          if (ctor.length === 0) {
            return new ctor();
          } else {
            throw new Error('TypeInfo not known for "' + ctor.name + '"');
          }
        }
        var params = paramInfo.map(_this.resolveParams(context, ctor));
        return new (ctor.bind.apply(ctor, __spread([undefined], params)))();
      })();
      if (isDisposable(instance)) {
        this.disposables.add(instance);
      }
      return instance;
    };
    InternalDependencyContainer2.prototype.resolveParams = function (context, ctor) {
      var _this = this;
      return function (param, idx) {
        var _a, _b, _c;
        try {
          if (isTokenDescriptor(param)) {
            if (isTransformDescriptor(param)) {
              return param.multiple
                ? (_a = _this.resolve(param.transform)).transform.apply(
                    _a,
                    __spread(
                      [
                        _this.resolveAll(
                          param.token,
                          new resolution_context_default(),
                          param.isOptional
                        ),
                      ],
                      param.transformArgs
                    )
                  )
                : (_b = _this.resolve(param.transform)).transform.apply(
                    _b,
                    __spread(
                      [_this.resolve(param.token, context, param.isOptional)],
                      param.transformArgs
                    )
                  );
            } else {
              return param.multiple
                ? _this.resolveAll(param.token, new resolution_context_default(), param.isOptional)
                : _this.resolve(param.token, context, param.isOptional);
            }
          } else if (isTransformDescriptor(param)) {
            return (_c = _this.resolve(param.transform, context)).transform.apply(
              _c,
              __spread([_this.resolve(param.token, context)], param.transformArgs)
            );
          }
          return _this.resolve(param, context);
        } catch (e) {
          throw new Error(formatErrorCtor(ctor, idx, e));
        }
      };
    };
    InternalDependencyContainer2.prototype.ensureNotDisposed = function () {
      if (this.disposed) {
        throw new Error(
          'This container has been disposed, you cannot interact with a disposed container'
        );
      }
    };
    return InternalDependencyContainer2;
  })();
  instance = new InternalDependencyContainer();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/auto-injectable.js
var init_auto_injectable = __esm(() => {
  init_dependency_container();
  init_injection_token();
  init_error_helpers();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject.js
function inject(token, options) {
  var data = {
    token,
    multiple: false,
    isOptional: options && options.isOptional,
  };
  return defineInjectionTokenMetadata(data);
}
var inject_default;
var init_inject = __esm(() => {
  inject_default = inject;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/injectable.js
function injectable(options) {
  return function (target) {
    typeInfo.set(target, getParamInfo(target));
    if (options && options.token) {
      if (!Array.isArray(options.token)) {
        instance.register(options.token, target);
      } else {
        options.token.forEach(function (token) {
          instance.register(token, target);
        });
      }
    }
  };
}
var injectable_default;
var init_injectable = __esm(() => {
  init_dependency_container();
  init_dependency_container();
  injectable_default = injectable;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/registry.js
var init_registry2 = __esm(() => {
  init_dependency_container();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/singleton.js
function singleton() {
  return function (target) {
    injectable_default()(target);
    instance.registerSingleton(target);
  };
}
var singleton_default;
var init_singleton = __esm(() => {
  init_injectable();
  init_dependency_container();
  singleton_default = singleton;
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all.js
var init_inject_all = () => {};

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-all-with-transform.js
var init_inject_all_with_transform = () => {};

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/inject-with-transform.js
var init_inject_with_transform = () => {};

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/scoped.js
var init_scoped = __esm(() => {
  init_injectable();
  init_dependency_container();
});

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/decorators/index.js
var init_decorators = __esm(() => {
  init_auto_injectable();
  init_inject();
  init_injectable();
  init_registry2();
  init_singleton();
  init_inject_all();
  init_inject_all_with_transform();
  init_inject_with_transform();
  init_scoped();
});
// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/factories/index.js
var init_factories = () => {};

// ../../node_modules/.bun/tsyringe@4.10.0/node_modules/tsyringe/dist/esm5/index.js
var init_esm5 = __esm(() => {
  init_types();
  init_lazy_helpers();
  init_dependency_container();
  init_decorators();
  init_factories();
  init_providers();
  if (typeof Reflect === 'undefined' || !Reflect.getMetadata) {
    throw new Error(
      `tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`
    );
  }
});

// ../../node_modules/.bun/picocolors@1.1.1/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
  var p = process || {};
  var argv = p.argv || [];
  var env = p.env || {};
  var isColorSupported =
    !(!!env.NO_COLOR || argv.includes('--no-color')) &&
    (!!env.FORCE_COLOR ||
      argv.includes('--color') ||
      p.platform === 'win32' ||
      ((p.stdout || {}).isTTY && env.TERM !== 'dumb') ||
      !!env.CI);
  var formatter =
    (open, close, replace = open) =>
    (input) => {
      let string = '' + input,
        index = string.indexOf(close, open.length);
      return ~index
        ? open + replaceClose(string, close, replace, index) + close
        : open + string + close;
    };
  var replaceClose = (string, close, replace, index) => {
    let result = '',
      cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  var createColors = (enabled = isColorSupported) => {
    let f = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f('\x1B[0m', '\x1B[0m'),
      bold: f('\x1B[1m', '\x1B[22m', '\x1B[22m\x1B[1m'),
      dim: f('\x1B[2m', '\x1B[22m', '\x1B[22m\x1B[2m'),
      italic: f('\x1B[3m', '\x1B[23m'),
      underline: f('\x1B[4m', '\x1B[24m'),
      inverse: f('\x1B[7m', '\x1B[27m'),
      hidden: f('\x1B[8m', '\x1B[28m'),
      strikethrough: f('\x1B[9m', '\x1B[29m'),
      black: f('\x1B[30m', '\x1B[39m'),
      red: f('\x1B[31m', '\x1B[39m'),
      green: f('\x1B[32m', '\x1B[39m'),
      yellow: f('\x1B[33m', '\x1B[39m'),
      blue: f('\x1B[34m', '\x1B[39m'),
      magenta: f('\x1B[35m', '\x1B[39m'),
      cyan: f('\x1B[36m', '\x1B[39m'),
      white: f('\x1B[37m', '\x1B[39m'),
      gray: f('\x1B[90m', '\x1B[39m'),
      bgBlack: f('\x1B[40m', '\x1B[49m'),
      bgRed: f('\x1B[41m', '\x1B[49m'),
      bgGreen: f('\x1B[42m', '\x1B[49m'),
      bgYellow: f('\x1B[43m', '\x1B[49m'),
      bgBlue: f('\x1B[44m', '\x1B[49m'),
      bgMagenta: f('\x1B[45m', '\x1B[49m'),
      bgCyan: f('\x1B[46m', '\x1B[49m'),
      bgWhite: f('\x1B[47m', '\x1B[49m'),
      blackBright: f('\x1B[90m', '\x1B[39m'),
      redBright: f('\x1B[91m', '\x1B[39m'),
      greenBright: f('\x1B[92m', '\x1B[39m'),
      yellowBright: f('\x1B[93m', '\x1B[39m'),
      blueBright: f('\x1B[94m', '\x1B[39m'),
      magentaBright: f('\x1B[95m', '\x1B[39m'),
      cyanBright: f('\x1B[96m', '\x1B[39m'),
      whiteBright: f('\x1B[97m', '\x1B[39m'),
      bgBlackBright: f('\x1B[100m', '\x1B[49m'),
      bgRedBright: f('\x1B[101m', '\x1B[49m'),
      bgGreenBright: f('\x1B[102m', '\x1B[49m'),
      bgYellowBright: f('\x1B[103m', '\x1B[49m'),
      bgBlueBright: f('\x1B[104m', '\x1B[49m'),
      bgMagentaBright: f('\x1B[105m', '\x1B[49m'),
      bgCyanBright: f('\x1B[106m', '\x1B[49m'),
      bgWhiteBright: f('\x1B[107m', '\x1B[49m'),
    };
  };
  module.exports = createColors();
  module.exports.createColors = createColors;
});

// ../../packages/adapters/src/utils/constants.ts
var DEBUG_JSON_SPACING = 2,
  TEXT_LIMITS,
  FORMATTING,
  JSON_SERIALIZATION,
  COVERAGE_LEVELS,
  DISPLAY,
  FILE_PERMISSIONS,
  SAFE_FILE_PERMISSIONS,
  LISTS;
var init_constants = __esm(() => {
  TEXT_LIMITS = {
    AUTHOR_NAME_MAX: 100,
    MAX_LINE_LENGTH: 100,
    DESCRIPTION_MAX: 500,
    PROJECT_NAME_MAX: 50,
    PATH_MAX: 1000,
  };
  FORMATTING = {
    JSON_INDENT_SIZE: 2,
    TAB_WIDTH: 2,
    MAX_EMPTY_LINES: 2,
    SWITCH_CASE_OFFSET: 1,
  };
  JSON_SERIALIZATION = {
    PRETTY_INDENT: 2,
    DEEP_INDENT: 6,
  };
  COVERAGE_LEVELS = {
    LIGHT_THRESHOLD: 70,
    MEDIUM_THRESHOLD: 85,
    STRICT_THRESHOLD: 95,
    DEFAULT_STRICT: 80,
  };
  DISPLAY = {
    BORDER_LENGTH: 40,
    DEFAULT_STEP: 1,
  };
  FILE_PERMISSIONS = {
    OWNER_READ_WRITE_ALL_READ: 420,
    OWNER_FULL_GROUP_READ_EXECUTE: 493,
    OWNER_FULL_GROUP_EXECUTE: 488,
    OWNER_READ_WRITE_GROUP_ONLY: 416,
    OWNER_READ_WRITE_ONLY: 384,
    OWNER_FULL_ONLY: 448,
  };
  SAFE_FILE_PERMISSIONS = [
    FILE_PERMISSIONS.OWNER_READ_WRITE_ALL_READ,
    FILE_PERMISSIONS.OWNER_FULL_GROUP_READ_EXECUTE,
    FILE_PERMISSIONS.OWNER_FULL_GROUP_EXECUTE,
    FILE_PERMISSIONS.OWNER_READ_WRITE_GROUP_ONLY,
    FILE_PERMISSIONS.OWNER_READ_WRITE_ONLY,
    FILE_PERMISSIONS.OWNER_FULL_ONLY,
  ];
  LISTS = {
    INDEX_OFFSET: 1,
    MIN_NAME_LENGTH: 2,
    MAX_NAME_LENGTH: 50,
  };
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/key.js
var isUpKey = (key, keybindings = []) =>
    key.name === 'up' ||
    (keybindings.includes('vim') && key.name === 'k') ||
    (keybindings.includes('emacs') && key.ctrl && key.name === 'p'),
  isDownKey = (key, keybindings = []) =>
    key.name === 'down' ||
    (keybindings.includes('vim') && key.name === 'j') ||
    (keybindings.includes('emacs') && key.ctrl && key.name === 'n'),
  isSpaceKey = (key) => key.name === 'space',
  isBackspaceKey = (key) => key.name === 'backspace',
  isTabKey = (key) => key.name === 'tab',
  isNumberKey = (key) => '1234567890'.includes(key.name),
  isEnterKey = (key) => key.name === 'enter' || key.name === 'return';

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/errors.js
var AbortPromptError, CancelPromptError, ExitPromptError, HookError, ValidationError;
var init_errors = __esm(() => {
  AbortPromptError = class AbortPromptError extends Error {
    name = 'AbortPromptError';
    message = 'Prompt was aborted';
    constructor(options) {
      super();
      this.cause = options?.cause;
    }
  };
  CancelPromptError = class CancelPromptError extends Error {
    name = 'CancelPromptError';
    message = 'Prompt was canceled';
  };
  ExitPromptError = class ExitPromptError extends Error {
    name = 'ExitPromptError';
  };
  HookError = class HookError extends Error {
    name = 'HookError';
  };
  ValidationError = class ValidationError extends Error {
    name = 'ValidationError';
  };
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/hook-engine.js
import { AsyncLocalStorage, AsyncResource } from 'async_hooks';
function createStore(rl) {
  const store = {
    rl,
    hooks: [],
    hooksCleanup: [],
    hooksEffect: [],
    index: 0,
    handleChange() {},
  };
  return store;
}
function withHooks(rl, cb) {
  const store = createStore(rl);
  return hookStorage.run(store, () => {
    function cycle(render) {
      store.handleChange = () => {
        store.index = 0;
        render();
      };
      store.handleChange();
    }
    return cb(cycle);
  });
}
function getStore() {
  const store = hookStorage.getStore();
  if (!store) {
    throw new HookError('[Inquirer] Hook functions can only be called from within a prompt');
  }
  return store;
}
function readline() {
  return getStore().rl;
}
function withUpdates(fn) {
  const wrapped = (...args) => {
    const store = getStore();
    let shouldUpdate = false;
    const oldHandleChange = store.handleChange;
    store.handleChange = () => {
      shouldUpdate = true;
    };
    const returnValue = fn(...args);
    if (shouldUpdate) {
      oldHandleChange();
    }
    store.handleChange = oldHandleChange;
    return returnValue;
  };
  return AsyncResource.bind(wrapped);
}
function withPointer(cb) {
  const store = getStore();
  const { index } = store;
  const pointer = {
    get() {
      return store.hooks[index];
    },
    set(value) {
      store.hooks[index] = value;
    },
    initialized: index in store.hooks,
  };
  const returnValue = cb(pointer);
  store.index++;
  return returnValue;
}
function handleChange() {
  getStore().handleChange();
}
var hookStorage, effectScheduler;
var init_hook_engine = __esm(() => {
  init_errors();
  hookStorage = new AsyncLocalStorage();
  effectScheduler = {
    queue(cb) {
      const store = getStore();
      const { index } = store;
      store.hooksEffect.push(() => {
        store.hooksCleanup[index]?.();
        const cleanFn = cb(readline());
        if (cleanFn != null && typeof cleanFn !== 'function') {
          throw new ValidationError(
            'useEffect return value must be a cleanup function or nothing.'
          );
        }
        store.hooksCleanup[index] = cleanFn;
      });
    },
    run() {
      const store = getStore();
      withUpdates(() => {
        store.hooksEffect.forEach((effect) => {
          effect();
        });
        store.hooksEffect.length = 0;
      })();
    },
    clearAll() {
      const store = getStore();
      store.hooksCleanup.forEach((cleanFn) => {
        cleanFn?.();
      });
      store.hooksEffect.length = 0;
      store.hooksCleanup.length = 0;
    },
  };
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/use-state.js
import { AsyncResource as AsyncResource2 } from 'async_hooks';
function useState(defaultValue) {
  return withPointer((pointer) => {
    const setState = AsyncResource2.bind(function setState(newValue) {
      if (pointer.get() !== newValue) {
        pointer.set(newValue);
        handleChange();
      }
    });
    if (pointer.initialized) {
      return [pointer.get(), setState];
    }
    const value = typeof defaultValue === 'function' ? defaultValue() : defaultValue;
    pointer.set(value);
    return [value, setState];
  });
}
var init_use_state = __esm(() => {
  init_hook_engine();
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/use-effect.js
function useEffect(cb, depArray) {
  withPointer((pointer) => {
    const oldDeps = pointer.get();
    const hasChanged =
      !Array.isArray(oldDeps) || depArray.some((dep, i) => !Object.is(dep, oldDeps[i]));
    if (hasChanged) {
      effectScheduler.queue(cb);
    }
    pointer.set(depArray);
  });
}
var init_use_effect = __esm(() => {
  init_hook_engine();
});

// ../../node_modules/.bun/yoctocolors-cjs@2.1.3/node_modules/yoctocolors-cjs/index.js
var require_yoctocolors_cjs = __commonJS((exports, module) => {
  var tty = __require('tty');
  var hasColors = tty?.WriteStream?.prototype?.hasColors?.() ?? false;
  var format3 = (open, close) => {
    if (!hasColors) {
      return (input) => input;
    }
    const openCode = `\x1B[${open}m`;
    const closeCode = `\x1B[${close}m`;
    return (input) => {
      const string = input + '';
      let index = string.indexOf(closeCode);
      if (index === -1) {
        return openCode + string + closeCode;
      }
      let result = openCode;
      let lastIndex = 0;
      const reopenOnNestedClose = close === 22;
      const replaceCode = (reopenOnNestedClose ? closeCode : '') + openCode;
      while (index !== -1) {
        result += string.slice(lastIndex, index) + replaceCode;
        lastIndex = index + closeCode.length;
        index = string.indexOf(closeCode, lastIndex);
      }
      result += string.slice(lastIndex) + closeCode;
      return result;
    };
  };
  var colors = {};
  colors.reset = format3(0, 0);
  colors.bold = format3(1, 22);
  colors.dim = format3(2, 22);
  colors.italic = format3(3, 23);
  colors.underline = format3(4, 24);
  colors.overline = format3(53, 55);
  colors.inverse = format3(7, 27);
  colors.hidden = format3(8, 28);
  colors.strikethrough = format3(9, 29);
  colors.black = format3(30, 39);
  colors.red = format3(31, 39);
  colors.green = format3(32, 39);
  colors.yellow = format3(33, 39);
  colors.blue = format3(34, 39);
  colors.magenta = format3(35, 39);
  colors.cyan = format3(36, 39);
  colors.white = format3(37, 39);
  colors.gray = format3(90, 39);
  colors.bgBlack = format3(40, 49);
  colors.bgRed = format3(41, 49);
  colors.bgGreen = format3(42, 49);
  colors.bgYellow = format3(43, 49);
  colors.bgBlue = format3(44, 49);
  colors.bgMagenta = format3(45, 49);
  colors.bgCyan = format3(46, 49);
  colors.bgWhite = format3(47, 49);
  colors.bgGray = format3(100, 49);
  colors.redBright = format3(91, 39);
  colors.greenBright = format3(92, 39);
  colors.yellowBright = format3(93, 39);
  colors.blueBright = format3(94, 39);
  colors.magentaBright = format3(95, 39);
  colors.cyanBright = format3(96, 39);
  colors.whiteBright = format3(97, 39);
  colors.bgRedBright = format3(101, 49);
  colors.bgGreenBright = format3(102, 49);
  colors.bgYellowBright = format3(103, 49);
  colors.bgBlueBright = format3(104, 49);
  colors.bgMagentaBright = format3(105, 49);
  colors.bgCyanBright = format3(106, 49);
  colors.bgWhiteBright = format3(107, 49);
  module.exports = colors;
});

// ../../node_modules/.bun/@inquirer+figures@1.0.14/node_modules/@inquirer/figures/dist/esm/index.js
import process2 from 'process';
function isUnicodeSupported() {
  if (process2.platform !== 'win32') {
    return process2.env['TERM'] !== 'linux';
  }
  return (
    Boolean(process2.env['WT_SESSION']) ||
    Boolean(process2.env['TERMINUS_SUBLIME']) ||
    process2.env['ConEmuTask'] === '{cmd::Cmder}' ||
    process2.env['TERM_PROGRAM'] === 'Terminus-Sublime' ||
    process2.env['TERM_PROGRAM'] === 'vscode' ||
    process2.env['TERM'] === 'xterm-256color' ||
    process2.env['TERM'] === 'alacritty' ||
    process2.env['TERMINAL_EMULATOR'] === 'JetBrains-JediTerm'
  );
}
var common,
  specialMainSymbols,
  specialFallbackSymbols,
  mainSymbols,
  fallbackSymbols,
  shouldUseMain,
  figures,
  esm_default2,
  replacements;
var init_esm = __esm(() => {
  common = {
    circleQuestionMark: '(?)',
    questionMarkPrefix: '(?)',
    square: '\u2588',
    squareDarkShade: '\u2593',
    squareMediumShade: '\u2592',
    squareLightShade: '\u2591',
    squareTop: '\u2580',
    squareBottom: '\u2584',
    squareLeft: '\u258C',
    squareRight: '\u2590',
    squareCenter: '\u25A0',
    bullet: '\u25CF',
    dot: '\u2024',
    ellipsis: '\u2026',
    pointerSmall: '\u203A',
    triangleUp: '\u25B2',
    triangleUpSmall: '\u25B4',
    triangleDown: '\u25BC',
    triangleDownSmall: '\u25BE',
    triangleLeftSmall: '\u25C2',
    triangleRightSmall: '\u25B8',
    home: '\u2302',
    heart: '\u2665',
    musicNote: '\u266A',
    musicNoteBeamed: '\u266B',
    arrowUp: '\u2191',
    arrowDown: '\u2193',
    arrowLeft: '\u2190',
    arrowRight: '\u2192',
    arrowLeftRight: '\u2194',
    arrowUpDown: '\u2195',
    almostEqual: '\u2248',
    notEqual: '\u2260',
    lessOrEqual: '\u2264',
    greaterOrEqual: '\u2265',
    identical: '\u2261',
    infinity: '\u221E',
    subscriptZero: '\u2080',
    subscriptOne: '\u2081',
    subscriptTwo: '\u2082',
    subscriptThree: '\u2083',
    subscriptFour: '\u2084',
    subscriptFive: '\u2085',
    subscriptSix: '\u2086',
    subscriptSeven: '\u2087',
    subscriptEight: '\u2088',
    subscriptNine: '\u2089',
    oneHalf: '\xBD',
    oneThird: '\u2153',
    oneQuarter: '\xBC',
    oneFifth: '\u2155',
    oneSixth: '\u2159',
    oneEighth: '\u215B',
    twoThirds: '\u2154',
    twoFifths: '\u2156',
    threeQuarters: '\xBE',
    threeFifths: '\u2157',
    threeEighths: '\u215C',
    fourFifths: '\u2158',
    fiveSixths: '\u215A',
    fiveEighths: '\u215D',
    sevenEighths: '\u215E',
    line: '\u2500',
    lineBold: '\u2501',
    lineDouble: '\u2550',
    lineDashed0: '\u2504',
    lineDashed1: '\u2505',
    lineDashed2: '\u2508',
    lineDashed3: '\u2509',
    lineDashed4: '\u254C',
    lineDashed5: '\u254D',
    lineDashed6: '\u2574',
    lineDashed7: '\u2576',
    lineDashed8: '\u2578',
    lineDashed9: '\u257A',
    lineDashed10: '\u257C',
    lineDashed11: '\u257E',
    lineDashed12: '\u2212',
    lineDashed13: '\u2013',
    lineDashed14: '\u2010',
    lineDashed15: '\u2043',
    lineVertical: '\u2502',
    lineVerticalBold: '\u2503',
    lineVerticalDouble: '\u2551',
    lineVerticalDashed0: '\u2506',
    lineVerticalDashed1: '\u2507',
    lineVerticalDashed2: '\u250A',
    lineVerticalDashed3: '\u250B',
    lineVerticalDashed4: '\u254E',
    lineVerticalDashed5: '\u254F',
    lineVerticalDashed6: '\u2575',
    lineVerticalDashed7: '\u2577',
    lineVerticalDashed8: '\u2579',
    lineVerticalDashed9: '\u257B',
    lineVerticalDashed10: '\u257D',
    lineVerticalDashed11: '\u257F',
    lineDownLeft: '\u2510',
    lineDownLeftArc: '\u256E',
    lineDownBoldLeftBold: '\u2513',
    lineDownBoldLeft: '\u2512',
    lineDownLeftBold: '\u2511',
    lineDownDoubleLeftDouble: '\u2557',
    lineDownDoubleLeft: '\u2556',
    lineDownLeftDouble: '\u2555',
    lineDownRight: '\u250C',
    lineDownRightArc: '\u256D',
    lineDownBoldRightBold: '\u250F',
    lineDownBoldRight: '\u250E',
    lineDownRightBold: '\u250D',
    lineDownDoubleRightDouble: '\u2554',
    lineDownDoubleRight: '\u2553',
    lineDownRightDouble: '\u2552',
    lineUpLeft: '\u2518',
    lineUpLeftArc: '\u256F',
    lineUpBoldLeftBold: '\u251B',
    lineUpBoldLeft: '\u251A',
    lineUpLeftBold: '\u2519',
    lineUpDoubleLeftDouble: '\u255D',
    lineUpDoubleLeft: '\u255C',
    lineUpLeftDouble: '\u255B',
    lineUpRight: '\u2514',
    lineUpRightArc: '\u2570',
    lineUpBoldRightBold: '\u2517',
    lineUpBoldRight: '\u2516',
    lineUpRightBold: '\u2515',
    lineUpDoubleRightDouble: '\u255A',
    lineUpDoubleRight: '\u2559',
    lineUpRightDouble: '\u2558',
    lineUpDownLeft: '\u2524',
    lineUpBoldDownBoldLeftBold: '\u252B',
    lineUpBoldDownBoldLeft: '\u2528',
    lineUpDownLeftBold: '\u2525',
    lineUpBoldDownLeftBold: '\u2529',
    lineUpDownBoldLeftBold: '\u252A',
    lineUpDownBoldLeft: '\u2527',
    lineUpBoldDownLeft: '\u2526',
    lineUpDoubleDownDoubleLeftDouble: '\u2563',
    lineUpDoubleDownDoubleLeft: '\u2562',
    lineUpDownLeftDouble: '\u2561',
    lineUpDownRight: '\u251C',
    lineUpBoldDownBoldRightBold: '\u2523',
    lineUpBoldDownBoldRight: '\u2520',
    lineUpDownRightBold: '\u251D',
    lineUpBoldDownRightBold: '\u2521',
    lineUpDownBoldRightBold: '\u2522',
    lineUpDownBoldRight: '\u251F',
    lineUpBoldDownRight: '\u251E',
    lineUpDoubleDownDoubleRightDouble: '\u2560',
    lineUpDoubleDownDoubleRight: '\u255F',
    lineUpDownRightDouble: '\u255E',
    lineDownLeftRight: '\u252C',
    lineDownBoldLeftBoldRightBold: '\u2533',
    lineDownLeftBoldRightBold: '\u252F',
    lineDownBoldLeftRight: '\u2530',
    lineDownBoldLeftBoldRight: '\u2531',
    lineDownBoldLeftRightBold: '\u2532',
    lineDownLeftRightBold: '\u252E',
    lineDownLeftBoldRight: '\u252D',
    lineDownDoubleLeftDoubleRightDouble: '\u2566',
    lineDownDoubleLeftRight: '\u2565',
    lineDownLeftDoubleRightDouble: '\u2564',
    lineUpLeftRight: '\u2534',
    lineUpBoldLeftBoldRightBold: '\u253B',
    lineUpLeftBoldRightBold: '\u2537',
    lineUpBoldLeftRight: '\u2538',
    lineUpBoldLeftBoldRight: '\u2539',
    lineUpBoldLeftRightBold: '\u253A',
    lineUpLeftRightBold: '\u2536',
    lineUpLeftBoldRight: '\u2535',
    lineUpDoubleLeftDoubleRightDouble: '\u2569',
    lineUpDoubleLeftRight: '\u2568',
    lineUpLeftDoubleRightDouble: '\u2567',
    lineUpDownLeftRight: '\u253C',
    lineUpBoldDownBoldLeftBoldRightBold: '\u254B',
    lineUpDownBoldLeftBoldRightBold: '\u2548',
    lineUpBoldDownLeftBoldRightBold: '\u2547',
    lineUpBoldDownBoldLeftRightBold: '\u254A',
    lineUpBoldDownBoldLeftBoldRight: '\u2549',
    lineUpBoldDownLeftRight: '\u2540',
    lineUpDownBoldLeftRight: '\u2541',
    lineUpDownLeftBoldRight: '\u253D',
    lineUpDownLeftRightBold: '\u253E',
    lineUpBoldDownBoldLeftRight: '\u2542',
    lineUpDownLeftBoldRightBold: '\u253F',
    lineUpBoldDownLeftBoldRight: '\u2543',
    lineUpBoldDownLeftRightBold: '\u2544',
    lineUpDownBoldLeftBoldRight: '\u2545',
    lineUpDownBoldLeftRightBold: '\u2546',
    lineUpDoubleDownDoubleLeftDoubleRightDouble: '\u256C',
    lineUpDoubleDownDoubleLeftRight: '\u256B',
    lineUpDownLeftDoubleRightDouble: '\u256A',
    lineCross: '\u2573',
    lineBackslash: '\u2572',
    lineSlash: '\u2571',
  };
  specialMainSymbols = {
    tick: '\u2714',
    info: '\u2139',
    warning: '\u26A0',
    cross: '\u2718',
    squareSmall: '\u25FB',
    squareSmallFilled: '\u25FC',
    circle: '\u25EF',
    circleFilled: '\u25C9',
    circleDotted: '\u25CC',
    circleDouble: '\u25CE',
    circleCircle: '\u24DE',
    circleCross: '\u24E7',
    circlePipe: '\u24BE',
    radioOn: '\u25C9',
    radioOff: '\u25EF',
    checkboxOn: '\u2612',
    checkboxOff: '\u2610',
    checkboxCircleOn: '\u24E7',
    checkboxCircleOff: '\u24BE',
    pointer: '\u276F',
    triangleUpOutline: '\u25B3',
    triangleLeft: '\u25C0',
    triangleRight: '\u25B6',
    lozenge: '\u25C6',
    lozengeOutline: '\u25C7',
    hamburger: '\u2630',
    smiley: '\u32E1',
    mustache: '\u0DF4',
    star: '\u2605',
    play: '\u25B6',
    nodejs: '\u2B22',
    oneSeventh: '\u2150',
    oneNinth: '\u2151',
    oneTenth: '\u2152',
  };
  specialFallbackSymbols = {
    tick: '\u221A',
    info: 'i',
    warning: '\u203C',
    cross: '\xD7',
    squareSmall: '\u25A1',
    squareSmallFilled: '\u25A0',
    circle: '( )',
    circleFilled: '(*)',
    circleDotted: '( )',
    circleDouble: '( )',
    circleCircle: '(\u25CB)',
    circleCross: '(\xD7)',
    circlePipe: '(\u2502)',
    radioOn: '(*)',
    radioOff: '( )',
    checkboxOn: '[\xD7]',
    checkboxOff: '[ ]',
    checkboxCircleOn: '(\xD7)',
    checkboxCircleOff: '( )',
    pointer: '>',
    triangleUpOutline: '\u2206',
    triangleLeft: '\u25C4',
    triangleRight: '\u25BA',
    lozenge: '\u2666',
    lozengeOutline: '\u25CA',
    hamburger: '\u2261',
    smiley: '\u263A',
    mustache: '\u250C\u2500\u2510',
    star: '\u2736',
    play: '\u25BA',
    nodejs: '\u2666',
    oneSeventh: '1/7',
    oneNinth: '1/9',
    oneTenth: '1/10',
  };
  mainSymbols = { ...common, ...specialMainSymbols };
  fallbackSymbols = {
    ...common,
    ...specialFallbackSymbols,
  };
  shouldUseMain = isUnicodeSupported();
  figures = shouldUseMain ? mainSymbols : fallbackSymbols;
  esm_default2 = figures;
  replacements = Object.entries(specialMainSymbols);
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/theme.js
var import_yoctocolors_cjs, defaultTheme;
var init_theme = __esm(() => {
  init_esm();
  import_yoctocolors_cjs = __toESM(require_yoctocolors_cjs(), 1);
  defaultTheme = {
    prefix: {
      idle: import_yoctocolors_cjs.default.blue('?'),
      done: import_yoctocolors_cjs.default.green(esm_default2.tick),
    },
    spinner: {
      interval: 80,
      frames: [
        '\u280B',
        '\u2819',
        '\u2839',
        '\u2838',
        '\u283C',
        '\u2834',
        '\u2826',
        '\u2827',
        '\u2807',
        '\u280F',
      ].map((frame) => import_yoctocolors_cjs.default.yellow(frame)),
    },
    style: {
      answer: import_yoctocolors_cjs.default.cyan,
      message: import_yoctocolors_cjs.default.bold,
      error: (text) => import_yoctocolors_cjs.default.red(`> ${text}`),
      defaultAnswer: (text) => import_yoctocolors_cjs.default.dim(`(${text})`),
      help: import_yoctocolors_cjs.default.dim,
      highlight: import_yoctocolors_cjs.default.cyan,
      key: (text) =>
        import_yoctocolors_cjs.default.cyan(import_yoctocolors_cjs.default.bold(`<${text}>`)),
    },
  };
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/make-theme.js
function isPlainObject(value) {
  if (typeof value !== 'object' || value === null) return false;
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
function deepMerge(...objects) {
  const output = {};
  for (const obj of objects) {
    for (const [key, value] of Object.entries(obj)) {
      const prevValue = output[key];
      output[key] =
        isPlainObject(prevValue) && isPlainObject(value) ? deepMerge(prevValue, value) : value;
    }
  }
  return output;
}
function makeTheme(...themes) {
  const themesToMerge = [defaultTheme, ...themes.filter((theme) => theme != null)];
  return deepMerge(...themesToMerge);
}
var init_make_theme = __esm(() => {
  init_theme();
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/use-prefix.js
function usePrefix({ status = 'idle', theme }) {
  const [showLoader, setShowLoader] = useState(false);
  const [tick, setTick] = useState(0);
  const { prefix, spinner } = makeTheme(theme);
  useEffect(() => {
    if (status === 'loading') {
      let tickInterval;
      let inc = -1;
      const delayTimeout = setTimeout(() => {
        setShowLoader(true);
        tickInterval = setInterval(() => {
          inc = inc + 1;
          setTick(inc % spinner.frames.length);
        }, spinner.interval);
      }, 300);
      return () => {
        clearTimeout(delayTimeout);
        clearInterval(tickInterval);
      };
    } else {
      setShowLoader(false);
    }
  }, [status]);
  if (showLoader) {
    return spinner.frames[tick];
  }
  const iconName = status === 'loading' ? 'idle' : status;
  return typeof prefix === 'string' ? prefix : (prefix[iconName] ?? prefix['idle']);
}
var init_use_prefix = __esm(() => {
  init_use_state();
  init_use_effect();
  init_make_theme();
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/use-memo.js
function useMemo(fn, dependencies) {
  return withPointer((pointer) => {
    const prev = pointer.get();
    if (
      !prev ||
      prev.dependencies.length !== dependencies.length ||
      prev.dependencies.some((dep, i) => dep !== dependencies[i])
    ) {
      const value = fn();
      pointer.set({ value, dependencies });
      return value;
    }
    return prev.value;
  });
}
var init_use_memo = __esm(() => {
  init_hook_engine();
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/use-ref.js
function useRef(val) {
  return useState({ current: val })[0];
}
var init_use_ref = __esm(() => {
  init_use_state();
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/use-keypress.js
function useKeypress(userHandler) {
  const signal = useRef(userHandler);
  signal.current = userHandler;
  useEffect((rl) => {
    let ignore = false;
    const handler = withUpdates((_input, event) => {
      if (ignore) return;
      signal.current(event, rl);
    });
    rl.input.on('keypress', handler);
    return () => {
      ignore = true;
      rl.input.removeListener('keypress', handler);
    };
  }, []);
}
var init_use_keypress = __esm(() => {
  init_use_ref();
  init_use_effect();
  init_hook_engine();
});

// ../../node_modules/.bun/cli-width@4.1.0/node_modules/cli-width/index.js
var require_cli_width = __commonJS((exports, module) => {
  module.exports = cliWidth;
  function normalizeOpts(options) {
    const defaultOpts = {
      defaultWidth: 0,
      output: process.stdout,
      tty: __require('tty'),
    };
    if (!options) {
      return defaultOpts;
    }
    Object.keys(defaultOpts).forEach(function (key) {
      if (!options[key]) {
        options[key] = defaultOpts[key];
      }
    });
    return options;
  }
  function cliWidth(options) {
    const opts = normalizeOpts(options);
    if (opts.output.getWindowSize) {
      return opts.output.getWindowSize()[0] || opts.defaultWidth;
    }
    if (opts.tty.getWindowSize) {
      return opts.tty.getWindowSize()[1] || opts.defaultWidth;
    }
    if (opts.output.columns) {
      return opts.output.columns;
    }
    if (process.env.CLI_WIDTH) {
      const width = parseInt(process.env.CLI_WIDTH, 10);
      if (!isNaN(width) && width !== 0) {
        return width;
      }
    }
    return opts.defaultWidth;
  }
});

// ../../node_modules/.bun/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS((exports, module) => {
  module.exports = ({ onlyFirst = false } = {}) => {
    const pattern = [
      '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
      '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))',
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
  };
});

// ../../node_modules/.bun/strip-ansi@6.0.1/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS((exports, module) => {
  var ansiRegex = require_ansi_regex();
  module.exports = (string) =>
    typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
});

// ../../node_modules/.bun/is-fullwidth-code-point@3.0.0/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS((exports, module) => {
  var isFullwidthCodePoint = (codePoint) => {
    if (Number.isNaN(codePoint)) {
      return false;
    }
    if (
      codePoint >= 4352 &&
      (codePoint <= 4447 ||
        codePoint === 9001 ||
        codePoint === 9002 ||
        (11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351) ||
        (12880 <= codePoint && codePoint <= 19903) ||
        (19968 <= codePoint && codePoint <= 42182) ||
        (43360 <= codePoint && codePoint <= 43388) ||
        (44032 <= codePoint && codePoint <= 55203) ||
        (63744 <= codePoint && codePoint <= 64255) ||
        (65040 <= codePoint && codePoint <= 65049) ||
        (65072 <= codePoint && codePoint <= 65131) ||
        (65281 <= codePoint && codePoint <= 65376) ||
        (65504 <= codePoint && codePoint <= 65510) ||
        (110592 <= codePoint && codePoint <= 110593) ||
        (127488 <= codePoint && codePoint <= 127569) ||
        (131072 <= codePoint && codePoint <= 262141))
    ) {
      return true;
    }
    return false;
  };
  module.exports = isFullwidthCodePoint;
  module.exports.default = isFullwidthCodePoint;
});

// ../../node_modules/.bun/emoji-regex@8.0.0/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS((exports, module) => {
  module.exports = function () {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../../node_modules/.bun/string-width@4.2.3/node_modules/string-width/index.js
var require_string_width = __commonJS((exports, module) => {
  var stripAnsi2 = require_strip_ansi();
  var isFullwidthCodePoint = require_is_fullwidth_code_point();
  var emojiRegex = require_emoji_regex();
  var stringWidth = (string) => {
    if (typeof string !== 'string' || string.length === 0) {
      return 0;
    }
    string = stripAnsi2(string);
    if (string.length === 0) {
      return 0;
    }
    string = string.replace(emojiRegex(), '  ');
    let width = 0;
    for (let i = 0; i < string.length; i++) {
      const code = string.codePointAt(i);
      if (code <= 31 || (code >= 127 && code <= 159)) {
        continue;
      }
      if (code >= 768 && code <= 879) {
        continue;
      }
      if (code > 65535) {
        i++;
      }
      width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
  };
  module.exports = stringWidth;
  module.exports.default = stringWidth;
});

// ../../node_modules/.bun/color-name@1.1.4/node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  };
});

// ../../node_modules/.bun/color-convert@2.0.1/node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert = {
    rgb: { channels: 3, labels: 'rgb' },
    hsl: { channels: 3, labels: 'hsl' },
    hsv: { channels: 3, labels: 'hsv' },
    hwb: { channels: 3, labels: 'hwb' },
    cmyk: { channels: 4, labels: 'cmyk' },
    xyz: { channels: 3, labels: 'xyz' },
    lab: { channels: 3, labels: 'lab' },
    lch: { channels: 3, labels: 'lch' },
    hex: { channels: 1, labels: ['hex'] },
    keyword: { channels: 1, labels: ['keyword'] },
    ansi16: { channels: 1, labels: ['ansi16'] },
    ansi256: { channels: 1, labels: ['ansi256'] },
    hcg: { channels: 3, labels: ['h', 'c', 'g'] },
    apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
    gray: { channels: 1, labels: ['gray'] },
  };
  module.exports = convert;
  for (const model of Object.keys(convert)) {
    if (!('channels' in convert[model])) {
      throw new Error('missing channels property: ' + model);
    }
    if (!('labels' in convert[model])) {
      throw new Error('missing channel labels property: ' + model);
    }
    if (convert[model].labels.length !== convert[model].channels) {
      throw new Error('channel and label counts mismatch: ' + model);
    }
    const { channels, labels } = convert[model];
    delete convert[model].channels;
    delete convert[model].labels;
    Object.defineProperty(convert[model], 'channels', { value: channels });
    Object.defineProperty(convert[model], 'labels', { value: labels });
  }
  convert.rgb.hsl = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function (rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function (c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [h * 360, s * 100, v * 100];
  };
  convert.rgb.hwb = function (rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert.rgb.hsl(rgb)[0];
    const w = (1 / 255) * Math.min(r, Math.min(g, b));
    b = 1 - (1 / 255) * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert.rgb.keyword = function (rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function (keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function (rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function (rgb) {
    const xyz = convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function (hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + (1 / 3) * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function (hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function (hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function (hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function (hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function (cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function (xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function (xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 0.008856 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 0.008856 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 0.008856 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function (lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = (hr * 360) / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function (lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = (h / 360) * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function (args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi2 =
      30 + ((Math.round(b / 255) << 2) | (Math.round(g / 255) << 1) | Math.round(r / 255));
    if (value === 2) {
      ansi2 += 60;
    }
    return ansi2;
  };
  convert.hsv.ansi16 = function (args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function (args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round(((r - 8) / 247) * 24) + 232;
    }
    const ansi2 =
      16 +
      36 * Math.round((r / 255) * 5) +
      6 * Math.round((g / 255) * 5) +
      Math.round((b / 255) * 5);
    return ansi2;
  };
  convert.ansi16.rgb = function (args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = (color / 10.5) * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = ((color >> 1) & 1) * mult * 255;
    const b = ((color >> 2) & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function (args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = (Math.floor(args / 36) / 5) * 255;
    const g = (Math.floor((rem = args % 36) / 6) / 5) * 255;
    const b = ((rem % 6) / 5) * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function (args) {
    const integer =
      ((Math.round(args[0]) & 255) << 16) +
      ((Math.round(args[1]) & 255) << 8) +
      (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };
  convert.hex.rgb = function (args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString
        .split('')
        .map((char) => {
          return char + char;
        })
        .join('');
    }
    const integer = parseInt(colorString, 16);
    const r = (integer >> 16) & 255;
    const g = (integer >> 8) & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function (rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = ((g - b) / chroma) % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert.hsl.hcg = function (hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function (hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function (hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = (h % 1) * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
  };
  convert.hcg.hsv = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function (hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function (hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function (apple) {
    return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
  };
  convert.rgb.apple = function (rgb) {
    return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
  };
  convert.gray.rgb = function (args) {
    return [(args[0] / 100) * 255, (args[0] / 100) * 255, (args[0] / 100) * 255];
  };
  convert.gray.hsl = function (args) {
    return [0, 0, args[0]];
  };
  convert.gray.hsv = convert.gray.hsl;
  convert.gray.hwb = function (gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function (gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function (gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function (gray) {
    const val = Math.round((gray[0] / 100) * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return '000000'.substring(string.length) + string;
  };
  convert.rgb.gray = function (rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [(val / 255) * 100];
  };
});

// ../../node_modules/.bun/color-convert@2.0.1/node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null,
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function (fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// ../../node_modules/.bun/color-convert@2.0.1/node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function (...args) {
      const arg0 = args[0];
      if (arg0 === undefined || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === 'object') {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels,
    });
    Object.defineProperty(convert[fromModel], 'labels', { value: conversions[fromModel].labels });
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert;
});

// ../../node_modules/.bun/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports, module) => {
  var wrapAnsi16 =
    (fn, offset) =>
    (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
  var wrapAnsi256 =
    (fn, offset) =>
    (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
  var wrapAnsi16m =
    (fn, offset) =>
    (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
  var ansi2ansi = (n) => n;
  var rgb2rgb = (r, g, b) => [r, g, b];
  var setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true,
        });
        return value;
      },
      enumerable: true,
      configurable: true,
    });
  };
  var colorConvert;
  var makeDynamicStyles = (wrap2, targetSpace, identity, isBackground) => {
    if (colorConvert === undefined) {
      colorConvert = require_color_convert();
    }
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
      if (sourceSpace === targetSpace) {
        styles[name] = wrap2(identity, offset);
      } else if (typeof suite === 'object') {
        styles[name] = wrap2(suite[targetSpace], offset);
      }
    }
    return styles;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39],
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49],
      },
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`,
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false,
      });
    }
    Object.defineProperty(styles, 'codes', {
      value: codes,
      enumerable: false,
    });
    styles.color.close = '\x1B[39m';
    styles.bgColor.close = '\x1B[49m';
    setLazyProperty(styles.color, 'ansi', () =>
      makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false)
    );
    setLazyProperty(styles.color, 'ansi256', () =>
      makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false)
    );
    setLazyProperty(styles.color, 'ansi16m', () =>
      makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false)
    );
    setLazyProperty(styles.bgColor, 'ansi', () =>
      makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true)
    );
    setLazyProperty(styles.bgColor, 'ansi256', () =>
      makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true)
    );
    setLazyProperty(styles.bgColor, 'ansi16m', () =>
      makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true)
    );
    return styles;
  }
  Object.defineProperty(module, 'exports', {
    enumerable: true,
    get: assembleStyles,
  });
});

// ../../node_modules/.bun/wrap-ansi@6.2.0/node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS((exports, module) => {
  var stringWidth = require_string_width();
  var stripAnsi2 = require_strip_ansi();
  var ansiStyles = require_ansi_styles();
  var ESCAPES = new Set(['\x1B', '\x9B']);
  var END_CODE = 39;
  var wrapAnsi = (code) => `${ESCAPES.values().next().value}[${code}m`;
  var wordLengths = (string) => string.split(' ').map((character) => stringWidth(character));
  var wrapWord = (rows, word, columns) => {
    const characters = [...word];
    let isInsideEscape = false;
    let visible = stringWidth(stripAnsi2(rows[rows.length - 1]));
    for (const [index, character] of characters.entries()) {
      const characterLength = stringWidth(character);
      if (visible + characterLength <= columns) {
        rows[rows.length - 1] += character;
      } else {
        rows.push(character);
        visible = 0;
      }
      if (ESCAPES.has(character)) {
        isInsideEscape = true;
      } else if (isInsideEscape && character === 'm') {
        isInsideEscape = false;
        continue;
      }
      if (isInsideEscape) {
        continue;
      }
      visible += characterLength;
      if (visible === columns && index < characters.length - 1) {
        rows.push('');
        visible = 0;
      }
    }
    if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
      rows[rows.length - 2] += rows.pop();
    }
  };
  var stringVisibleTrimSpacesRight = (str) => {
    const words = str.split(' ');
    let last = words.length;
    while (last > 0) {
      if (stringWidth(words[last - 1]) > 0) {
        break;
      }
      last--;
    }
    if (last === words.length) {
      return str;
    }
    return words.slice(0, last).join(' ') + words.slice(last).join('');
  };
  var exec = (string, columns, options = {}) => {
    if (options.trim !== false && string.trim() === '') {
      return '';
    }
    let pre = '';
    let ret = '';
    let escapeCode;
    const lengths = wordLengths(string);
    let rows = [''];
    for (const [index, word] of string.split(' ').entries()) {
      if (options.trim !== false) {
        rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
      }
      let rowLength = stringWidth(rows[rows.length - 1]);
      if (index !== 0) {
        if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
          rows.push('');
          rowLength = 0;
        }
        if (rowLength > 0 || options.trim === false) {
          rows[rows.length - 1] += ' ';
          rowLength++;
        }
      }
      if (options.hard && lengths[index] > columns) {
        const remainingColumns = columns - rowLength;
        const breaksStartingThisLine =
          1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
        const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
        if (breaksStartingNextLine < breaksStartingThisLine) {
          rows.push('');
        }
        wrapWord(rows, word, columns);
        continue;
      }
      if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
        if (options.wordWrap === false && rowLength < columns) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows.push('');
      }
      if (rowLength + lengths[index] > columns && options.wordWrap === false) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows[rows.length - 1] += word;
    }
    if (options.trim !== false) {
      rows = rows.map(stringVisibleTrimSpacesRight);
    }
    pre = rows.join(`
`);
    for (const [index, character] of [...pre].entries()) {
      ret += character;
      if (ESCAPES.has(character)) {
        const code2 = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
        escapeCode = code2 === END_CODE ? null : code2;
      }
      const code = ansiStyles.codes.get(Number(escapeCode));
      if (escapeCode && code) {
        if (
          pre[index + 1] ===
          `
`
        ) {
          ret += wrapAnsi(code);
        } else if (
          character ===
          `
`
        ) {
          ret += wrapAnsi(escapeCode);
        }
      }
    }
    return ret;
  };
  module.exports = (string, columns, options) => {
    return String(string)
      .normalize()
      .replace(
        /\r\n/g,
        `
`
      )
      .split(
        `
`
      )
      .map((line) => exec(line, columns, options)).join(`
`);
  };
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/utils.js
function breakLines(content, width) {
  return content
    .split(
      `
`
    )
    .flatMap((line) =>
      import_wrap_ansi
        .default(line, width, { trim: false, hard: true })
        .split(
          `
`
        )
        .map((str) => str.trimEnd())
    ).join(`
`);
}
function readlineWidth() {
  return import_cli_width.default({ defaultWidth: 80, output: readline().output });
}
var import_cli_width, import_wrap_ansi;
var init_utils = __esm(() => {
  init_hook_engine();
  import_cli_width = __toESM(require_cli_width(), 1);
  import_wrap_ansi = __toESM(require_wrap_ansi(), 1);
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/pagination/use-pagination.js
function usePointerPosition({ active, renderedItems, pageSize, loop }) {
  const state = useRef({
    lastPointer: active,
    lastActive: undefined,
  });
  const { lastPointer, lastActive } = state.current;
  const middle = Math.floor(pageSize / 2);
  const renderedLength = renderedItems.reduce((acc, item) => acc + item.length, 0);
  const defaultPointerPosition = renderedItems
    .slice(0, active)
    .reduce((acc, item) => acc + item.length, 0);
  let pointer = defaultPointerPosition;
  if (renderedLength > pageSize) {
    if (loop) {
      pointer = lastPointer;
      if (lastActive != null && lastActive < active && active - lastActive < pageSize) {
        pointer = Math.min(
          middle,
          Math.abs(active - lastActive) === 1
            ? Math.min(
                lastPointer + (renderedItems[lastActive]?.length ?? 0),
                Math.max(defaultPointerPosition, lastPointer)
              )
            : lastPointer + active - lastActive
        );
      }
    } else {
      const spaceUnderActive = renderedItems
        .slice(active)
        .reduce((acc, item) => acc + item.length, 0);
      pointer =
        spaceUnderActive < pageSize - middle
          ? pageSize - spaceUnderActive
          : Math.min(defaultPointerPosition, middle);
    }
  }
  state.current.lastPointer = pointer;
  state.current.lastActive = active;
  return pointer;
}
function usePagination({ items, active, renderItem, pageSize, loop = true }) {
  const width = readlineWidth();
  const bound = (num) => ((num % items.length) + items.length) % items.length;
  const renderedItems = items.map((item, index) => {
    if (item == null) return [];
    return breakLines(renderItem({ item, index, isActive: index === active }), width).split(`
`);
  });
  const renderedLength = renderedItems.reduce((acc, item) => acc + item.length, 0);
  const renderItemAtIndex = (index) => renderedItems[index] ?? [];
  const pointer = usePointerPosition({ active, renderedItems, pageSize, loop });
  const activeItem = renderItemAtIndex(active).slice(0, pageSize);
  const activeItemPosition =
    pointer + activeItem.length <= pageSize ? pointer : pageSize - activeItem.length;
  const pageBuffer = Array.from({ length: pageSize });
  pageBuffer.splice(activeItemPosition, activeItem.length, ...activeItem);
  const itemVisited = new Set([active]);
  let bufferPointer = activeItemPosition + activeItem.length;
  let itemPointer = bound(active + 1);
  while (
    bufferPointer < pageSize &&
    !itemVisited.has(itemPointer) &&
    (loop && renderedLength > pageSize ? itemPointer !== active : itemPointer > active)
  ) {
    const lines = renderItemAtIndex(itemPointer);
    const linesToAdd = lines.slice(0, pageSize - bufferPointer);
    pageBuffer.splice(bufferPointer, linesToAdd.length, ...linesToAdd);
    itemVisited.add(itemPointer);
    bufferPointer += linesToAdd.length;
    itemPointer = bound(itemPointer + 1);
  }
  bufferPointer = activeItemPosition - 1;
  itemPointer = bound(active - 1);
  while (
    bufferPointer >= 0 &&
    !itemVisited.has(itemPointer) &&
    (loop && renderedLength > pageSize ? itemPointer !== active : itemPointer < active)
  ) {
    const lines = renderItemAtIndex(itemPointer);
    const linesToAdd = lines.slice(Math.max(0, lines.length - bufferPointer - 1));
    pageBuffer.splice(bufferPointer - linesToAdd.length + 1, linesToAdd.length, ...linesToAdd);
    itemVisited.add(itemPointer);
    bufferPointer -= linesToAdd.length;
    itemPointer = bound(itemPointer - 1);
  }
  return pageBuffer.filter((line) => typeof line === 'string').join(`
`);
}
var init_use_pagination = __esm(() => {
  init_use_ref();
  init_utils();
});

// ../../node_modules/.bun/mute-stream@2.0.0/node_modules/mute-stream/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var Stream = __require('stream');

  class MuteStream extends Stream {
    #isTTY = null;
    constructor(opts = {}) {
      super(opts);
      this.writable = this.readable = true;
      this.muted = false;
      this.on('pipe', this._onpipe);
      this.replace = opts.replace;
      this._prompt = opts.prompt || null;
      this._hadControl = false;
    }
    #destSrc(key, def) {
      if (this._dest) {
        return this._dest[key];
      }
      if (this._src) {
        return this._src[key];
      }
      return def;
    }
    #proxy(method, ...args) {
      if (typeof this._dest?.[method] === 'function') {
        this._dest[method](...args);
      }
      if (typeof this._src?.[method] === 'function') {
        this._src[method](...args);
      }
    }
    get isTTY() {
      if (this.#isTTY !== null) {
        return this.#isTTY;
      }
      return this.#destSrc('isTTY', false);
    }
    set isTTY(val) {
      this.#isTTY = val;
    }
    get rows() {
      return this.#destSrc('rows');
    }
    get columns() {
      return this.#destSrc('columns');
    }
    mute() {
      this.muted = true;
    }
    unmute() {
      this.muted = false;
    }
    _onpipe(src) {
      this._src = src;
    }
    pipe(dest, options) {
      this._dest = dest;
      return super.pipe(dest, options);
    }
    pause() {
      if (this._src) {
        return this._src.pause();
      }
    }
    resume() {
      if (this._src) {
        return this._src.resume();
      }
    }
    write(c) {
      if (this.muted) {
        if (!this.replace) {
          return true;
        }
        if (c.match(/^\u001b/)) {
          if (c.indexOf(this._prompt) === 0) {
            c = c.slice(this._prompt.length);
            c = c.replace(/./g, this.replace);
            c = this._prompt + c;
          }
          this._hadControl = true;
          return this.emit('data', c);
        } else {
          if (this._prompt && this._hadControl && c.indexOf(this._prompt) === 0) {
            this._hadControl = false;
            this.emit('data', this._prompt);
            c = c.slice(this._prompt.length);
          }
          c = c.toString().replace(/./g, this.replace);
        }
      }
      this.emit('data', c);
    }
    end(c) {
      if (this.muted) {
        if (c && this.replace) {
          c = c.toString().replace(/./g, this.replace);
        } else {
          c = null;
        }
      }
      if (c) {
        this.emit('data', c);
      }
      this.emit('end');
    }
    destroy(...args) {
      return this.#proxy('destroy', ...args);
    }
    destroySoon(...args) {
      return this.#proxy('destroySoon', ...args);
    }
    close(...args) {
      return this.#proxy('close', ...args);
    }
  }
  module.exports = MuteStream;
});

// ../../node_modules/.bun/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/signals.js
var signals;
var init_signals = __esm(() => {
  signals = [];
  signals.push('SIGHUP', 'SIGINT', 'SIGTERM');
  if (process.platform !== 'win32') {
    signals.push(
      'SIGALRM',
      'SIGABRT',
      'SIGVTALRM',
      'SIGXCPU',
      'SIGXFSZ',
      'SIGUSR2',
      'SIGTRAP',
      'SIGSYS',
      'SIGQUIT',
      'SIGIOT'
    );
  }
  if (process.platform === 'linux') {
    signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');
  }
});

// ../../node_modules/.bun/signal-exit@4.1.0/node_modules/signal-exit/dist/mjs/index.js
class Emitter {
  emitted = {
    afterExit: false,
    exit: false,
  };
  listeners = {
    afterExit: [],
    exit: [],
  };
  count = 0;
  id = Math.random();
  constructor() {
    if (global2[kExitEmitter]) {
      return global2[kExitEmitter];
    }
    ObjectDefineProperty(global2, kExitEmitter, {
      value: this,
      writable: false,
      enumerable: false,
      configurable: false,
    });
  }
  on(ev, fn) {
    this.listeners[ev].push(fn);
  }
  removeListener(ev, fn) {
    const list = this.listeners[ev];
    const i = list.indexOf(fn);
    if (i === -1) {
      return;
    }
    if (i === 0 && list.length === 1) {
      list.length = 0;
    } else {
      list.splice(i, 1);
    }
  }
  emit(ev, code, signal) {
    if (this.emitted[ev]) {
      return false;
    }
    this.emitted[ev] = true;
    let ret = false;
    for (const fn of this.listeners[ev]) {
      ret = fn(code, signal) === true || ret;
    }
    if (ev === 'exit') {
      ret = this.emit('afterExit', code, signal) || ret;
    }
    return ret;
  }
}

class SignalExitBase {}
var processOk = (process3) =>
    !!process3 &&
    typeof process3 === 'object' &&
    typeof process3.removeListener === 'function' &&
    typeof process3.emit === 'function' &&
    typeof process3.reallyExit === 'function' &&
    typeof process3.listeners === 'function' &&
    typeof process3.kill === 'function' &&
    typeof process3.pid === 'number' &&
    typeof process3.on === 'function',
  kExitEmitter,
  global2,
  ObjectDefineProperty,
  signalExitWrap = (handler) => {
    return {
      onExit(cb, opts) {
        return handler.onExit(cb, opts);
      },
      load() {
        return handler.load();
      },
      unload() {
        return handler.unload();
      },
    };
  },
  SignalExitFallback,
  SignalExit,
  process3,
  onExit,
  load,
  unload;
var init_mjs = __esm(() => {
  init_signals();
  kExitEmitter = Symbol.for('signal-exit emitter');
  global2 = globalThis;
  ObjectDefineProperty = Object.defineProperty.bind(Object);
  SignalExitFallback = class SignalExitFallback extends SignalExitBase {
    onExit() {
      return () => {};
    }
    load() {}
    unload() {}
  };
  SignalExit = class SignalExit extends SignalExitBase {
    #hupSig = process3.platform === 'win32' ? 'SIGINT' : 'SIGHUP';
    #emitter = new Emitter();
    #process;
    #originalProcessEmit;
    #originalProcessReallyExit;
    #sigListeners = {};
    #loaded = false;
    constructor(process3) {
      super();
      this.#process = process3;
      this.#sigListeners = {};
      for (const sig of signals) {
        this.#sigListeners[sig] = () => {
          const listeners = this.#process.listeners(sig);
          let { count } = this.#emitter;
          const p = process3;
          if (
            typeof p.__signal_exit_emitter__ === 'object' &&
            typeof p.__signal_exit_emitter__.count === 'number'
          ) {
            count += p.__signal_exit_emitter__.count;
          }
          if (listeners.length === count) {
            this.unload();
            const ret = this.#emitter.emit('exit', null, sig);
            const s = sig === 'SIGHUP' ? this.#hupSig : sig;
            if (!ret) process3.kill(process3.pid, s);
          }
        };
      }
      this.#originalProcessReallyExit = process3.reallyExit;
      this.#originalProcessEmit = process3.emit;
    }
    onExit(cb, opts) {
      if (!processOk(this.#process)) {
        return () => {};
      }
      if (this.#loaded === false) {
        this.load();
      }
      const ev = opts?.alwaysLast ? 'afterExit' : 'exit';
      this.#emitter.on(ev, cb);
      return () => {
        this.#emitter.removeListener(ev, cb);
        if (
          this.#emitter.listeners['exit'].length === 0 &&
          this.#emitter.listeners['afterExit'].length === 0
        ) {
          this.unload();
        }
      };
    }
    load() {
      if (this.#loaded) {
        return;
      }
      this.#loaded = true;
      this.#emitter.count += 1;
      for (const sig of signals) {
        try {
          const fn = this.#sigListeners[sig];
          if (fn) this.#process.on(sig, fn);
        } catch (_) {}
      }
      this.#process.emit = (ev, ...a) => {
        return this.#processEmit(ev, ...a);
      };
      this.#process.reallyExit = (code) => {
        return this.#processReallyExit(code);
      };
    }
    unload() {
      if (!this.#loaded) {
        return;
      }
      this.#loaded = false;
      signals.forEach((sig) => {
        const listener = this.#sigListeners[sig];
        if (!listener) {
          throw new Error('Listener not defined for signal: ' + sig);
        }
        try {
          this.#process.removeListener(sig, listener);
        } catch (_) {}
      });
      this.#process.emit = this.#originalProcessEmit;
      this.#process.reallyExit = this.#originalProcessReallyExit;
      this.#emitter.count -= 1;
    }
    #processReallyExit(code) {
      if (!processOk(this.#process)) {
        return 0;
      }
      this.#process.exitCode = code || 0;
      this.#emitter.emit('exit', this.#process.exitCode, null);
      return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);
    }
    #processEmit(ev, ...args) {
      const og = this.#originalProcessEmit;
      if (ev === 'exit' && processOk(this.#process)) {
        if (typeof args[0] === 'number') {
          this.#process.exitCode = args[0];
        }
        const ret = og.call(this.#process, ev, ...args);
        this.#emitter.emit('exit', this.#process.exitCode, null);
        return ret;
      } else {
        return og.call(this.#process, ev, ...args);
      }
    }
  };
  process3 = globalThis.process;
  ({ onExit, load, unload } = signalExitWrap(
    processOk(process3) ? new SignalExit(process3) : new SignalExitFallback()
  ));
});

// ../../node_modules/.bun/@inquirer+ansi@1.0.1/node_modules/@inquirer/ansi/dist/esm/index.js
var ESC = '\x1B[',
  cursorLeft,
  cursorHide,
  cursorShow,
  cursorUp = (rows = 1) => (rows > 0 ? `${ESC}${rows}A` : ''),
  cursorDown = (rows = 1) => (rows > 0 ? `${ESC}${rows}B` : ''),
  cursorTo = (x, y) => {
    if (typeof y === 'number' && !Number.isNaN(y)) {
      return `${ESC}${y + 1};${x + 1}H`;
    }
    return `${ESC}${x + 1}G`;
  },
  eraseLine,
  eraseLines = (lines) =>
    lines > 0 ? (eraseLine + cursorUp(1)).repeat(lines - 1) + eraseLine + cursorLeft : '';
var init_esm2 = __esm(() => {
  cursorLeft = ESC + 'G';
  cursorHide = ESC + '?25l';
  cursorShow = ESC + '?25h';
  eraseLine = ESC + '2K';
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/screen-manager.js
import { stripVTControlCharacters } from 'util';

class ScreenManager {
  height = 0;
  extraLinesUnderPrompt = 0;
  cursorPos;
  rl;
  constructor(rl) {
    this.rl = rl;
    this.cursorPos = rl.getCursorPos();
  }
  write(content) {
    this.rl.output.unmute();
    this.rl.output.write(content);
    this.rl.output.mute();
  }
  render(content, bottomContent = '') {
    const promptLine = lastLine(content);
    const rawPromptLine = stripVTControlCharacters(promptLine);
    let prompt = rawPromptLine;
    if (this.rl.line.length > 0) {
      prompt = prompt.slice(0, -this.rl.line.length);
    }
    this.rl.setPrompt(prompt);
    this.cursorPos = this.rl.getCursorPos();
    const width = readlineWidth();
    content = breakLines(content, width);
    bottomContent = breakLines(bottomContent, width);
    if (rawPromptLine.length % width === 0) {
      content += `
`;
    }
    let output =
      content +
      (bottomContent
        ? `
` + bottomContent
        : '');
    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - this.cursorPos.rows;
    const bottomContentHeight = promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
    if (bottomContentHeight > 0) output += cursorUp(bottomContentHeight);
    output += cursorTo(this.cursorPos.cols);
    this.write(cursorDown(this.extraLinesUnderPrompt) + eraseLines(this.height) + output);
    this.extraLinesUnderPrompt = bottomContentHeight;
    this.height = height(output);
  }
  checkCursorPos() {
    const cursorPos = this.rl.getCursorPos();
    if (cursorPos.cols !== this.cursorPos.cols) {
      this.write(cursorTo(cursorPos.cols));
      this.cursorPos = cursorPos;
    }
  }
  done({ clearContent }) {
    this.rl.setPrompt('');
    let output = cursorDown(this.extraLinesUnderPrompt);
    output += clearContent
      ? eraseLines(this.height)
      : `
`;
    output += cursorShow;
    this.write(output);
    this.rl.close();
  }
}
var height = (content) =>
    content.split(`
`).length,
  lastLine = (content) =>
    content
      .split(
        `
`
      )
      .pop() ?? '';
var init_screen_manager = __esm(() => {
  init_utils();
  init_esm2();
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/promise-polyfill.js
var PromisePolyfill;
var init_promise_polyfill = __esm(() => {
  PromisePolyfill = class PromisePolyfill extends Promise {
    static withResolver() {
      let resolve5;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve5 = res;
        reject = rej;
      });
      return { promise, resolve: resolve5, reject };
    }
  };
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/create-prompt.js
import * as readline2 from 'readline';
import { AsyncResource as AsyncResource3 } from 'async_hooks';
function getCallSites() {
  const _prepareStackTrace = Error.prepareStackTrace;
  let result = [];
  try {
    Error.prepareStackTrace = (_, callSites) => {
      const callSitesWithoutCurrent = callSites.slice(1);
      result = callSitesWithoutCurrent;
      return callSitesWithoutCurrent;
    };
    new Error().stack;
  } catch {
    return result;
  }
  Error.prepareStackTrace = _prepareStackTrace;
  return result;
}
function createPrompt(view) {
  const callSites = getCallSites();
  const prompt = (config, context = {}) => {
    const { input = process.stdin, signal } = context;
    const cleanups = new Set();
    const output = new import_mute_stream.default();
    output.pipe(context.output ?? process.stdout);
    const rl = readline2.createInterface({
      terminal: true,
      input,
      output,
    });
    const screen = new ScreenManager(rl);
    const { promise, resolve: resolve5, reject } = PromisePolyfill.withResolver();
    const cancel = () => reject(new CancelPromptError());
    if (signal) {
      const abort = () => reject(new AbortPromptError({ cause: signal.reason }));
      if (signal.aborted) {
        abort();
        return Object.assign(promise, { cancel });
      }
      signal.addEventListener('abort', abort);
      cleanups.add(() => signal.removeEventListener('abort', abort));
    }
    cleanups.add(
      onExit((code, signal2) => {
        reject(new ExitPromptError(`User force closed the prompt with ${code} ${signal2}`));
      })
    );
    const sigint = () => reject(new ExitPromptError(`User force closed the prompt with SIGINT`));
    rl.on('SIGINT', sigint);
    cleanups.add(() => rl.removeListener('SIGINT', sigint));
    const checkCursorPos = () => screen.checkCursorPos();
    rl.input.on('keypress', checkCursorPos);
    cleanups.add(() => rl.input.removeListener('keypress', checkCursorPos));
    return withHooks(rl, (cycle) => {
      const hooksCleanup = AsyncResource3.bind(() => effectScheduler.clearAll());
      rl.on('close', hooksCleanup);
      cleanups.add(() => rl.removeListener('close', hooksCleanup));
      cycle(() => {
        try {
          const nextView = view(config, (value) => {
            setImmediate(() => resolve5(value));
          });
          if (nextView === undefined) {
            const callerFilename = callSites[1]?.getFileName();
            throw new Error(`Prompt functions must return a string.
    at ${callerFilename}`);
          }
          const [content, bottomContent] = typeof nextView === 'string' ? [nextView] : nextView;
          screen.render(content, bottomContent);
          effectScheduler.run();
        } catch (error) {
          reject(error);
        }
      });
      return Object.assign(
        promise
          .then(
            (answer) => {
              effectScheduler.clearAll();
              return answer;
            },
            (error) => {
              effectScheduler.clearAll();
              throw error;
            }
          )
          .finally(() => {
            cleanups.forEach((cleanup) => cleanup());
            screen.done({ clearContent: Boolean(context.clearPromptOnDone) });
            output.end();
          })
          .then(() => promise),
        { cancel }
      );
    });
  };
  return prompt;
}
var import_mute_stream;
var init_create_prompt = __esm(() => {
  init_mjs();
  init_screen_manager();
  init_promise_polyfill();
  init_hook_engine();
  init_errors();
  import_mute_stream = __toESM(require_lib(), 1);
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/lib/Separator.js
class Separator {
  separator = import_yoctocolors_cjs2.default.dim(
    Array.from({ length: 15 }).join(esm_default2.line)
  );
  type = 'separator';
  constructor(separator) {
    if (separator) {
      this.separator = separator;
    }
  }
  static isSeparator(choice) {
    return Boolean(
      choice && typeof choice === 'object' && 'type' in choice && choice.type === 'separator'
    );
  }
}
var import_yoctocolors_cjs2;
var init_Separator = __esm(() => {
  init_esm();
  import_yoctocolors_cjs2 = __toESM(require_yoctocolors_cjs(), 1);
});

// ../../node_modules/.bun/@inquirer+core@10.3.0+4a5940375a364d46/node_modules/@inquirer/core/dist/esm/index.js
var init_esm3 = __esm(() => {
  init_use_prefix();
  init_use_state();
  init_use_effect();
  init_use_memo();
  init_use_ref();
  init_use_keypress();
  init_make_theme();
  init_use_pagination();
  init_create_prompt();
  init_Separator();
  init_errors();
});

// ../../node_modules/.bun/@inquirer+checkbox@4.3.0+4a5940375a364d46/node_modules/@inquirer/checkbox/dist/esm/index.js
function isSelectable(item) {
  return !Separator.isSeparator(item) && !item.disabled;
}
function isChecked(item) {
  return isSelectable(item) && item.checked;
}
function toggle(item) {
  return isSelectable(item) ? { ...item, checked: !item.checked } : item;
}
function check(checked) {
  return function (item) {
    return isSelectable(item) ? { ...item, checked } : item;
  };
}
function normalizeChoices(choices) {
  return choices.map((choice) => {
    if (Separator.isSeparator(choice)) return choice;
    if (typeof choice === 'string') {
      return {
        value: choice,
        name: choice,
        short: choice,
        checkedName: choice,
        disabled: false,
        checked: false,
      };
    }
    const name = choice.name ?? String(choice.value);
    const normalizedChoice = {
      value: choice.value,
      name,
      short: choice.short ?? name,
      checkedName: choice.checkedName ?? name,
      disabled: choice.disabled ?? false,
      checked: choice.checked ?? false,
    };
    if (choice.description) {
      normalizedChoice.description = choice.description;
    }
    return normalizedChoice;
  });
}
var import_yoctocolors_cjs3, checkboxTheme, esm_default3;
var init_esm4 = __esm(() => {
  init_esm3();
  init_esm2();
  init_esm();
  import_yoctocolors_cjs3 = __toESM(require_yoctocolors_cjs(), 1);
  checkboxTheme = {
    icon: {
      checked: import_yoctocolors_cjs3.default.green(esm_default2.circleFilled),
      unchecked: esm_default2.circle,
      cursor: esm_default2.pointer,
    },
    style: {
      disabledChoice: (text) => import_yoctocolors_cjs3.default.dim(`- ${text}`),
      renderSelectedChoices: (selectedChoices) =>
        selectedChoices.map((choice) => choice.short).join(', '),
      description: (text) => import_yoctocolors_cjs3.default.cyan(text),
      keysHelpTip: (keys) =>
        keys
          .map(
            ([key, action]) =>
              `${import_yoctocolors_cjs3.default.bold(key)} ${import_yoctocolors_cjs3.default.dim(action)}`
          )
          .join(import_yoctocolors_cjs3.default.dim(' \u2022 ')),
    },
    helpMode: 'always',
    keybindings: [],
  };
  esm_default3 = createPrompt((config, done) => {
    const { instructions, pageSize = 7, loop = true, required, validate = () => true } = config;
    const shortcuts = { all: 'a', invert: 'i', ...config.shortcuts };
    const theme = makeTheme(checkboxTheme, config.theme);
    const { keybindings } = theme;
    const [status, setStatus] = useState('idle');
    const prefix = usePrefix({ status, theme });
    const [items, setItems] = useState(normalizeChoices(config.choices));
    const bounds = useMemo(() => {
      const first = items.findIndex(isSelectable);
      const last = items.findLastIndex(isSelectable);
      if (first === -1) {
        throw new ValidationError(
          '[checkbox prompt] No selectable choices. All choices are disabled.'
        );
      }
      return { first, last };
    }, [items]);
    const [active, setActive] = useState(bounds.first);
    const [errorMsg, setError] = useState();
    useKeypress(async (key) => {
      if (isEnterKey(key)) {
        const selection = items.filter(isChecked);
        const isValid = await validate([...selection]);
        if (required && !items.some(isChecked)) {
          setError('At least one choice must be selected');
        } else if (isValid === true) {
          setStatus('done');
          done(selection.map((choice) => choice.value));
        } else {
          setError(isValid || 'You must select a valid value');
        }
      } else if (isUpKey(key, keybindings) || isDownKey(key, keybindings)) {
        if (
          loop ||
          (isUpKey(key, keybindings) && active !== bounds.first) ||
          (isDownKey(key, keybindings) && active !== bounds.last)
        ) {
          const offset = isUpKey(key, keybindings) ? -1 : 1;
          let next = active;
          do {
            next = (next + offset + items.length) % items.length;
          } while (!isSelectable(items[next]));
          setActive(next);
        }
      } else if (isSpaceKey(key)) {
        setError(undefined);
        setItems(items.map((choice, i) => (i === active ? toggle(choice) : choice)));
      } else if (key.name === shortcuts.all) {
        const selectAll = items.some((choice) => isSelectable(choice) && !choice.checked);
        setItems(items.map(check(selectAll)));
      } else if (key.name === shortcuts.invert) {
        setItems(items.map(toggle));
      } else if (isNumberKey(key)) {
        const selectedIndex = Number(key.name) - 1;
        let selectableIndex = -1;
        const position = items.findIndex((item) => {
          if (Separator.isSeparator(item)) return false;
          selectableIndex++;
          return selectableIndex === selectedIndex;
        });
        const selectedItem = items[position];
        if (selectedItem && isSelectable(selectedItem)) {
          setActive(position);
          setItems(items.map((choice, i) => (i === position ? toggle(choice) : choice)));
        }
      }
    });
    const message = theme.style.message(config.message, status);
    let description;
    const page = usePagination({
      items,
      active,
      renderItem({ item, isActive }) {
        if (Separator.isSeparator(item)) {
          return ` ${item.separator}`;
        }
        if (item.disabled) {
          const disabledLabel = typeof item.disabled === 'string' ? item.disabled : '(disabled)';
          return theme.style.disabledChoice(`${item.name} ${disabledLabel}`);
        }
        if (isActive) {
          description = item.description;
        }
        const checkbox = item.checked ? theme.icon.checked : theme.icon.unchecked;
        const name = item.checked ? item.checkedName : item.name;
        const color = isActive ? theme.style.highlight : (x) => x;
        const cursor = isActive ? theme.icon.cursor : ' ';
        return color(`${cursor}${checkbox} ${name}`);
      },
      pageSize,
      loop,
    });
    if (status === 'done') {
      const selection = items.filter(isChecked);
      const answer = theme.style.answer(theme.style.renderSelectedChoices(selection, items));
      return [prefix, message, answer].filter(Boolean).join(' ');
    }
    let helpLine;
    if (theme.helpMode !== 'never' && instructions !== false) {
      if (typeof instructions === 'string') {
        helpLine = instructions;
      } else {
        const keys = [
          ['\u2191\u2193', 'navigate'],
          ['space', 'select'],
        ];
        if (shortcuts.all) keys.push([shortcuts.all, 'all']);
        if (shortcuts.invert) keys.push([shortcuts.invert, 'invert']);
        keys.push(['\u23CE', 'submit']);
        helpLine = theme.style.keysHelpTip(keys);
      }
    }
    const lines = [
      [prefix, message].filter(Boolean).join(' '),
      page,
      ' ',
      description ? theme.style.description(description) : '',
      errorMsg ? theme.style.error(errorMsg) : '',
      helpLine,
    ]
      .filter(Boolean)
      .join(
        `
`
      )
      .trimEnd();
    return `${lines}${cursorHide}`;
  });
});

// ../../node_modules/.bun/@inquirer+confirm@5.1.19+4a5940375a364d46/node_modules/@inquirer/confirm/dist/esm/index.js
function getBooleanValue(value, defaultValue) {
  let answer = defaultValue !== false;
  if (/^(y|yes)/i.test(value)) answer = true;
  else if (/^(n|no)/i.test(value)) answer = false;
  return answer;
}
function boolToString(value) {
  return value ? 'Yes' : 'No';
}
var esm_default4;
var init_esm6 = __esm(() => {
  init_esm3();
  esm_default4 = createPrompt((config, done) => {
    const { transformer = boolToString } = config;
    const [status, setStatus] = useState('idle');
    const [value, setValue] = useState('');
    const theme = makeTheme(config.theme);
    const prefix = usePrefix({ status, theme });
    useKeypress((key, rl) => {
      if (status !== 'idle') return;
      if (isEnterKey(key)) {
        const answer = getBooleanValue(value, config.default);
        setValue(transformer(answer));
        setStatus('done');
        done(answer);
      } else if (isTabKey(key)) {
        const answer = boolToString(!getBooleanValue(value, config.default));
        rl.clearLine(0);
        rl.write(answer);
        setValue(answer);
      } else {
        setValue(rl.line);
      }
    });
    let formattedValue = value;
    let defaultValue = '';
    if (status === 'done') {
      formattedValue = theme.style.answer(value);
    } else {
      defaultValue = ` ${theme.style.defaultAnswer(config.default === false ? 'y/N' : 'Y/n')}`;
    }
    const message = theme.style.message(config.message, status);
    return `${prefix} ${message}${defaultValue} ${formattedValue}`;
  });
});

// ../../node_modules/.bun/@inquirer+input@4.2.5+4a5940375a364d46/node_modules/@inquirer/input/dist/esm/index.js
var inputTheme, esm_default5;
var init_esm8 = __esm(() => {
  init_esm3();
  inputTheme = {
    validationFailureMode: 'keep',
  };
  esm_default5 = createPrompt((config, done) => {
    const { required, validate = () => true, prefill = 'tab' } = config;
    const theme = makeTheme(inputTheme, config.theme);
    const [status, setStatus] = useState('idle');
    const [defaultValue = '', setDefaultValue] = useState(config.default);
    const [errorMsg, setError] = useState();
    const [value, setValue] = useState('');
    const prefix = usePrefix({ status, theme });
    useKeypress(async (key, rl) => {
      if (status !== 'idle') {
        return;
      }
      if (isEnterKey(key)) {
        const answer = value || defaultValue;
        setStatus('loading');
        const isValid = required && !answer ? 'You must provide a value' : await validate(answer);
        if (isValid === true) {
          setValue(answer);
          setStatus('done');
          done(answer);
        } else {
          if (theme.validationFailureMode === 'clear') {
            setValue('');
          } else {
            rl.write(value);
          }
          setError(isValid || 'You must provide a valid value');
          setStatus('idle');
        }
      } else if (isBackspaceKey(key) && !value) {
        setDefaultValue(undefined);
      } else if (isTabKey(key) && !value) {
        setDefaultValue(undefined);
        rl.clearLine(0);
        rl.write(defaultValue);
        setValue(defaultValue);
      } else {
        setValue(rl.line);
        setError(undefined);
      }
    });
    useEffect((rl) => {
      if (prefill === 'editable' && defaultValue) {
        rl.write(defaultValue);
        setValue(defaultValue);
      }
    }, []);
    const message = theme.style.message(config.message, status);
    let formattedValue = value;
    if (typeof config.transformer === 'function') {
      formattedValue = config.transformer(value, { isFinal: status === 'done' });
    } else if (status === 'done') {
      formattedValue = theme.style.answer(value);
    }
    let defaultStr;
    if (defaultValue && status !== 'done' && !value) {
      defaultStr = theme.style.defaultAnswer(defaultValue);
    }
    let error = '';
    if (errorMsg) {
      error = theme.style.error(errorMsg);
    }
    return [
      [prefix, message, defaultStr, formattedValue].filter((v) => v !== undefined).join(' '),
      error,
    ];
  });
});

// ../../node_modules/.bun/@inquirer+select@4.4.0+4a5940375a364d46/node_modules/@inquirer/select/dist/esm/index.js
function isSelectable2(item) {
  return !Separator.isSeparator(item) && !item.disabled;
}
function normalizeChoices2(choices) {
  return choices.map((choice) => {
    if (Separator.isSeparator(choice)) return choice;
    if (typeof choice === 'string') {
      return {
        value: choice,
        name: choice,
        short: choice,
        disabled: false,
      };
    }
    const name = choice.name ?? String(choice.value);
    const normalizedChoice = {
      value: choice.value,
      name,
      short: choice.short ?? name,
      disabled: choice.disabled ?? false,
    };
    if (choice.description) {
      normalizedChoice.description = choice.description;
    }
    return normalizedChoice;
  });
}
var import_yoctocolors_cjs4, selectTheme, esm_default6;
var init_esm9 = __esm(() => {
  init_esm3();
  init_esm2();
  init_esm();
  import_yoctocolors_cjs4 = __toESM(require_yoctocolors_cjs(), 1);
  selectTheme = {
    icon: { cursor: esm_default2.pointer },
    style: {
      disabled: (text) => import_yoctocolors_cjs4.default.dim(`- ${text}`),
      description: (text) => import_yoctocolors_cjs4.default.cyan(text),
      keysHelpTip: (keys) =>
        keys
          .map(
            ([key, action]) =>
              `${import_yoctocolors_cjs4.default.bold(key)} ${import_yoctocolors_cjs4.default.dim(action)}`
          )
          .join(import_yoctocolors_cjs4.default.dim(' \u2022 ')),
    },
    helpMode: 'always',
    indexMode: 'hidden',
    keybindings: [],
  };
  esm_default6 = createPrompt((config, done) => {
    const { loop = true, pageSize = 7 } = config;
    const theme = makeTheme(selectTheme, config.theme);
    const { keybindings } = theme;
    const [status, setStatus] = useState('idle');
    const prefix = usePrefix({ status, theme });
    const searchTimeoutRef = useRef();
    const searchEnabled = !keybindings.includes('vim');
    const items = useMemo(() => normalizeChoices2(config.choices), [config.choices]);
    const bounds = useMemo(() => {
      const first = items.findIndex(isSelectable2);
      const last = items.findLastIndex(isSelectable2);
      if (first === -1) {
        throw new ValidationError(
          '[select prompt] No selectable choices. All choices are disabled.'
        );
      }
      return { first, last };
    }, [items]);
    const defaultItemIndex = useMemo(() => {
      if (!('default' in config)) return -1;
      return items.findIndex((item) => isSelectable2(item) && item.value === config.default);
    }, [config.default, items]);
    const [active, setActive] = useState(defaultItemIndex === -1 ? bounds.first : defaultItemIndex);
    const selectedChoice = items[active];
    useKeypress((key, rl) => {
      clearTimeout(searchTimeoutRef.current);
      if (isEnterKey(key)) {
        setStatus('done');
        done(selectedChoice.value);
      } else if (isUpKey(key, keybindings) || isDownKey(key, keybindings)) {
        rl.clearLine(0);
        if (
          loop ||
          (isUpKey(key, keybindings) && active !== bounds.first) ||
          (isDownKey(key, keybindings) && active !== bounds.last)
        ) {
          const offset = isUpKey(key, keybindings) ? -1 : 1;
          let next = active;
          do {
            next = (next + offset + items.length) % items.length;
          } while (!isSelectable2(items[next]));
          setActive(next);
        }
      } else if (isNumberKey(key) && !Number.isNaN(Number(rl.line))) {
        const selectedIndex = Number(rl.line) - 1;
        let selectableIndex = -1;
        const position = items.findIndex((item2) => {
          if (Separator.isSeparator(item2)) return false;
          selectableIndex++;
          return selectableIndex === selectedIndex;
        });
        const item = items[position];
        if (item != null && isSelectable2(item)) {
          setActive(position);
        }
        searchTimeoutRef.current = setTimeout(() => {
          rl.clearLine(0);
        }, 700);
      } else if (isBackspaceKey(key)) {
        rl.clearLine(0);
      } else if (searchEnabled) {
        const searchTerm = rl.line.toLowerCase();
        const matchIndex = items.findIndex((item) => {
          if (Separator.isSeparator(item) || !isSelectable2(item)) return false;
          return item.name.toLowerCase().startsWith(searchTerm);
        });
        if (matchIndex !== -1) {
          setActive(matchIndex);
        }
        searchTimeoutRef.current = setTimeout(() => {
          rl.clearLine(0);
        }, 700);
      }
    });
    useEffect(
      () => () => {
        clearTimeout(searchTimeoutRef.current);
      },
      []
    );
    const message = theme.style.message(config.message, status);
    let helpLine;
    if (theme.helpMode !== 'never') {
      if (config.instructions) {
        const { pager, navigation } = config.instructions;
        helpLine = theme.style.help(items.length > pageSize ? pager : navigation);
      } else {
        helpLine = theme.style.keysHelpTip([
          ['\u2191\u2193', 'navigate'],
          ['\u23CE', 'select'],
        ]);
      }
    }
    let separatorCount = 0;
    const page = usePagination({
      items,
      active,
      renderItem({ item, isActive, index }) {
        if (Separator.isSeparator(item)) {
          separatorCount++;
          return ` ${item.separator}`;
        }
        const indexLabel = theme.indexMode === 'number' ? `${index + 1 - separatorCount}. ` : '';
        if (item.disabled) {
          const disabledLabel = typeof item.disabled === 'string' ? item.disabled : '(disabled)';
          return theme.style.disabled(`${indexLabel}${item.name} ${disabledLabel}`);
        }
        const color = isActive ? theme.style.highlight : (x) => x;
        const cursor = isActive ? theme.icon.cursor : ` `;
        return color(`${cursor} ${indexLabel}${item.name}`);
      },
      pageSize,
      loop,
    });
    if (status === 'done') {
      return [prefix, message, theme.style.answer(selectedChoice.short)].filter(Boolean).join(' ');
    }
    const { description } = selectedChoice;
    const lines = [
      [prefix, message].filter(Boolean).join(' '),
      page,
      ' ',
      description ? theme.style.description(description) : '',
      helpLine,
    ]
      .filter(Boolean)
      .join(
        `
`
      )
      .trimEnd();
    return `${lines}${cursorHide}`;
  });
});

// ../../packages/adapters/src/wizards/prompt-handlers.ts
function withSigIntHandling(promptFunction) {
  return async (...args) => {
    try {
      return await promptFunction(...args);
    } catch (error) {
      if (
        error instanceof Error &&
        (error.message.includes('SIGINT') ||
          error.message.includes('User force closed') ||
          error.name === 'ExitPromptError')
      ) {
        process.exit(SIGINT_EXIT_CODE);
      }
      throw error;
    }
  };
}
var SIGINT_EXIT_CODE = 130,
  promptText,
  promptList,
  promptCheckbox,
  promptConfirm;
var init_prompt_handlers = __esm(() => {
  init_esm4();
  init_esm6();
  init_esm8();
  init_esm9();
  promptText = withSigIntHandling(async (message, defaultValue) => {
    return esm_default5({
      message,
      default: defaultValue,
    });
  });
  promptList = withSigIntHandling(async (message, options, defaultValue) => {
    return esm_default6({
      message,
      choices: options.map((opt) => ({
        name: opt.label,
        value: opt.value,
        description: opt.description,
      })),
      default: defaultValue,
    });
  });
  promptCheckbox = withSigIntHandling(async (message, options, defaultValues = []) => {
    return esm_default3({
      message,
      choices: options.map((opt) => ({
        name: opt.label,
        value: opt.value,
        description: opt.description,
        checked: defaultValues.includes(opt.value),
      })),
    });
  });
  promptConfirm = withSigIntHandling(async (message, defaultValue = true) => {
    return esm_default4({
      message,
      default: defaultValue,
    });
  });
});

// ../../packages/adapters/src/wizards/validation-rules.ts
function validateStepInput(step, value) {
  const errors2 = [];
  if (isRequiredFieldEmpty(step, value)) {
    errors2.push('This field is required');
    return { valid: false, errors: errors2 };
  }
  if (isOptionalFieldEmpty(step, value)) {
    return { valid: true, errors: [] };
  }
  runValidationRules(step, value, errors2);
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function isRequiredFieldEmpty(step, value) {
  return step.required && (value === undefined || value === null || value === '');
}
function isOptionalFieldEmpty(step, value) {
  return !step.required && (value === undefined || value === null || value === '');
}
function runValidationRules(step, value, errors2) {
  if (!step.validation) {
    return;
  }
  for (const rule of step.validation) {
    validateRule(rule, value, errors2);
  }
}
function validateRule(rule, value, errors2) {
  switch (rule.type) {
    case 'pattern':
      validatePatternRule(rule, value, errors2);
      break;
    case 'length':
      validateLengthRule(rule, value, errors2);
      break;
    case 'custom':
      validateCustomRule(rule, value, errors2);
      break;
    default:
      break;
  }
}
function validatePatternRule(rule, value, errors2) {
  if (typeof value !== 'string' || !rule.pattern) {
    return;
  }
  if (!rule.pattern.test(value)) {
    errors2.push(rule.message);
  }
}
function validateLengthRule(rule, value, errors2) {
  if (typeof value !== 'string') {
    return;
  }
  if (rule.min && value.length < rule.min) {
    errors2.push(rule.message);
  }
  if (rule.max && value.length > rule.max) {
    errors2.push(rule.message);
  }
}
function validateCustomRule(rule, value, errors2) {
  if (!rule.validator) {
    return;
  }
  const result = rule.validator(value);
  if (typeof result === 'string') {
    errors2.push(result);
  } else if (!result) {
    errors2.push(rule.message);
  }
}

// ../../packages/adapters/src/wizards/wizard-prompts.ts
async function handleTextStep(title, defaultValue, help) {
  const message = help
    ? `${help}
${title}`
    : title;
  return promptText(message, defaultValue);
}
async function handleListStep(title, step) {
  if (!step.options) {
    throw new Error(`List step "${step.id}" requires options`);
  }
  return promptList(title, step.options, step.defaultValue);
}
async function handleCheckboxStep(title, step) {
  if (!step.options) {
    throw new Error(`Checkbox step "${step.id}" requires options`);
  }
  return promptCheckbox(title, step.options, step.defaultValue);
}
async function handleConfirmStep(title, defaultValue) {
  return promptConfirm(title, defaultValue);
}
async function promptForStep(step) {
  switch (step.type) {
    case 'text':
      return handleTextStep(step.title, step.defaultValue, step.help);
    case 'list':
      return handleListStep(step.title, step);
    case 'checkbox':
      return handleCheckboxStep(step.title, step);
    case 'confirm':
      return handleConfirmStep(step.title, step.defaultValue);
    default:
      throw new Error(`Unsupported step type: ${step.type}`);
  }
}
function createErrorMessage(error) {
  return error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE;
}
var UNKNOWN_ERROR_MESSAGE = 'Unknown error';
var init_wizard_prompts = __esm(() => {
  init_prompt_handlers();
});

// ../../packages/adapters/src/wizards/wizard-steps.ts
import path from 'path';
function getDefaultProjectName(config) {
  const targetDir = config['targetDirectory'];
  return targetDir ? path.basename(targetDir) : path.basename(process.cwd());
}
function createTargetDirectoryStep() {
  return {
    id: 'targetDirectory',
    title: 'Target Directory',
    description: 'Enter the directory where the project will be created',
    help: 'Press Enter to use the current directory, or specify a different path',
    type: 'text',
    required: true,
    defaultValue: process.cwd(),
    validation: [
      {
        type: 'required',
        message: 'Target directory is required',
      },
      {
        type: 'length',
        min: LISTS.INDEX_OFFSET,
        max: TEXT_LIMITS.PATH_MAX,
        message: `Directory path must be between ${LISTS.INDEX_OFFSET} and ${TEXT_LIMITS.PATH_MAX} characters`,
      },
    ],
  };
}
function createProjectNameStep() {
  return {
    id: 'name',
    title: 'Project Name',
    description: 'Enter the name of your project',
    help: 'Project names should be lowercase, contain no spaces, and be suitable for npm package naming',
    type: 'text',
    required: true,
    defaultValue: getDefaultProjectName,
    condition: (config) => !config['name'],
    validation: PROJECT_NAME_VALIDATION,
  };
}
function createProjectDescriptionStep() {
  return {
    id: 'description',
    title: 'Project Description',
    description: 'Enter a brief description of your project',
    help: 'A good description helps others understand what your project does',
    type: 'text',
    required: false,
    defaultValue: '',
    validation: [
      {
        type: 'length',
        max: TEXT_LIMITS.DESCRIPTION_MAX,
        message: `Description must be less than ${TEXT_LIMITS.DESCRIPTION_MAX} characters`,
      },
    ],
  };
}
function createQualityLevelStep() {
  return {
    id: 'qualityLevel',
    title: 'Quality Level',
    description: 'Choose the quality level for your project',
    help: 'Higher quality levels include more strict rules and tools',
    type: 'list',
    required: true,
    defaultValue: 'strict',
    options: [
      {
        label: 'Light',
        value: 'light',
        description: 'Basic ESLint rules, minimal restrictions',
      },
      {
        label: 'Medium',
        value: 'medium',
        description: 'Balanced approach with good practices enforced',
      },
      {
        label: 'Strict (Recommended)',
        value: 'strict',
        description: 'Maximum code quality with comprehensive rules',
      },
    ],
  };
}
function createProjectTypeStep() {
  return {
    id: 'projectType',
    title: 'Project Type',
    description: 'Choose the type of project you want to create',
    help: 'This determines the initial project structure and configuration',
    type: 'list',
    required: true,
    defaultValue: 'basic',
    options: getProjectTypeOptions(),
  };
}
function getProjectTypeOptions() {
  return [
    {
      label: 'Basic',
      value: 'basic',
      description: 'Simple TypeScript project with basic setup',
    },
    {
      label: 'CLI Application',
      value: 'cli',
      description: 'Command-line interface application with argument parsing',
    },
    {
      label: 'Web Application',
      value: 'web',
      description: 'Web server application with HTTP routing',
    },
    {
      label: 'Library Package',
      value: 'library',
      description: 'Reusable library package for distribution',
    },
  ];
}
function createAIAssistantsStep() {
  return {
    id: 'aiAssistants',
    title: 'AI Assistants',
    description: 'Choose which AI assistants to configure',
    help: 'This will generate optimized context files for the selected assistants',
    type: 'checkbox',
    required: true,
    defaultValue: ['claude-code'],
    options: [
      {
        label: 'Claude Code',
        value: 'claude-code',
        description: 'Generate CLAUDE.md with project context and guidelines',
      },
      {
        label: 'GitHub Copilot',
        value: 'copilot',
        description: 'Generate GitHub Copilot instructions file',
      },
    ],
  };
}
function createAuthorStep() {
  return {
    id: 'author',
    title: 'Author',
    description: 'Enter the author name for this project',
    help: 'This will be used in package.json and license headers',
    type: 'text',
    required: false,
    defaultValue: '',
    validation: [
      {
        type: 'length',
        max: TEXT_LIMITS.AUTHOR_NAME_MAX,
        message: `Author name must be less than ${TEXT_LIMITS.AUTHOR_NAME_MAX} characters`,
      },
    ],
  };
}
function createLicenseStep() {
  return {
    id: 'license',
    title: 'License',
    description: 'Choose a license for your project',
    help: 'This will be used in package.json and LICENSE file',
    type: 'list',
    required: false,
    defaultValue: 'MIT',
    options: createLicenseOptions(),
  };
}
function createLicenseOptions() {
  const permissiveLicenses = getPermissiveLicenses();
  const copyleftLicenses = getCopyleftLicenses();
  return [...permissiveLicenses, ...copyleftLicenses, getNoLicenseOption()];
}
function getPermissiveLicenses() {
  return [
    {
      label: 'MIT',
      value: 'MIT',
      description: 'Permissive license with minimal restrictions',
    },
    {
      label: 'Apache-2.0',
      value: 'Apache-2.0',
      description: 'Permissive license with patent grant',
    },
    {
      label: 'BSD-3-Clause',
      value: 'BSD-3-Clause',
      description: 'Permissive license with advertising clause',
    },
    {
      label: 'ISC',
      value: 'ISC',
      description: 'Simple permissive license',
    },
  ];
}
function getCopyleftLicenses() {
  return [
    {
      label: 'GPL-3.0-or-later',
      value: 'GPL-3.0-or-later',
      description: 'Strong copyleft license',
    },
  ];
}
function getNoLicenseOption() {
  return {
    label: 'None',
    value: '',
    description: 'No license (unlicensed)',
  };
}
var PROJECT_NAME_VALIDATION;
var init_wizard_steps = __esm(() => {
  init_constants();
  PROJECT_NAME_VALIDATION = [
    {
      type: 'required',
      message: 'Project name is required',
    },
    {
      type: 'pattern',
      pattern: /^[\d_a-z-]+$/,
      message:
        'Project name must contain only lowercase letters, numbers, hyphens, and underscores',
    },
    {
      type: 'length',
      min: LISTS.INDEX_OFFSET,
      max: LISTS.MAX_NAME_LENGTH,
      message: `Project name must be between ${LISTS.INDEX_OFFSET} and ${LISTS.MAX_NAME_LENGTH} characters`,
    },
  ];
});

// ../../packages/adapters/src/wizards/wizard-validators.ts
function validateRequiredFields(config) {
  const errors2 = [];
  validateProjectNameField(config, errors2);
  validateQualityLevelField(config, errors2);
  validateProjectTypeField(config, errors2);
  validateAIAssistantsField(config, errors2);
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function validateProjectNameField(config, errors2) {
  if (config.name) {
    const nameValidation = validateProjectName(config.name);
    if (!nameValidation.valid) {
      errors2.push(...nameValidation.errors);
    }
  } else {
    errors2.push('Project name is required');
  }
}
function validateQualityLevelField(config, errors2) {
  if (!config.qualityLevel) {
    errors2.push('Quality level is required');
  } else if (!isValidQualityLevel(config.qualityLevel)) {
    errors2.push('Invalid quality level. Must be: light, medium, or strict');
  }
}
function validateProjectTypeField(config, errors2) {
  if (!config.projectType) {
    errors2.push('Project type is required');
  } else if (!isValidProjectType(config.projectType)) {
    errors2.push('Invalid project type. Must be: basic, web, cli, or library');
  }
}
function validateAIAssistantsField(config, errors2) {
  if (!config.aiAssistants || config.aiAssistants.length === 0) {
    errors2.push('At least one AI assistant must be selected');
  } else {
    const validationErrors = validateAIAssistants(config.aiAssistants);
    errors2.push(...validationErrors);
  }
}
function validateOptionalFields(config) {
  const errors2 = [];
  if (config.description && config.description.length > TEXT_LIMITS.DESCRIPTION_MAX) {
    errors2.push(`Description must be less than ${TEXT_LIMITS.DESCRIPTION_MAX} characters`);
  }
  if (config.author && config.author.length > TEXT_LIMITS.AUTHOR_NAME_MAX) {
    errors2.push(`Author name must be less than ${TEXT_LIMITS.AUTHOR_NAME_MAX} characters`);
  }
  if (config.license && !isValidLicense(config.license)) {
    errors2.push('Invalid license. Use a valid SPDX license identifier or leave empty');
  }
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function isValidQualityLevel(qualityLevel) {
  return ['light', 'medium', 'strict'].includes(qualityLevel);
}
function isValidProjectType(projectType) {
  return ['basic', 'web', 'cli', 'library'].includes(projectType);
}
function validateAIAssistants(aiAssistants) {
  const errors2 = [];
  const invalidAssistants = aiAssistants.filter(
    (assistant) => !VALID_AI_ASSISTANTS.includes(assistant)
  );
  if (invalidAssistants.length > 0) {
    errors2.push(INVALID_ASSISTANTS_MESSAGE.replace('{{invalid}}', invalidAssistants.join(', ')));
  }
  return errors2;
}
function validateProjectName(name) {
  const errors2 = [];
  if (!/^[\d_a-z-]+$/.test(name)) {
    errors2.push(
      'Project name must contain only lowercase letters, numbers, hyphens, and underscores'
    );
  }
  if (name.length === 0 || name.length > LISTS.MAX_NAME_LENGTH) {
    errors2.push(
      `Project name must be between ${LISTS.INDEX_OFFSET} and ${LISTS.MAX_NAME_LENGTH} characters`
    );
  }
  if (/^[\d.]/.test(name)) {
    errors2.push('Project name cannot start with a number or dot');
  }
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function isValidLicense(license) {
  const validLicenses = [
    'MIT',
    'Apache-2.0',
    'GPL-3.0-or-later',
    'BSD-3-Clause',
    'BSD-2-Clause',
    'ISC',
    'LGPL-3.0-or-later',
    'AGPL-3.0-or-later',
    'Unlicense',
    'CC0-1.0',
    'MPL-2.0',
    'BSL-1.0',
    'Zlib',
    'WTFPL',
    '0BSD',
  ];
  return validLicenses.includes(license) || /^[\d.A-Za-z-]+$/.test(license);
}
var VALID_AI_ASSISTANTS,
  VALID_ASSISTANTS_MESSAGE = 'claude-code, copilot',
  INVALID_ASSISTANTS_MESSAGE;
var init_wizard_validators = __esm(() => {
  init_constants();
  VALID_AI_ASSISTANTS = ['claude-code', 'copilot'];
  INVALID_ASSISTANTS_MESSAGE = `Invalid AI assistants: {{invalid}}. Valid options: ${VALID_ASSISTANTS_MESSAGE}`;
});

// ../../packages/adapters/src/wizards/project-wizard.ts
class OutputWriter2 {
  static write(message) {
    process.stdout.write(message);
  }
  static writeError(message) {
    process.stderr.write(message);
  }
  static writeln(message = '') {
    process.stdout.write(`${message}
`);
  }
  static writelnError(message) {
    process.stderr.write(`${message}
`);
  }
}

class ProjectWizardImplementation {
  steps = [];
  currentConfig = {};
  constructor() {
    this.initializeDefaultSteps();
  }
  async run(config) {
    this.currentConfig = { ...config };
    OutputWriter2.writeln(`
\uD83D\uDE80 N\xECmata Project Generator
`);
    OutputWriter2.writeln(`Let's create your new TypeScript project!
`);
    for (const step of this.steps) {
      if (step.condition && !step.condition(this.currentConfig)) {
        continue;
      }
      await this.executeStep(step);
    }
    const finalConfig = this.currentConfig;
    this.displaySummary(finalConfig);
    return finalConfig;
  }
  addStep(step) {
    this.steps.push(step);
  }
  validate(config) {
    const requiredValidation = validateRequiredFields(config);
    const optionalValidation = validateOptionalFields(config);
    const allErrors = [...requiredValidation.errors, ...optionalValidation.errors];
    return {
      valid: allErrors.length === 0,
      errors: allErrors,
    };
  }
  getSteps() {
    return [...this.steps];
  }
  getStep(stepId) {
    return this.steps.find((step) => step.id === stepId);
  }
  reset() {
    this.currentConfig = {};
  }
  initializeDefaultSteps() {
    this.addStep(createTargetDirectoryStep());
    this.addStep(createProjectNameStep());
    this.addStep(createProjectDescriptionStep());
    this.addStep(createQualityLevelStep());
    this.addStep(createProjectTypeStep());
    this.addStep(createAIAssistantsStep());
    this.addStep(createAuthorStep());
    this.addStep(createLicenseStep());
  }
  async executeStep(step) {
    while (true) {
      try {
        const evaluatedStep = { ...step };
        if (typeof step.defaultValue === 'function') {
          evaluatedStep.defaultValue = step.defaultValue(this.currentConfig);
        }
        const value = await promptForStep(evaluatedStep);
        const validationResult = validateStepInput(step, value);
        if (!validationResult.valid) {
          this.displayValidationErrors(validationResult.errors);
          continue;
        }
        this.currentConfig[step.id] = value;
        break;
      } catch (error) {
        this.displayExecutionError(error);
      }
    }
  }
  displayValidationErrors(errors2) {
    OutputWriter2.writeln(
      import_picocolors.default.red(`
\u274C ${errors2.join(', ')}`)
    );
    OutputWriter2.writeln(
      import_picocolors.default.gray(`Please try again.
`)
    );
  }
  displayExecutionError(error) {
    OutputWriter2.writeln(
      import_picocolors.default.red(`
\u274C Error: ${createErrorMessage(error)}`)
    );
    OutputWriter2.writeln(
      import_picocolors.default.gray(`Please try again.
`)
    );
  }
  displaySummary(config) {
    OutputWriter2.writeln(
      import_picocolors.default.cyan(`
\u2705 Project Configuration Summary:`)
    );
    OutputWriter2.writeln(import_picocolors.default.gray('\u2500'.repeat(DISPLAY.BORDER_LENGTH)));
    OutputWriter2.writeln(import_picocolors.default.white(`Name:        ${config.name}`));
    if (config.description) {
      OutputWriter2.writeln(import_picocolors.default.white(`Description: ${config.description}`));
    }
    if (config.author) {
      OutputWriter2.writeln(import_picocolors.default.white(`Author:      ${config.author}`));
    }
    if (config.license) {
      OutputWriter2.writeln(import_picocolors.default.white(`License:     ${config.license}`));
    }
    OutputWriter2.writeln(import_picocolors.default.white(`Quality:     ${config.qualityLevel}`));
    OutputWriter2.writeln(import_picocolors.default.white(`Type:        ${config.projectType}`));
    OutputWriter2.writeln(
      import_picocolors.default.white(`AI Assistants: ${config.aiAssistants.join(', ')}`)
    );
    OutputWriter2.writeln(import_picocolors.default.gray('\u2500'.repeat(DISPLAY.BORDER_LENGTH)));
    OutputWriter2.writeln(
      import_picocolors.default.green(`
\uD83C\uDF89 Ready to generate your project!
`)
    );
  }
}
var import_picocolors;
var init_project_wizard = __esm(() => {
  init_constants();
  init_wizard_prompts();
  init_wizard_steps();
  init_wizard_validators();
  import_picocolors = __toESM(require_picocolors(), 1);
});

// ../../packages/core/src/types/config.ts
function validateConfigPaths(config) {
  const errors2 = [];
  const checkPath = (path2, fieldPath) => {
    if (path2 && (path2.startsWith('/') || path2.includes('..'))) {
      errors2.push(
        `${fieldPath}: Absolute paths and parent directory references are not allowed (got: ${path2})`
      );
    }
  };
  checkPath(config.tools?.eslint?.configPath, 'tools.eslint.configPath');
  checkPath(config.tools?.typescript?.configPath, 'tools.typescript.configPath');
  checkPath(config.tools?.prettier?.configPath, 'tools.prettier.configPath');
  checkPath(config.scaffolding?.templateDirectory, 'scaffolding.templateDirectory');
  checkPath(config.logging?.destination, 'logging.destination');
  return errors2;
}
// ../../packages/core/src/config/defaults.ts
var DEFAULT_CONFIG;
var init_defaults = __esm(() => {
  DEFAULT_CONFIG = {
    version: 1,
    qualityLevel: 'strict',
    aiAssistants: ['claude-code'],
    tools: {
      eslint: {
        enabled: true,
        configPath: '.eslintrc.json',
      },
      typescript: {
        enabled: true,
        configPath: 'tsconfig.json',
        strict: true,
        target: 'ES2022',
      },
      prettier: {
        enabled: true,
        configPath: '.prettierrc.json',
      },
      bunTest: {
        enabled: true,
        coverage: true,
        coverageThreshold: 80,
      },
    },
    scaffolding: {
      templateDirectory: 'templates',
      includeExamples: true,
      initializeGit: true,
      installDependencies: true,
    },
    validation: {
      cache: true,
      parallel: true,
    },
    refactoring: {
      preview: true,
    },
    logging: {
      level: 'info',
      destination: '~/.nimata/logs/nimata.log',
    },
  };
});

// ../../packages/core/src/utils/deep-merge.ts
function isPlainObject2(value) {
  return (
    typeof value === 'object' &&
    value !== null &&
    !Array.isArray(value) &&
    Object.prototype.toString.call(value) === '[object Object]' &&
    Object.getPrototypeOf(value) === Object.prototype
  );
}
function deepMerge2(base, override) {
  validateInputs(base);
  const result = { ...base };
  mergeKeys(result, override);
  return result;
}
function validateInputs(base) {
  if (typeof base !== 'object' || base === null || Array.isArray(base)) {
    throw new TypeError('Base must be an object');
  }
}
function mergeKeys(result, override) {
  if (!isPlainObject2(override)) {
    return;
  }
  for (const key in override) {
    if (!Object.prototype.hasOwnProperty.call(override, key)) {
      continue;
    }
    mergeKey(result, key, override[key]);
  }
}
function mergeKey(result, key, overrideValue) {
  if (overrideValue === undefined) {
    return;
  }
  const baseValue = result[key];
  const shouldMergeRecursively = isPlainObject2(baseValue) && isPlainObject2(overrideValue);
  result[key] = shouldMergeRecursively ? deepMerge2(baseValue, overrideValue) : overrideValue;
}

// ../../packages/core/src/utils/string-utils.ts
function toPascalCase(str) {
  if (!str || typeof str !== 'string') {
    return '';
  }
  return str
    .replace(/(?:^\w)|[A-Z]|(?:\b\w)/g, (word) => {
      return word.toUpperCase();
    })
    .replace(/\s+/g, '')
    .replace(/-/g, '')
    .replace(/_/g, '');
}

// ../../packages/core/src/utils/logger.ts
class Logger {
  static instance;
  logLevel;
  constructor(logLevel = 'info') {
    this.logLevel = logLevel;
  }
  static getInstance(logLevel) {
    if (!Logger.instance) {
      Logger.instance = new Logger(logLevel);
    }
    return Logger.instance;
  }
  debug(operation, message, metadata) {
    this.log('debug', operation, message, metadata);
  }
  info(operation, message, metadata) {
    this.log('info', operation, message, metadata);
  }
  warn(operation, message, metadata) {
    this.log('warn', operation, message, metadata);
  }
  error(operation, message, metadata) {
    this.log('error', operation, message, metadata);
  }
  log(level, operation, message, metadata) {
    const maskedMetadata = this.maskSensitiveData(metadata);
    const entry = {
      level,
      timestamp: new Date().toISOString(),
      operation,
      message,
      metadata: maskedMetadata,
    };
    if (this.shouldLog(level)) {
      this.outputLog(entry);
    }
  }
  shouldLog(level) {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    return levels[level] >= levels[this.logLevel];
  }
  outputLog(entry) {
    const prefix = `[${entry.timestamp}] [${entry.level.toUpperCase()}] [${entry.operation}] ${entry.message}`;
    const metadataStr = entry.metadata ? JSON.stringify(entry.metadata) : 'undefined';
    switch (entry.level) {
      case 'debug':
        process.stderr.write(`DEBUG: ${prefix} ${metadataStr}
`);
        break;
      case 'info':
        process.stdout.write(`INFO: ${prefix} ${metadataStr}
`);
        break;
      case 'warn':
        if (entry.fieldPath) {
          process.stderr.write(`WARN: ${prefix} ${entry.fieldPath} ${metadataStr}
`);
        } else {
          process.stderr.write(`WARN: ${prefix} ${metadataStr}
`);
        }
        break;
      case 'error':
        process.stderr.write(`ERROR: ${prefix} ${metadataStr}
`);
        break;
    }
  }
  maskSensitiveData(metadata) {
    if (!metadata) return;
    const sensitiveKeys = ['password', 'token', 'secret', 'apikey', 'auth'];
    const masked = {};
    for (const [key, value] of Object.entries(metadata)) {
      const lowerKey = key.toLowerCase();
      const isSensitive = sensitiveKeys.some(
        (sensitive) => lowerKey === sensitive || lowerKey.endsWith(sensitive)
      );
      if (isSensitive && typeof value === 'string') {
        masked[key] = this.maskValue(value);
      } else if (typeof value === 'object' && value !== null) {
        masked[key] = this.maskObject(value);
      } else {
        masked[key] = value;
      }
    }
    return masked;
  }
  maskValue(value) {
    if (value.length <= LOGGER_CONSTANTS.MIN_MASK_LENGTH) {
      return LOGGER_CONSTANTS.FULL_MASK;
    }
    const prefixLength = LOGGER_CONSTANTS.MASK_PREFIX_LENGTH;
    const suffixLength = LOGGER_CONSTANTS.MASK_PREFIX_LENGTH;
    return `${value.substring(0, prefixLength)}${LOGGER_CONSTANTS.FULL_MASK}${value.substring(value.length - suffixLength)}`;
  }
  maskObject(obj) {
    if (Array.isArray(obj)) {
      return obj.map((item) => this.maskObject(item));
    }
    if (typeof obj === 'object' && obj !== null) {
      const masked = {};
      for (const [key, value] of Object.entries(obj)) {
        const lowerKey = key.toLowerCase();
        const isSensitive = ['password', 'token', 'secret', 'apikey', 'auth'].some(
          (sensitive) => lowerKey === sensitive || lowerKey.endsWith(sensitive)
        );
        masked[key] =
          isSensitive && typeof value === 'string' ? this.maskValue(value) : this.maskObject(value);
      }
      return masked;
    }
    return obj;
  }
}
var LOGGER_CONSTANTS, logger;
var init_logger = __esm(() => {
  LOGGER_CONSTANTS = {
    MIN_MASK_LENGTH: 4,
    MASK_PREFIX_LENGTH: 2,
    FULL_MASK: '****',
  };
  logger = Logger.getInstance();
});
// ../../packages/core/src/services/generators/cli/cli-entry-point-generator.ts
import { promises as fs } from 'fs';
import { join } from 'path';

class CliEntryPointGenerator {
  async generateCliEntryPoint(basePath, cliName) {
    const filePath = join(basePath, 'bin', cliName);
    const content = this.generateCliContent(cliName);
    try {
      await fs.mkdir(join(basePath, 'bin'), { recursive: true, mode: DEFAULT_DIR_PERMISSIONS });
      await fs.writeFile(filePath, content, { mode: DEFAULT_EXECUTABLE_PERMISSIONS });
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to create CLI entry point: ${error.message}`);
      }
      throw new Error('Failed to create CLI entry point: Unknown error');
    }
  }
  generateCliContent(cliName) {
    return [
      this.generateShebang(),
      this.generateFileHeader(cliName),
      this.generateErrorHandlers(),
      this.generateCliEntryPointFunction(cliName),
      this.generateShowHelpFunction(cliName),
      this.generateHandleCliErrorFunction(cliName),
      this.generateEntryPointCall(),
    ].join(`
`);
  }
  generateShebang() {
    return '#!/usr/bin/env bun';
  }
  generateFileHeader(cliName) {
    return `/**
 * ${cliName} CLI Entry Point
 *
 * Main CLI launcher for ${cliName}
 *
 * @author Your Name
 * @license MIT
 * @version 1.0.0
 */`;
  }
  generateErrorHandlers() {
    return `// Error handling for uncaught exceptions
process.on('uncaughtException', (error) => {
  process.stderr.write('Uncaught Exception: ' + error.message + '\\n');
  if (process.env.NODE_ENV === 'development') {
    process.stderr.write((error.stack || 'No stack available') + '\\n');
  }
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  process.stderr.write('Unhandled Rejection at: ' + String(promise) + ', reason: ' + String(reason) + '\\n');
  process.exit(1);
});`;
  }
  generateCliEntryPointFunction(cliName) {
    return `/**
 * CLI entry point wrapper with enhanced error handling
 */
async function cliEntryPoint(): Promise<void> {
  try {
    // Parse command line arguments
    const args = process.argv.slice(2);

    // Show help if no arguments provided
    if (args.length === 0) {
      showHelp('${cliName}');
      return;
    }

    // Handle basic commands
    if (args.includes('--help')) {
      showHelp('${cliName}');
      return;
    }

    if (args.includes('--version')) {
      process.stdout.write('${cliName} version 1.0.0\\n');
      return;
    }

    // Add your CLI logic here
    process.stdout.write('Hello from ${cliName} CLI!\\n');

  } catch (error) {
    handleCliError(error, '${cliName}');
  }
}`;
  }
  generateShowHelpFunction(cliName) {
    return `/**
 * Shows help information for the CLI
   * @param {string} cliName - Name of the CLI tool
 */
function showHelp(cliName: string): void {
  const helpText = [
    '${cliName} - CLI Tool',
    'Usage: ${cliName} [options]',
    '',
    'Options:',
    '  --help     Show this help message',
    '  --version  Show version information'
  ].join('\\n');
  process.stdout.write(helpText + '\\n');
}`;
  }
  generateHandleCliErrorFunction(_cliName) {
    return `/**
 * Handles CLI errors with proper formatting
   * @param {string} error - Error that occurred
   * @param {string} cliName - Name of the CLI tool
 */
function handleCliError(error: unknown, cliName: string): void {
  process.stderr.write('\u274C ' + cliName + ' CLI Error:\\n');
  if (error instanceof Error) {
    process.stderr.write(error.message + '\\n');
    if (process.env.NODE_ENV === 'development' || process.env.VERBOSE) {
      process.stderr.write('\\nStack trace:\\n');
      process.stderr.write((error.stack || 'No stack available') + '\\n');
    }
  } else {
    process.stderr.write('Unknown error occurred\\n');
  }

  // Exit with error code
  process.exit(1);
}`;
  }
  generateEntryPointCall() {
    return `// Execute CLI entry point
cliEntryPoint();`;
  }
}
var DEFAULT_DIR_PERMISSIONS = 493,
  DEFAULT_EXECUTABLE_PERMISSIONS = 493;
var init_cli_entry_point_generator = () => {};

// ../../packages/core/src/services/generators/config/constants.ts
var JSON_INDENTATION = 2,
  NODE_VERSIONS,
  DIRECTORIES,
  TS_TARGETS,
  TS_MODULES,
  TS_JSX,
  ESLINT_RULE_VALUES;
var init_constants2 = __esm(() => {
  NODE_VERSIONS = ['18.x', '20.x'];
  DIRECTORIES = {
    SOURCE: 'src',
    TESTS: 'tests',
    DOCS: 'docs',
    DIST: 'dist',
    BUILD: 'build',
    COVERAGE: 'coverage',
    CACHE: '.cache',
    TEMP: 'temp',
    LOGS: 'logs',
  };
  TS_TARGETS = {
    ES2022: 'ES2022',
  };
  TS_MODULES = {
    ESNEXT: 'ESNext',
  };
  TS_JSX = {
    REACT: 'react-jsx',
  };
  ESLINT_RULE_VALUES = {
    ERROR: 'error',
    WARN: 'warn',
  };
});

// ../../packages/core/src/services/generators/config/eslint-config-generator.ts
class ESLintConfigGenerator {
  generate(_config) {
    return ESLintConfigGenerator.generateESLintConfig();
  }
  static buildESLintOptions() {
    return {
      root: true,
      env: {
        node: true,
        es2022: true,
      },
      extends: [
        'eslint:recommended',
        '@typescript-eslint/recommended',
        '@typescript-eslint/recommended-requiring-type-checking',
      ],
      parser: '@typescript-eslint/parser',
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        project: './tsconfig.json',
      },
      plugins: ['@typescript-eslint'],
      rules: {
        '@typescript-eslint/no-unused-vars': ESLINT_RULE_VALUES.ERROR,
        '@typescript-eslint/explicit-function-return-type': ESLINT_RULE_VALUES.WARN,
        '@typescript-eslint/no-explicit-any': ESLINT_RULE_VALUES.ERROR,
        '@typescript-eslint/no-non-null-assertion': ESLINT_RULE_VALUES.ERROR,
        'prefer-const': ESLINT_RULE_VALUES.ERROR,
        'no-var': ESLINT_RULE_VALUES.ERROR,
      },
    };
  }
  static generateESLintConfig() {
    const config = this.buildESLintOptions();
    return `export default ${JSON.stringify(config, null, JSON_INDENTATION)};`;
  }
}
var init_eslint_config_generator = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/config/gitignore-generator.ts
class GitignoreGenerator {
  generate(_config) {
    return [
      this.generateDependencies(),
      this.generateBuilds(),
      this.generateEnvironment(),
      this.generateIDE(),
      this.generateOS(),
      this.generateLogs(),
      this.generateRuntime(),
      this.generateCoverage(),
      this.generateCache(),
      this.generateOutputs(),
      this.generateEditors(),
    ].join(`
`);
  }
  generateDependencies() {
    return `# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
jspm_packages/`;
  }
  generateBuilds() {
    return `# Production builds
dist/
build/
out/
.next/
.nuxt/
.cache/

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt

# Gatsby files
.cache/
public`;
  }
  generateEnvironment() {
    return `# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local`;
  }
  generateIDE() {
    return `# IDE files
.vscode/
.idea/
*.swp
*.swo
*~`;
  }
  generateOS() {
    return `# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db`;
  }
  generateLogs() {
    return `# Logs
logs/
*.log`;
  }
  generateRuntime() {
    return `# Runtime data
pids/
*.pid
*.seed
*.pid.lock`;
  }
  generateCoverage() {
    return `# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output/`;
  }
  generateCache() {
    return `# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# parcel-bundler cache (https://parceljs.org/)
.parcel-cache/`;
  }
  generateOutputs() {
    return `# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/`;
  }
  generateEditors() {
    return `# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Local Netlify folder
.netlify

# Turbo
.turbo

# Vite
.vite/

# TypeScript
*.tsbuildinfo

# Test results
test-results/
playwright-report/
test-results.xml
`;
  }
}

// ../../packages/core/src/services/generators/config/package-json-generator.ts
class PackageJsonGenerator {
  static buildPackageScripts(config) {
    const baseScripts = {
      build: 'tsc',
      test: 'vitest',
      'test:watch': 'vitest --watch',
      'test:coverage': 'vitest --coverage',
      lint: 'eslint src/**/*.ts',
      'lint:fix': 'eslint src/**/*.ts --fix',
      format: 'prettier --write .',
      'format:check': 'prettier --check .',
      clean: 'rimraf dist',
      'type-check': 'tsc --noEmit',
      prebuild: 'npm run clean',
    };
    const projectTypeScripts = this.getProjectTypeScripts(config);
    const qualityScripts = this.getQualityScripts(config.qualityLevel);
    return { ...baseScripts, ...projectTypeScripts, ...qualityScripts };
  }
  static getProjectTypeScripts(config) {
    switch (config.projectType) {
      case 'basic':
        return {
          dev: 'tsx watch src/index.ts',
          'test:ui': 'vitest --ui',
        };
      case 'cli':
        return {
          dev: 'tsx src/index.ts',
          'dev:cli': 'tsx src/index.ts',
          start: 'node dist/index.js',
          prepack: 'npm run build',
        };
      case 'web':
        return {
          dev: 'vite',
          'dev:server': 'vite --port 3000',
          build: 'tsc && vite build',
          preview: 'vite preview',
        };
      default:
        return {
          dev: 'tsc --watch',
        };
    }
  }
  static getQualityScripts(qualityLevel) {
    switch (qualityLevel) {
      case 'high':
        return {
          'test:mutation': 'stryker run',
          'test:ci': 'vitest run --coverage && eslint . --ext .ts,.tsx',
          'quality:all': 'bun run lint && bun run test:coverage && bun run test:mutation',
        };
      case 'strict':
        return {
          'test:ci': 'vitest run --coverage && eslint . --ext .ts,.tsx',
          'quality:all': 'bun run lint && bun run test:coverage',
        };
      default:
        return {
          'test:ci': 'vitest run',
        };
    }
  }
  static buildPackageKeywords(config) {
    const baseKeywords = ['typescript', 'bun'];
    const typeKeywords = this.getTypeKeywords(config.projectType);
    return [...baseKeywords, ...typeKeywords];
  }
  static getTypeKeywords(projectType) {
    switch (projectType) {
      case 'cli':
        return ['cli', 'command-line'];
      case 'web':
        return ['web', 'frontend'];
      case 'library':
        return ['library', 'package'];
      case 'bun-react':
        return ['react', 'jsx', 'frontend'];
      case 'bun-vue':
        return ['vue', 'frontend'];
      case 'bun-express':
        return ['express', 'backend', 'api'];
      default:
        return [];
    }
  }
  static buildDependencies(config) {
    const dependencies = {};
    switch (config.projectType) {
      case 'cli':
        dependencies.commander = '^11.0.0';
        dependencies.chalk = '^5.3.0';
        break;
      case 'bun-react':
      case 'web':
        dependencies.react = '^18.2.0';
        dependencies['react-dom'] = '^18.2.0';
        dependencies['react-router-dom'] = '^6.8.0';
        break;
      case 'bun-express':
        dependencies.express = '^4.18.0';
        break;
      case 'bun-vue':
        dependencies.vue = '^3.3.0';
        break;
    }
    return dependencies;
  }
  static buildDevDependencies(config) {
    const baseDevDependencies = this.getBaseDevDependencies();
    switch (config.projectType) {
      case 'basic':
        return this.getBasicDevDependencies(baseDevDependencies);
      case 'cli':
        return this.getCliDevDependencies(baseDevDependencies);
      case 'web':
        return this.getWebDevDependencies();
      case 'library':
        return this.getLibraryDevDependencies();
      default:
        return this.getDefaultDevDependencies(baseDevDependencies);
    }
  }
  static getBaseDevDependencies() {
    return {
      typescript: '^5.0.0',
      vitest: '^1.0.0',
    };
  }
  static getBasicDevDependencies(baseDevDependencies) {
    return {
      ...baseDevDependencies,
      '@types/node': '^20.0.0',
      tsx: '^4.0.0',
      eslint: '^8.40.0',
      '@typescript-eslint/eslint-plugin': '^6.0.0',
      '@typescript-eslint/parser': '^6.0.0',
      rimraf: '^5.0.0',
      '@vitest/coverage-v8': '^1.0.0',
      '@vitest/ui': '^1.0.0',
    };
  }
  static getCliDevDependencies(baseDevDependencies) {
    return {
      ...baseDevDependencies,
      '@types/commander': '^2.12.2',
      '@types/node': '^20.0.0',
    };
  }
  static getWebDevDependencies() {
    return {
      vite: '^5.0.0',
      '@vitejs/plugin-react': '^4.0.0',
      '@types/react': '^18.2.0',
      '@types/react-dom': '^18.2.0',
      typescript: '^5.0.0',
      vitest: '^1.0.0',
    };
  }
  static getLibraryDevDependencies() {
    return {
      typescript: '^5.0.0',
      vitest: '^1.0.0',
      '@types/node': '^20.0.0',
      tsx: '^4.0.0',
      eslint: '^8.40.0',
      '@typescript-eslint/eslint-plugin': '^6.0.0',
      '@typescript-eslint/parser': '^6.0.0',
      rimraf: '^5.0.0',
      '@vitest/coverage-v8': '^1.0.0',
      '@vitest/ui': '^1.0.0',
    };
  }
  static getDefaultDevDependencies(baseDevDependencies) {
    return {
      ...baseDevDependencies,
      '@types/node': '^20.0.0',
      eslint: '^9.0.0',
      '@typescript-eslint/eslint-plugin': '^8.0.0',
      '@typescript-eslint/parser': '^8.0.0',
      prettier: '^3.0.0',
      '@vitest/coverage-v8': '^1.0.0',
    };
  }
  static generatePackageJson(config) {
    const packageConfig = this.buildBasePackageConfig(config);
    this.addProjectSpecificFields(packageConfig, config);
    return JSON.stringify(packageConfig, null, JSON_INDENTATION);
  }
  generate(config) {
    return PackageJsonGenerator.generatePackageJson(config);
  }
  static buildBasePackageConfig(config) {
    return {
      name: config.name,
      version: config.version || '1.0.0',
      description: config.description || `${config.name} project`,
      main: config.projectType === 'cli' ? 'dist/index.js' : 'src/index.ts',
      module: config.projectType === 'library' ? './dist/index.esm.js' : undefined,
      types: config.projectType === 'library' ? './dist/index.d.ts' : 'dist/index.d.ts',
      type: 'module',
      scripts: this.buildPackageScripts(config),
      keywords: this.buildPackageKeywords(config),
      author: config.author || '',
      license: config.license || 'MIT',
      dependencies: this.buildDependencies(config),
      devDependencies: this.buildDevDependencies(config),
      engines: {
        node: '>=18.0.0',
        npm: '>=8.0.0',
        bun: '>=1.3.0',
      },
    };
  }
  static addProjectSpecificFields(packageConfig, config) {
    if (config.projectType === 'cli') {
      packageConfig.bin = {
        [config.name]: 'dist/index.js',
      };
    }
    if (config.projectType === 'library') {
      packageConfig.exports = {
        '.': {
          types: './dist/index.d.ts',
          import: './dist/index.js',
        },
      };
    }
  }
}
var init_package_json_generator = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/config/typescript-config-generator.ts
class TypeScriptConfigGenerator {
  static buildBasicOptions() {
    return {
      target: TS_TARGETS.ES2022,
      module: TS_MODULES.ESNEXT,
      moduleResolution: 'node',
      allowSyntheticDefaultImports: true,
      esModuleInterop: true,
      allowJs: true,
      checkJs: false,
      jsx: TS_JSX.REACT,
    };
  }
  static buildOutputOptions() {
    return {
      declaration: true,
      declarationMap: true,
      sourceMap: true,
      outDir: 'dist',
      rootDir: 'src',
      removeComments: false,
      noEmit: true,
    };
  }
  static buildStrictOptions() {
    return {
      strict: true,
      noImplicitAny: true,
      strictNullChecks: true,
      strictFunctionTypes: true,
      noImplicitReturns: true,
      noFallthroughCasesInSwitch: true,
      noUncheckedIndexedAccess: true,
      noImplicitOverride: true,
      exactOptionalPropertyTypes: true,
    };
  }
  static buildModuleOptions() {
    return {
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      isolatedModules: true,
      verbatimModuleSyntax: true,
      resolveJsonModule: true,
      baseUrl: '.',
      paths: {
        '@/*': ['src/*'],
        '@/types/*': ['src/types/*'],
        '@/utils/*': ['src/utils/*'],
        '@/config/*': ['src/config/*'],
        '@/services/*': ['src/services/*'],
      },
    };
  }
  static buildCompilerOptions() {
    return {
      ...this.buildBasicOptions(),
      ...this.buildOutputOptions(),
      ...this.buildStrictOptions(),
      ...this.buildModuleOptions(),
    };
  }
  static generateTypeScriptConfig(_config) {
    const compilerOptions = this.buildCompilerOptions();
    const baseConfig = {
      compilerOptions,
      include: ['src/**/*', 'tests/**/*'],
      exclude: ['node_modules', 'dist', 'build', 'coverage'],
      'ts-node': {
        esm: true,
        experimentalSpecifierResolution: 'node',
      },
    };
    return JSON.stringify(baseConfig, null, JSON_INDENTATION);
  }
  generate(config) {
    return TypeScriptConfigGenerator.generateTypeScriptConfig(config);
  }
}
var init_typescript_config_generator = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/config/config-file-generators.ts
class ConfigFileGenerators {
  gitignoreGenerator = new GitignoreGenerator();
  packageJsonGenerator = new PackageJsonGenerator();
  typescriptConfigGenerator = new TypeScriptConfigGenerator();
  eslintConfigGenerator = new ESLintConfigGenerator();
  generateGitignore(config) {
    return this.gitignoreGenerator.generate(config);
  }
  generatePackageJson(config) {
    return this.packageJsonGenerator.generate(config);
  }
  generateTsConfig(config) {
    return this.typescriptConfigGenerator.generate(config);
  }
  generateESLintConfig(config) {
    return this.eslintConfigGenerator.generate(config);
  }
}
var init_config_file_generators = __esm(() => {
  init_eslint_config_generator();
  init_package_json_generator();
  init_typescript_config_generator();
});

// ../../packages/core/src/services/generators/config/ai-config-generators.ts
class AIConfigGenerators {
  static generateClaudeConfig(config) {
    const projectInfo = this.getProjectInfo(config);
    const guidelines = this.getDevelopmentGuidelines();
    const structure = this.getProjectStructure();
    const commands = this.getCommands();
    const instructions = this.getAIInstructions();
    return `# Claude Code Configuration for ${config.name}

## AI Assistant
This configuration is for **claude-code** AI assistant.

${projectInfo}

${guidelines}

${structure}

${commands}

${instructions}`;
  }
  static generateCopilotConfig(config) {
    const context = this.getProjectContext(config);
    const overview = this.getOverviewSection(config);
    const styleGuidelines = this.getCodeStyleGuidelines();
    const testingRequirements = this.getTestingRequirements();
    const securityConsiderations = this.getSecurityConsiderations();
    const performanceGuidelines = this.getPerformanceGuidelines();
    const projectSpecificGuidelines = this.getProjectSpecificGuidelines(config);
    return `# GitHub Copilot Instructions

${overview}

${context}

${styleGuidelines}

${testingRequirements}

${securityConsiderations}

${performanceGuidelines}

${projectSpecificGuidelines}`;
  }
  static generateAIContext(config) {
    const overview = this.getProjectOverview(config);
    const techStack = this.getTechStack(config);
    const projectConfig = this.getProjectConfiguration(config);
    const devStandards = this.getDevelopmentStandards(config);
    const testingStrategy = this.getTestingStrategy();
    const qualityGates = this.getQualityGates(config);
    const changeProcess = this.getChangeProcess();
    return `# AI Context for ${config.name}

${overview}

${techStack}

${projectConfig}

${devStandards}

${testingStrategy}

${qualityGates}

${changeProcess}`;
  }
  static generateCursorRules(config) {
    const intro = this.getIntroduction(config);
    const technicalGuidelines = this.getTechnicalGuidelines();
    const qualityStandards = this.getQualityStandards();
    const testingRequirements = this.getCursorTestingRequirements(config);
    const securityPrinciples = this.getSecurityPrinciples();
    const codingProcess = this.getCodingProcess();
    const projectContext = this.getProjectSpecificContext(config);
    return `# Cursor Rules for ${config.name}

${intro}

${technicalGuidelines}

${qualityStandards}

${testingRequirements}

${securityPrinciples}

${codingProcess}

${projectContext}`;
  }
  static getProjectInfo(config) {
    return `## Project Information
- **Name**: ${config.name}
- **Type**: ${config.projectType}
- **Quality Level**: ${config.qualityLevel}
- **Template**: ${config.template || 'basic'}`;
  }
  static getDevelopmentGuidelines() {
    return `## Development Guidelines
- All code must be written in English
- Use TypeScript with strict mode enabled
- Follow the existing code style and patterns
- Ensure all tests pass before committing
- Maintain test coverage above 80%
- Run mutation testing with Stryker`;
  }
  static getProjectStructure() {
    return `## Project Structure
- \`src/\`: Source code
- \`tests/\`: Test files
- \`docs/\`: Documentation
- \`dist/\`: Build output`;
  }
  static getCommands() {
    return `## Commands
- \`bun test\`: Run tests
- \`bun run lint\`: Check code quality
- \`bun run typecheck\`: Verify types
- \`bun run build\`: Build the project`;
  }
  static getAIInstructions() {
    return `## AI Assistant Instructions
When generating code for this project:
1. Always include TypeScript types
2. Write comprehensive tests
3. Follow the existing patterns and conventions
4. Add proper documentation
5. Consider performance and security`;
  }
  static getOverviewSection(config) {
    const projectTypeNames = {
      basic: 'Basic Application',
      web: 'Web Application',
      cli: 'CLI Application',
      library: 'Library Package',
    };
    return `## Overview

This is a ${projectTypeNames[config.projectType] || config.projectType}.

**Name**: ${config.name}`;
  }
  static getProjectContext(config) {
    return `## Project Guidelines
- Author: Your Name
- License: MIT
- Project Type: ${config.projectType}
- Quality Level: ${config.qualityLevel}`;
  }
  static getCodeStyleGuidelines() {
    return `## Coding Standards
- Write all code, comments, and documentation in English
- Follow TypeScript best practices
- Use ESLint and Prettier for code formatting
- Maintain consistent naming conventions`;
  }
  static getTestingRequirements() {
    return `## Testing Requirements
- Write tests for all public methods
- Use Vitest for unit testing
- Aim for 80%+ code coverage
- Include edge cases and error scenarios`;
  }
  static getSecurityConsiderations() {
    return `## Security Considerations
- Validate all inputs from external sources
- Handle errors appropriately
- Avoid exposing sensitive information
- Follow secure coding practices`;
  }
  static getPerformanceGuidelines() {
    return `## Performance Guidelines
- Optimize for Bun runtime
- Use async/await for async operations
- Consider memory usage and performance`;
  }
  static getProjectSpecificGuidelines(config) {
    if (config.projectType === 'cli') {
      return `## CLI Development Guidelines

- Use command pattern for CLI operations
- Handle errors gracefully and provide helpful error messages
- Support both programmatic and interactive usage
- TypeScript
- Browser`;
    } else if (config.projectType === 'web') {
      return `## Web Development Guidelines

- Build responsive, accessible user interfaces
- Follow modern web standards and best practices
- Optimize for performance and user experience
- TypeScript
- Browser`;
    } else if (config.projectType === 'library') {
      return `## Library Development Guidelines

- Design clear, well-documented public APIs
- Follow semantic versioning for releases
- Provide comprehensive examples and documentation
- TypeScript
- Browser`;
    }
    return `## Development Guidelines

- Write clean, maintainable code
- Follow established patterns and conventions
- TypeScript
- Browser`;
  }
  static getProjectOverview(config) {
    return `## Project Information
${config.description || 'A modern TypeScript library built with Bun'}`;
  }
  static getTechStack(config) {
    const mutationTesting = config.qualityLevel === 'high' ? ' + Stryker' : '';
    return `## Technical Stack
- Runtime: Bun
- Language: TypeScript (strict mode)
- Testing: Vitest
- Quality: ESLint + Prettier${mutationTesting}`;
  }
  static getProjectConfiguration(config) {
    return `## Project Configuration
- Name: ${config.name}
- Type: ${config.projectType}
- Quality: ${config.qualityLevel}
- Template: ${config.template || 'basic'}`;
  }
  static getDevelopmentStandards(config) {
    const mutationRequirement =
      config.qualityLevel === 'high'
        ? `
7. Achieve 80%+ mutation testing score`
        : '';
    return `## Development Standards
1. Code must be written in English
2. All functions must have explicit return types
3. Use 'const' and 'let', never 'var'
4. Follow functional programming principles where possible
5. Write comprehensive tests with meaningful assertions
6. Maintain code coverage above 80%${mutationRequirement}`;
  }
  static getTestingStrategy() {
    return `## Testing Strategy
- Unit tests for all functions and classes
- Integration tests for complex workflows
- Edge case and error handling tests
- Performance tests for critical paths`;
  }
  static getQualityGates(config) {
    const mutationGate =
      config.qualityLevel === 'high'
        ? `
- 80%+ mutation testing score`
        : '';
    return `## Quality Gates
- TypeScript compilation with no errors
- ESLint with no warnings or errors
- 100% test pass rate
- 80%+ code coverage${mutationGate}`;
  }
  static getChangeProcess() {
    return `## When Making Changes
1. Understand the existing codebase structure
2. Follow established patterns and conventions
3. Write tests before implementing features
4. Verify all quality gates pass
5. Update documentation as needed`;
  }
  static getIntroduction(config) {
    return `You are an expert TypeScript developer working on a ${config.projectType} project.`;
  }
  static getTechnicalGuidelines() {
    return `## Technical Guidelines
- Use Bun as the runtime environment
- Write TypeScript in strict mode
- Follow ESLint rules without exceptions
- Format code with Prettier
- Write comprehensive tests with Vitest`;
  }
  static getQualityStandards() {
    return `## Code Quality Standards
- No 'any' types - use explicit TypeScript types
- No non-null assertions (!) - use proper type guards
- No disabled ESLint rules - fix the underlying issues
- Functions must be \u226430 lines and \u226410 complexity
- Files must be \u2264300 lines`;
  }
  static getCursorTestingRequirements(config) {
    const mutationRequirement =
      config.qualityLevel === 'high'
        ? `
- Achieve 80%+ mutation testing score`
        : '';
    return `## Testing Requirements
- Test all public methods and edge cases
- Use descriptive test names with Given-When-Then structure
- Verify behavior, not just execution
- Achieve 80%+ code coverage${mutationRequirement}`;
  }
  static getSecurityPrinciples() {
    return `## Security Principles
- Validate all inputs from external sources
- Handle errors gracefully without exposing sensitive information
- Use parameterized queries for database operations
- Escape outputs to prevent XSS attacks`;
  }
  static getCodingProcess() {
    return `## When Writing Code
1. Understand the requirements and existing codebase
2. Plan the implementation before coding
3. Write tests first (TDD approach preferred)
4. Implement the solution incrementally
5. Refactor for clarity and maintainability
6. Verify all quality gates pass`;
  }
  static getProjectSpecificContext(config) {
    return `## Project-Specific Context
This is a ${config.name} project with ${config.qualityLevel} quality standards.
${config.description || 'Focus on clean, maintainable code.'}`;
  }
}

// ../../packages/core/src/services/generators/config/ci-generators.ts
class CIGenerators {
  static generateCIConfig() {
    const workflowHeader = this.getWorkflowHeader();
    const jobs = this.getJobs();
    return `${workflowHeader}

${jobs}`;
  }
  static getWorkflowHeader() {
    return `name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]`;
  }
  static getJobs() {
    const matrix = this.getNodeVersionMatrix();
    const steps = this.getJobSteps();
    return `jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [${matrix}]

    steps:
${steps}`;
  }
  static getNodeVersionMatrix() {
    return NODE_VERSIONS.map((version) => `'${version}'`).join(', ');
  }
  static getJobSteps() {
    const steps = [
      this.getCheckoutStep(),
      this.getBunSetupStep(),
      this.getInstallStep(),
      this.getTypeCheckStep(),
      this.getLintStep(),
      this.getTestStep(),
      this.getMutationTestStep(),
      this.getBuildStep(),
    ];
    return steps.join(`

`);
  }
  static getCheckoutStep() {
    return '    - uses: actions/checkout@v4';
  }
  static getBunSetupStep() {
    return `    - name: Use Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest`;
  }
  static getInstallStep() {
    return `    - name: Install dependencies
      run: bun install`;
  }
  static getTypeCheckStep() {
    return `    - name: Type check
      run: bun run typecheck`;
  }
  static getLintStep() {
    return `    - name: Lint
      run: bun run lint`;
  }
  static getTestStep() {
    return `    - name: Test
      run: bun test --coverage`;
  }
  static getMutationTestStep() {
    return `    - name: Mutation test
      run: bun run test:mutate`;
  }
  static getBuildStep() {
    return `    - name: Build
      run: bun run build`;
  }
}
var init_ci_generators = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/config/documentation-generator.ts
class DocumentationGenerator {
  static generateAPIDocumentation(config) {
    return `# API Documentation

## Overview

${config.description || 'A modern TypeScript project'}

## Table of Contents

- [Installation](#installation)
- [Usage](#usage)
- [API Reference](#api-reference)

## Installation

\`\`\`bash
bun install
\`\`\`

## Usage

\`\`\`typescript
import { main } from '${config.name}';

// TODO: Add usage examples
\`\`\`

## API Reference

### Functions

\`\`\`typescript
// TODO: Add function documentation
\`\`\`

## Contributing

Please see the main README.md for contribution guidelines.

## License

${config.license || 'MIT'}
`;
  }
  generate(config) {
    return DocumentationGenerator.generateAPIDocumentation(config);
  }
}

// ../../packages/core/src/services/generators/config/prettier-config-generator.ts
class PrettierConfigGenerator {
  static buildPrettierOptions() {
    return {
      semi: true,
      trailingComma: 'es5',
      singleQuote: true,
      printWidth: 100,
      tabWidth: JSON_INDENTATION,
      useTabs: false,
    };
  }
  static generatePrettierConfig() {
    const config = this.buildPrettierOptions();
    return JSON.stringify(config, null, JSON_INDENTATION);
  }
  generate() {
    return PrettierConfigGenerator.generatePrettierConfig();
  }
}
var init_prettier_config_generator = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/config/stryker-config-generator.ts
class StrykerConfigGenerator {
  static buildStrykerOptions() {
    return {
      _comment: 'This config was generated using stryker config init',
      $schema: './node_modules/@stryker-mutator/core/schema/stryker-schema.json',
      testRunner: 'vitest',
      coverageAnalysis: 'perTest',
      reporters: ['progress', 'clear-text', 'html'],
      thresholds: {
        high: 80,
        low: 60,
      },
    };
  }
  static generateStrykerConfig() {
    const config = this.buildStrykerOptions();
    return JSON.stringify(config, null, JSON_INDENTATION);
  }
  generate() {
    return StrykerConfigGenerator.generateStrykerConfig();
  }
}
var init_stryker_config_generator = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/config/vitest-config-generator.ts
class VitestConfigGenerator {
  static generateVitestConfig() {
    return `import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/**/*.ts'],
      exclude: ['src/**/*.test.ts', 'src/**/*.spec.ts']
    }
  }
});`;
  }
  generate() {
    return VitestConfigGenerator.generateVitestConfig();
  }
}

// ../../packages/core/src/services/generators/config/config-generators.ts
class ConfigGenerators {
  static generateTypeScriptConfig(config) {
    return TypeScriptConfigGenerator.generateTypeScriptConfig(config);
  }
  static generatePrettierConfig() {
    return PrettierConfigGenerator.generatePrettierConfig();
  }
  static generateESLintConfig() {
    return ESLintConfigGenerator.generateESLintConfig();
  }
  static generateVitestConfig() {
    return VitestConfigGenerator.generateVitestConfig();
  }
  static generateStrykerConfig() {
    return StrykerConfigGenerator.generateStrykerConfig();
  }
  static generatePackageJson(config) {
    return PackageJsonGenerator.generatePackageJson(config);
  }
  static generateAPIDocumentation(config) {
    return DocumentationGenerator.generateAPIDocumentation(config);
  }
}
var init_config_generators = __esm(() => {
  init_eslint_config_generator();
  init_package_json_generator();
  init_prettier_config_generator();
  init_stryker_config_generator();
  init_typescript_config_generator();
});

// ../../packages/core/src/services/generators/config/misc-generators.ts
class MiscGenerators {
  static generateGitignore() {
    const coreSections = [
      this.getDependenciesSection(),
      this.getBuildSection(),
      this.getEnvironmentSection(),
    ];
    const toolingSections = [
      this.getIDESection(),
      this.getLogsSection(),
      this.getCoverageSection(),
      this.getTypeScriptSection(),
    ];
    const systemSections = [this.getOSSection(), this.getCacheSection(), this.getTempSection()];
    const projectSections = [this.getBunSection()];
    return [...coreSections, ...toolingSections, ...systemSections, ...projectSections].join(`

`);
  }
  static getDependenciesSection() {
    return `# Dependencies
node_modules/
bun.lockb`;
  }
  static getBuildSection() {
    return `# Build output
${DIRECTORIES.DIST}/
${DIRECTORIES.BUILD}/`;
  }
  static getEnvironmentSection() {
    return `# Environment variables
.env
.env.local
.env.production`;
  }
  static getIDESection() {
    return `# IDE
.vscode/
.idea/
*.swp
*.swo`;
  }
  static getOSSection() {
    return `# OS
.DS_Store
Thumbs.db`;
  }
  static getLogsSection() {
    return `# Logs
${DIRECTORIES.LOGS}/
*.log`;
  }
  static getCoverageSection() {
    return `# Coverage
${DIRECTORIES.COVERAGE}/`;
  }
  static getTypeScriptSection() {
    return `# TypeScript
*.tsbuildinfo
*.d.ts.map`;
  }
  static getCacheSection() {
    return `# Cache
${DIRECTORIES.CACHE}/
.nimata/cache/
temp/`;
  }
  static getTempSection() {
    return `# Temporary files
*.tmp
*.temp
*.swp
*.swo
*~`;
  }
  static getBunSection() {
    return `# Bun
bun.lockb`;
  }
}
var init_misc_generators = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/config/readme-generator.ts
class ReadmeGenerator {
  static generate(config) {
    const header = this.generateHeader(config);
    const features = this.generateFeatures(config);
    const installation = this.generateInstallation(config);
    const usage = this.generateUsage(config);
    const development = this.generateDevelopmentSection();
    const license = this.generateLicense(config);
    const footer = this.generateFooter(config);
    return [header, features, installation, usage, development, license, footer].join(`

`);
  }
  static generateHeader(config) {
    const description = config.description
      ? `

${config.description}`
      : '';
    return `# ${config.name}${description}`;
  }
  static generateFeatures(config) {
    const baseFeatures = `- \uD83D\uDE80 Built with [Bun](https://bun.sh) for lightning-fast performance
- \uD83D\uDCDD Written in TypeScript with strict type checking
- \uD83E\uDDEA Comprehensive test coverage with [Vitest](https://vitest.dev/)
- \uD83C\uDFA8 Consistent code formatting with [Prettier](https://prettier.io/)
- \uD83D\uDD0D Code quality checks with [ESLint](https://eslint.org/)`;
    const additionalFeatures =
      config.qualityLevel === 'high'
        ? `
- \uD83E\uDDEC Mutation testing with [Stryker](https://stryker-mutator.io/)
- \uD83D\uDE80 CI/CD pipeline with GitHub Actions`
        : '';
    return `## Features

${baseFeatures}${additionalFeatures}`;
  }
  static generateInstallation(config) {
    return `## Installation

\`\`\`bash
bun add ${config.name}
\`\`\``;
  }
  static generateUsage(config) {
    const pascalCaseName = toPascalCase(config.name);
    return `## Usage

\`\`\`typescript
import { ${pascalCaseName}Core } from '${config.name}';

const app = new ${pascalCaseName}Core({
  debug: true
});

await app.initialize();
\`\`\``;
  }
  static generateDevelopmentSection() {
    return `## Development

\`\`\`bash
# Install dependencies
bun install

# Run tests
bun test

# Run tests with coverage
bun test --coverage

# Type checking
bun run typecheck

# Linting
bun run lint

# Format code
bun run format

# Build
bun run build
\`\`\``;
  }
  static generateLicense(config) {
    return `## License

${config.license || 'MIT'}`;
  }
  static generateFooter(config) {
    return `---

Made with \u2764\uFE0F by ${config.author || 'the community'}`;
  }
}
var init_readme_generator = () => {};

// ../../packages/core/src/services/generators/config/content-generators.ts
class ContentGenerators {
  static generateReadme(config) {
    return ReadmeGenerator.generate(config);
  }
  static generateGitignore() {
    return MiscGenerators.generateGitignore();
  }
  static generateTypeScriptConfig(config) {
    return ConfigGenerators.generateTypeScriptConfig(config);
  }
  static generatePrettierConfig() {
    return ConfigGenerators.generatePrettierConfig();
  }
  static generateESLintConfig() {
    return ConfigGenerators.generateESLintConfig();
  }
  static generateVitestConfig() {
    return ConfigGenerators.generateVitestConfig();
  }
  static generateStrykerConfig() {
    return ConfigGenerators.generateStrykerConfig();
  }
  static generateCIConfig() {
    return CIGenerators.generateCIConfig();
  }
  static generateClaudeConfig(config) {
    return AIConfigGenerators.generateClaudeConfig(config);
  }
  static generateCopilotConfig(config) {
    return AIConfigGenerators.generateCopilotConfig(config);
  }
  static generateAIContext(config) {
    return AIConfigGenerators.generateAIContext(config);
  }
  static generateCursorRules(config) {
    return AIConfigGenerators.generateCursorRules(config);
  }
  static generatePackageJson(config) {
    return ConfigGenerators.generatePackageJson(config);
  }
  static generateAPIDocumentation(config) {
    return ConfigGenerators.generateAPIDocumentation(config);
  }
}
var init_content_generators = __esm(() => {
  init_ci_generators();
  init_config_generators();
  init_misc_generators();
  init_readme_generator();
});

// ../../packages/core/src/services/generators/core/ai/claude-config-generator.ts
class ClaudeConfigGenerator {
  static generateClaudeConfig(config) {
    return {
      path: 'CLAUDE.md',
      type: 'file',
      content: ClaudeConfigGenerator.generateClaudeConfigContent(config),
    };
  }
  static generateClaudeConfigContent(config) {
    return [
      ClaudeConfigGenerator.generateClaudeHeader(config),
      ClaudeConfigGenerator.generateClaudeProjectOverview(config),
      ClaudeConfigGenerator.generateClaudeCodeStandards(),
      ClaudeConfigGenerator.generateClaudeDevelopmentGuidelines(),
      ClaudeConfigGenerator.generateClaudeTestingRequirements(),
      ClaudeConfigGenerator.generateClaudeProjectStructure(config),
      ClaudeConfigGenerator.generateClaudeQualityStandards(config),
      ClaudeConfigGenerator.generateClaudeNotes(config),
    ].join(`

`);
  }
  static generateClaudeHeader(_config) {
    return `# Claude Code Integration

AI Assistant: claude-code`;
  }
  static generateClaudeProjectOverview(config) {
    return `## Project Information

**Name**: ${config.name}
**Description**: ${config.description || 'A modern TypeScript project'}`;
  }
  static generateClaudeCodeStandards() {
    return `## Code Standards
- All code, comments, and documentation must be written in English
- Follow ESLint rules without disabling them inline
- Write comprehensive tests with high mutation score thresholds
- Use \`bunx turbo test\` for running tests`;
  }
  static generateClaudeDevelopmentGuidelines() {
    return `## Development Guidelines
- Follow SOLID principles
- Use TypeScript for type safety
- Maintain consistent code formatting with Prettier
- Write meaningful commit messages in English

## Language Requirements

All code, code comments, and technical documentation MUST be written in **English**.

- **Code**: English only
- **Code comments**: English only
- **Technical documentation** (README files, API docs, inline docs, etc.): English only
- **Commit messages**: English only
- **Pull request descriptions**: English only

## Development Workflow

TypeScript
ESLint
test
coverage`;
  }
  static generateClaudeTestingRequirements() {
    return `## Testing Requirements
- Aim for high test coverage
- Do not lower mutation testing thresholds
- Add more tests to kill surviving mutants
- Use the project's testing framework`;
  }
  static generateClaudeProjectStructure(config) {
    const specificStructure = ClaudeConfigGenerator.generateSpecificStructure(config.projectType);
    const architectureSection = ClaudeConfigGenerator.generateArchitectureSection(
      config.projectType
    );
    const baseStructure = `## Project Structure
- \`src/\` - Main source code
- \`tests/\` - Test files
- \`docs/\` - Documentation
- \`.nimata/\` - Project configuration and cache`;
    return ClaudeConfigGenerator.combineStructureSections(
      baseStructure,
      specificStructure,
      architectureSection
    );
  }
  static generateSpecificStructure(projectType) {
    switch (projectType) {
      case 'cli':
        return `- \`src/commands/\` - CLI command implementations
- \`src/utils/\` - Utility functions and helpers`;
      case 'web':
        return `- \`src/components/\` - Reusable UI components
- \`src/pages/\` - Page-level components`;
      case 'library':
        return `- \`src/\` - Library source code
- \`types/\` - TypeScript type definitions`;
      default:
        return '';
    }
  }
  static generateArchitectureSection(projectType) {
    switch (projectType) {
      case 'cli':
        return `

## Architecture

CLI Application with command pattern implementation.

### CLI Development
- argument parsing
- error handling`;
      case 'web':
        return `

## Architecture

Web Application with frontend components.

### Key Components
- src/components/
- src/pages/`;
      case 'library':
        return `

## Architecture

Library Package with public API.

### Key Components
- TypeScript
- src/`;
      default:
        return '';
    }
  }
  static combineStructureSections(baseStructure, specificStructure, architectureSection) {
    let result = baseStructure;
    if (specificStructure) {
      result = `${result}
${specificStructure}`;
    }
    if (architectureSection) {
      result = `${result}${architectureSection}`;
    }
    return result;
  }
  static generateClaudeQualityStandards(config) {
    const coverageThreshold = ClaudeConfigGenerator.getCoverageThreshold(config.qualityLevel);
    return `## Quality Standards

**Quality Level**: ${config.qualityLevel}
- Target coverage: ${coverageThreshold}%
- Minimum ${coverageThreshold}% required for all tests

### ESLint Rules

**CRITICAL RULE**: NEVER disable ESLint rules via inline comments (eslint-disable, eslint-disable-next-line, etc.).

1. \u274C **NEVER USE** \`// eslint-disable-next-line\`
2. \u274C **NEVER USE** \`/* eslint-disable */\`
3. \u2705 **ALWAYS FIX** the underlying code issue

**Rationale**: Disabling rules masks code quality issues and creates technical debt. Code must comply with all ESLint rules without exceptions.

### Mutation Testing Thresholds

**CRITICAL RULE**: NEVER reduce mutation testing thresholds to make tests pass. If mutation score is below threshold:

1. \u2705 **ADD MORE TESTS** to kill surviving mutants
2. \u2705 **IMPROVE TEST QUALITY** to cover edge cases
3. \u274C **NEVER LOWER THRESHOLDS** as a shortcut

**Rationale**: Lowering thresholds masks quality issues and creates technical debt. Always improve test coverage instead.

- All ESLint rules must pass
- Code must be well-documented
- Follow the established patterns in the codebase
- Maintain backward compatibility when possible`;
  }
  static generateClaudeNotes(config) {
    return `## Notes
- Author: ${config.author || 'Your Name'}
- License: ${config.license || 'MIT'}
- Project Type: ${config.projectType}
- Quality Level: ${config.qualityLevel}`;
  }
  static getCoverageThreshold(qualityLevel) {
    switch (qualityLevel) {
      case 'light':
        return COVERAGE_THRESHOLDS.light;
      case 'medium':
        return COVERAGE_THRESHOLDS.medium;
      case 'strict':
        return COVERAGE_THRESHOLDS.strict;
      default:
        return COVERAGE_THRESHOLDS.default;
    }
  }
}
var COVERAGE_THRESHOLDS;
var init_claude_config_generator = __esm(() => {
  COVERAGE_THRESHOLDS = {
    light: 70,
    medium: 85,
    strict: 95,
    default: 80,
  };
});

// ../../packages/core/src/services/generators/core/ai/other-ai-config-generators.ts
class OtherAIConfigGenerators {
  static generateCopilotConfig(config) {
    return {
      path: '.github/copilot-instructions.md',
      type: 'file',
      content: OtherAIConfigGenerators.generateCopilotConfigContent(config),
    };
  }
  static generateAIContextConfig(config) {
    return {
      path: '.ai-context',
      type: 'file',
      content: OtherAIConfigGenerators.generateAIContextContent(config),
    };
  }
  static generateCursorConfig(config) {
    return {
      path: '.cursorrules',
      type: 'file',
      content: OtherAIConfigGenerators.generateCursorRules(config),
    };
  }
  static generateCopilotConfigContent(config) {
    return [
      OtherAIConfigGenerators.generateCopilotHeader(config),
      OtherAIConfigGenerators.generateCopilotProjectContext(config),
      OtherAIConfigGenerators.generateCopilotCodingStandards(),
      OtherAIConfigGenerators.generateCopilotProjectGuidelines(config),
    ].join(`

`);
  }
  static generateCopilotHeader(_config) {
    return `# GitHub Copilot Instructions`;
  }
  static generateCopilotProjectContext(config) {
    const projectTypeNames = {
      basic: 'Basic Application',
      web: 'Web Application',
      cli: 'CLI Application',
      library: 'Library Package',
    };
    return `## Overview

This is a ${projectTypeNames[config.projectType] || config.projectType}.

**Name**: ${config.name}`;
  }
  static generateCopilotCodingStandards() {
    return `## Coding Standards
- Write all code, comments, and documentation in English
- Follow TypeScript best practices
- Use ESLint and Prettier for code formatting
- Maintain consistent naming conventions`;
  }
  static generateCopilotProjectGuidelines(config) {
    const projectSpecificSection = this.getProjectSpecificSection(config.projectType);
    return `## Project Guidelines
- Author: ${config.author || 'Your Name'}
- License: ${config.license || 'MIT'}
- Project Type: ${config.projectType}
- Quality Level: ${config.qualityLevel}

${projectSpecificSection}`;
  }
  static getProjectSpecificSection(projectType) {
    if (projectType === 'cli') {
      return `## CLI Development Guidelines

- Use command pattern for CLI operations
- Handle errors gracefully and provide helpful error messages
- Support both programmatic and interactive usage
- TypeScript
- Browser`;
    } else if (projectType === 'web') {
      return `## Web Development Guidelines

- Build responsive, accessible user interfaces
- Follow modern web standards and best practices
- Optimize for performance and user experience
- TypeScript
- Browser`;
    } else if (projectType === 'library') {
      return `## Library Development Guidelines

- Design clear, well-documented public APIs
- Follow semantic versioning for releases
- Provide comprehensive examples and documentation
- TypeScript
- Browser`;
    }
    return `## Development Guidelines

- Write clean, maintainable code
- Follow established patterns and conventions
- TypeScript
- Browser`;
  }
  static generateAIContextContent(config) {
    return `Project: ${config.name}
Type: ${config.projectType}
Description: ${config.description || 'A modern TypeScript project'}
Author: ${config.author || 'Your Name'}
License: ${config.license || 'MIT'}

This is a TypeScript project with strict ESLint rules and comprehensive testing.`;
  }
  static generateCursorRules(config) {
    return `# Cursor Rules for ${config.name}

## Project Context
This is a ${config.projectType} project: ${config.name}

## Code Standards
- All code and comments must be in English
- Follow strict ESLint rules without disabling them
- Write comprehensive tests
- Use TypeScript for type safety

## Development Practices
- Follow SOLID principles
- Maintain consistent formatting with Prettier
- Write meaningful commit messages in English
- Aim for high code quality and test coverage

## Author: ${config.author || 'Your Name'}
## License: ${config.license || 'MIT'}`;
  }
}

// ../../packages/core/src/services/generators/core/ai-config-generators.ts
class AIConfigGenerators2 {
  static generateAIAssistantConfigs(config) {
    return config.aiAssistants.map((assistant) =>
      AIConfigGenerators2.getAIAssistantConfig(assistant, config)
    );
  }
  static getAIAssistantConfig(assistant, config) {
    switch (assistant) {
      case 'claude-code':
        return ClaudeConfigGenerator.generateClaudeConfig(config);
      case 'github-copilot':
      case 'copilot':
        return OtherAIConfigGenerators.generateCopilotConfig(config);
      case 'ai-context':
        return OtherAIConfigGenerators.generateAIContextConfig(config);
      case 'cursor':
        return OtherAIConfigGenerators.generateCursorConfig(config);
      default:
        throw new Error(`Unknown AI assistant: ${assistant}`);
    }
  }
}
var init_ai_config_generators = __esm(() => {
  init_claude_config_generator();
});

// ../../packages/core/src/services/generators/core/file-operations/file-permissions.ts
function getTempDirPermissions() {
  return TEMP_DIR_PERMISSIONS;
}
function getTempFilePermissions() {
  return TEMP_FILE_PERMISSIONS;
}
function getDefaultDirPermissions() {
  return DEFAULT_DIR_PERMISSIONS2;
}
function getDefaultFilePermissions() {
  return DEFAULT_FILE_PERMISSIONS;
}
function getDefaultExecutablePermissions() {
  return DEFAULT_EXECUTABLE_PERMISSIONS2;
}
function getTempPathPatterns() {
  return [
    `${FORWARD_SLASH}tmp${FORWARD_SLASH}`,
    `${FORWARD_SLASH}var${FORWARD_SLASH}folders${FORWARD_SLASH}`,
    `${FORWARD_SLASH}T${FORWARD_SLASH}`,
  ];
}
var DEFAULT_DIR_PERMISSIONS2 = 493,
  DEFAULT_FILE_PERMISSIONS = 420,
  DEFAULT_EXECUTABLE_PERMISSIONS2 = 493,
  TEMP_DIR_PERMISSIONS = 511,
  TEMP_FILE_PERMISSIONS = 438,
  FORWARD_SLASH_CHAR = 47,
  FORWARD_SLASH;
var init_file_permissions = __esm(() => {
  FORWARD_SLASH = String.fromCharCode(FORWARD_SLASH_CHAR);
});

// ../../packages/core/src/services/generators/validators/directory-path-validator.ts
import { resolve as resolve5, relative as relative2, normalize as normalize2 } from 'path';

class DirectoryPathValidator {
  static validatePath(basePath, targetPath) {
    this.validatePathInputs(basePath, targetPath);
    this.validatePathCharacters(targetPath);
    this.validatePathTraversalPatterns(targetPath);
    this.validateAbsolutePath(targetPath);
    this.validatePathResolution(basePath, targetPath);
    this.validatePathLength(targetPath);
    this.validateSuspiciousCharacters(targetPath);
    this.validatePathNormalization(targetPath);
  }
  static validatePathInputs(basePath, targetPath) {
    if (!targetPath || typeof targetPath !== 'string') {
      throw new Error(`Invalid target path: path must be a non-empty string`);
    }
    if (!basePath || typeof basePath !== 'string') {
      throw new Error(`Invalid base path: base path must be a non-empty string`);
    }
  }
  static validatePathCharacters(targetPath) {
    if (
      targetPath.includes('\x00') ||
      targetPath.includes('\r') ||
      targetPath.includes(`
`)
    ) {
      throw new Error(`Path traversal detected: ${targetPath} contains null bytes or line breaks`);
    }
  }
  static validatePathTraversalPatterns(targetPath) {
    const dangerousPatterns = [
      '../',
      '..\\',
      '~/',
      '~\\',
      '%2e%2e%2f',
      '%2e%2e\\',
      '%2e%2e%5c',
      '..%2f',
      '..%5c',
    ];
    const lowerPath = targetPath.toLowerCase();
    for (const pattern of dangerousPatterns) {
      if (lowerPath.includes(pattern)) {
        throw new Error(
          `Path traversal detected: ${targetPath} contains dangerous pattern: ${pattern}`
        );
      }
    }
  }
  static validateAbsolutePath(targetPath) {
    if (targetPath.startsWith('/') || /^[A-Za-z]:/.test(targetPath)) {
      throw new Error(
        `Absolute path detected: ${targetPath} - paths must be relative to project directory`
      );
    }
  }
  static validatePathResolution(basePath, targetPath) {
    const resolvedBase = resolve5(basePath);
    const resolvedTarget = resolve5(basePath, targetPath);
    const relativePath = relative2(resolvedBase, resolvedTarget);
    if (relativePath.startsWith('..') || relativePath === resolve5(resolvedTarget)) {
      throw new Error(
        `Path traversal detected: ${targetPath} attempts to access files outside the project directory`
      );
    }
  }
  static validatePathLength(targetPath) {
    if (targetPath.length > MAX_PATH_LENGTH) {
      throw new Error(`Path too long: ${targetPath} exceeds maximum allowed length`);
    }
  }
  static validateSuspiciousCharacters(targetPath) {
    const suspiciousChars = /["*:<>?|]/;
    if (suspiciousChars.test(targetPath)) {
      throw new Error(`Invalid characters in path: ${targetPath} contains forbidden characters`);
    }
  }
  static validatePathNormalization(targetPath) {
    const normalizedPath = normalize2(targetPath);
    if (normalizedPath !== targetPath && targetPath.includes('//')) {
      throw new Error(`Path normalization issue detected in: ${targetPath}`);
    }
  }
}
var MAX_PATH_LENGTH = 1024;
var init_directory_path_validator = () => {};

// ../../packages/core/src/services/generators/core/file-operations/path-validation.ts
var exports_path_validation = {};
__export(exports_path_validation, {
  validatePath: () => validatePath,
  isValidTempDirectory: () => isValidTempDirectory,
  isPermissionError: () => isPermissionError,
  createCreationError: () => createCreationError,
});
import { resolve as resolve6 } from 'path';
function validatePath(basePath, targetPath) {
  DirectoryPathValidator.validatePath(basePath, targetPath);
}
function isValidTempDirectory(fullPath) {
  if (!hasValidTempPattern(fullPath)) {
    return false;
  }
  if (hasSuspiciousPatterns(fullPath)) {
    return false;
  }
  return hasValidPathResolution(fullPath);
}
function hasValidTempPattern(fullPath) {
  const tempPathPatterns = getTempPathPatterns();
  return tempPathPatterns.some((pattern) => fullPath.includes(pattern));
}
function hasSuspiciousPatterns(fullPath) {
  const suspiciousPatterns = [
    '..',
    '~/',
    '/etc/',
    '/usr/',
    '/bin/',
    '/sbin/',
    '/var/log/',
    '/var/db/',
    '/Library/',
    '/System/',
  ];
  return suspiciousPatterns.some((pattern) => fullPath.includes(pattern));
}
function hasValidPathResolution(fullPath) {
  try {
    const resolvedPath = resolve6(fullPath);
    const normalizedPath = resolvedPath.replace(/\/+/g, '/');
    return !(normalizedPath.includes('../') || normalizedPath.includes('..\\'));
  } catch {
    return false;
  }
}
function isPermissionError(error) {
  return error.message.includes('EACCES') || error.message.includes('permission denied');
}
function createCreationError(itemType, itemPath, originalError) {
  if (originalError instanceof Error) {
    if (isPermissionError(originalError)) {
      return new Error(
        `Failed to create ${itemType} '${itemPath}': Permission denied. Check file/directory permissions and ensure the target directory exists and is writable. (${originalError.message})`
      );
    }
    return new Error(`Failed to create ${itemType} '${itemPath}': ${originalError.message}`);
  }
  return new Error(`Failed to create ${itemType} '${itemPath}': Unknown error`);
}
var init_path_validation = __esm(() => {
  init_directory_path_validator();
  init_file_permissions();
});

// ../../packages/core/src/services/generators/core/file-operations/file-operations.ts
var exports_file_operations = {};
__export(exports_file_operations, {
  executeWithPermissivePermissions: () => executeWithPermissivePermissions,
  createFileItemWithValidation: () => createFileItemWithValidation,
});
import { promises as fs2 } from 'fs';
import { resolve as resolve7 } from 'path';
async function createFileItemWithValidation(itemPath, fullPath, content, mode) {
  const parentDir = resolve7(fullPath, '..');
  try {
    await createParentDirectory(parentDir);
    await writeFileWithPermissions(fullPath, content, mode);
  } catch (error) {
    await handleFileCreationError(error, {
      itemPath,
      parentDir,
      fullPath,
      content,
    });
  }
}
async function createParentDirectory(parentDir) {
  try {
    const isTempDir = isValidTempDirectory(parentDir);
    const dirMode = isTempDir ? getTempDirPermissions() : getDefaultFilePermissions();
    await fs2.mkdir(parentDir, {
      recursive: true,
      mode: dirMode,
    });
  } catch (error) {
    if (error instanceof Error && isPermissionError(error)) {
      const isTempDir = isValidTempDirectory(parentDir);
      const fallbackMode = isTempDir ? 511 : 493;
      await fs2.mkdir(parentDir, {
        recursive: true,
        mode: fallbackMode,
      });
      return;
    }
    throw error;
  }
}
async function writeFileWithPermissions(fullPath, content, mode) {
  const isTempDir = isValidTempDirectory(fullPath);
  const fileMode = mode || (isTempDir ? getTempFilePermissions() : getDefaultFilePermissions());
  await fs2.writeFile(fullPath, content || '', { mode: fileMode });
}
async function handleFileCreationError(error, context) {
  if (error instanceof Error && isPermissionError(error)) {
    try {
      await retryWithFallbackPermissions(context.parentDir, context.fullPath, context.content);
      return;
    } catch (retryError) {
      throw createCreationError('file', context.itemPath, retryError);
    }
  }
  throw createCreationError('file', context.itemPath, error);
}
async function retryWithFallbackPermissions(parentDir, fullPath, content) {
  try {
    const isTempDir = isValidTempDirectory(fullPath);
    const dirPermissions = isTempDir ? getTempDirPermissions() : 493;
    const filePermissions = isTempDir ? getTempFilePermissions() : 420;
    await fs2.mkdir(parentDir, { recursive: true, mode: dirPermissions });
    await fs2.writeFile(fullPath, content || '', { mode: filePermissions });
  } catch (error) {
    if (error instanceof Error && isPermissionError(error)) {
      const isTempDir = isValidTempDirectory(fullPath);
      const maxDirPermissions = isTempDir ? 511 : 493;
      const maxFilePermissions = isTempDir ? 438 : 420;
      await fs2.mkdir(parentDir, { recursive: true, mode: maxDirPermissions });
      await fs2.writeFile(fullPath, content || '', { mode: maxFilePermissions });
      return;
    }
    throw error;
  }
}
async function executeWithPermissivePermissions(operation, targetPath, callback) {
  if (!isValidTempDirectory(targetPath)) {
    throw new Error(`SECURITY: Permissive permissions not allowed for path: ${targetPath}`);
  }
  try {
    await callback();
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to execute ${operation}: ${error.message}`);
    }
    throw new Error(`Failed to execute ${operation}: Unknown error`);
  }
}
var init_file_operations = __esm(() => {
  init_file_permissions();
  init_path_validation();
});

// ../../packages/core/src/services/generators/core/file-operations/directory-operations.ts
import { promises as fs3 } from 'fs';
import { join as join2, resolve as resolve8, relative as relative3 } from 'path';
async function createDirectories(basePath, directories) {
  if (!directories || directories.length === 0) {
    return;
  }
  for (const dir of directories) {
    validatePath(basePath, dir);
    const fullPath = join2(basePath, dir);
    try {
      await fs3.mkdir(fullPath, { recursive: true, mode: getDefaultDirPermissions() });
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to create directory '${dir}': ${error.message}`);
      }
      throw new Error(`Failed to create directory '${dir}': Unknown error`);
    }
  }
}
async function createNestedDirectories(basePath, nestedStructure) {
  await createDirectories(basePath, nestedStructure);
}
async function createDirectoriesWithGitkeep(basePath, directories) {
  await createDirectories(basePath, directories);
  for (const dir of directories) {
    validatePath(basePath, dir);
    const gitkeepPath = join2(basePath, dir, '.gitkeep');
    try {
      await fs3.writeFile(gitkeepPath, '', { mode: getDefaultFilePermissions() });
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to create .gitkeep file in '${dir}': ${error.message}`);
      }
      throw new Error(`Failed to create .gitkeep file in '${dir}': Unknown error`);
    }
  }
}
async function createDirectoryWithPermissions(dirPath, mode) {
  const basePath = resolve8(dirPath, '..');
  const dirName = relative3(basePath, dirPath);
  validatePath(basePath, dirName);
  try {
    await fs3.mkdir(dirPath, { recursive: true, mode });
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to create directory with permissions: ${error.message}`);
    }
    throw new Error(`Failed to create directory with permissions: Unknown error`);
  }
}
async function createStructureFromDirectoryItems(basePath, structure) {
  for (const item of structure) {
    await createDirectoryItem(basePath, item);
  }
}
async function createDirectoryItem(basePath, item) {
  validatePath(basePath, item.path);
  const fullPath = join2(basePath, item.path);
  if (item.type === 'directory') {
    await createDirectoryItemWithValidation(item.path, fullPath, item.mode);
  } else if (item.type === 'file') {
    const { createFileItemWithValidation: createFileItemWithValidation2 } =
      await Promise.resolve().then(() => (init_file_operations(), exports_file_operations));
    await createFileItemWithValidation2(item.path, fullPath, item.content, item.mode);
  }
}
async function createDirectoryItemWithValidation(itemPath, fullPath, mode) {
  try {
    const isTempDir = isValidTempDirectory(fullPath);
    const dirMode = mode || (isTempDir ? getTempDirPermissions() : getDefaultDirPermissions());
    await fs3.mkdir(fullPath, { recursive: true, mode: dirMode });
  } catch (error) {
    const { isPermissionError: isPermissionError2, createCreationError: createCreationError2 } =
      await Promise.resolve().then(() => (init_path_validation(), exports_path_validation));
    if (error instanceof Error && isPermissionError2(error)) {
      try {
        const isTempDir = isValidTempDirectory(fullPath);
        const fallbackMode = isTempDir ? 511 : 493;
        await fs3.mkdir(fullPath, { recursive: true, mode: fallbackMode });
        return;
      } catch (retryError) {
        throw createCreationError2('directory', itemPath, retryError);
      }
    }
    throw createCreationError2('directory', itemPath, error);
  }
}
var init_directory_operations = __esm(() => {
  init_file_permissions();
  init_path_validation();
});

// ../../packages/core/src/services/generators/core/file-operations/cli-executable.ts
import { promises as fs4 } from 'fs';
import { resolve as resolve9, relative as relative4 } from 'path';
async function createCliExecutable(filePath, content) {
  const basePath = resolve9(filePath, '..');
  const fileName = relative4(basePath, filePath);
  validatePath(basePath, fileName);
  const isTempDir = isValidTempDirectory(filePath);
  try {
    await createCliExecutableParentDirectory(basePath, isTempDir);
    const fileMode = getExecutableFileMode(isTempDir);
    await fs4.writeFile(filePath, content, { mode: fileMode });
  } catch (error) {
    await handleCliExecutableError(error, basePath, filePath, content);
  }
}
async function createCliExecutableParentDirectory(basePath, isTempDir) {
  await fs4.mkdir(basePath, {
    recursive: true,
    mode: isTempDir ? getTempDirPermissions() : getDefaultDirPermissions(),
  });
}
function getExecutableFileMode(isTempDir) {
  return isTempDir ? getTempFilePermissions() : getDefaultExecutablePermissions();
}
async function handleCliExecutableError(error, basePath, filePath, content) {
  if (error instanceof Error && isPermissionError(error)) {
    try {
      await retryCliExecutableCreation(basePath, filePath, content);
      return;
    } catch (retryError) {
      throw createCliExecutableError(retryError);
    }
  }
  throw createCliExecutableError(error);
}
async function retryCliExecutableCreation(basePath, filePath, content) {
  const { executeWithPermissivePermissions: executeWithPermissivePermissions2 } =
    await Promise.resolve().then(() => (init_file_operations(), exports_file_operations));
  await executeWithPermissivePermissions2('retry CLI executable creation', filePath, async () => {
    await fs4.mkdir(basePath, { recursive: true, mode: getTempDirPermissions() });
    await fs4.writeFile(filePath, content, { mode: getTempFilePermissions() });
  });
}
function createCliExecutableError(error) {
  if (error instanceof Error) {
    return new Error(`Failed to create CLI executable: ${error.message}`);
  }
  return new Error('Failed to create CLI executable: Unknown error');
}
var init_cli_executable = __esm(() => {
  init_file_permissions();
  init_path_validation();
});

// ../../packages/core/src/services/generators/core/file-operations/utils.ts
function normalizeDirectoryItems(items) {
  const normalizedItems = items.map((item) => {
    if (item.type === 'directory' && item.mode === undefined) {
      return { ...item, mode: getDefaultDirPermissions() };
    }
    if (item.type === 'file' && item.mode === undefined) {
      const defaultMode = item.executable
        ? getDefaultExecutablePermissions()
        : getDefaultFilePermissions();
      return { ...item, mode: defaultMode };
    }
    return item;
  });
  return normalizedItems.filter(
    (item, index, self2) =>
      index ===
      self2.findIndex((otherItem) => otherItem.path === item.path && otherItem.type === item.type)
  );
}
var init_utils2 = __esm(() => {
  init_file_permissions();
});

// ../../packages/core/src/services/generators/core/file-operations/index.ts
class CoreFileOperations {
  static validatePath(basePath, targetPath) {
    validatePath(basePath, targetPath);
  }
  static isValidTempDirectory(fullPath) {
    return isValidTempDirectory(fullPath);
  }
  static async createDirectories(basePath, directories) {
    await createDirectories(basePath, directories);
  }
  static async createNestedDirectories(basePath, nestedStructure) {
    await createNestedDirectories(basePath, nestedStructure);
  }
  static async createDirectoriesWithGitkeep(basePath, directories) {
    await createDirectoriesWithGitkeep(basePath, directories);
  }
  static async createStructureFromDirectoryItems(basePath, structure) {
    await createStructureFromDirectoryItems(basePath, structure);
  }
  static async createDirectoryWithPermissions(dirPath, mode) {
    await createDirectoryWithPermissions(dirPath, mode);
  }
  static async createCliExecutable(filePath, content) {
    await createCliExecutable(filePath, content);
  }
  static async executeWithPermissivePermissions(operation, targetPath, callback) {
    await executeWithPermissivePermissions(operation, targetPath, callback);
  }
  static normalizeDirectoryItems(items) {
    return normalizeDirectoryItems(items);
  }
}
var init_file_operations2 = __esm(() => {
  init_file_permissions();
  init_path_validation();
  init_directory_operations();
  init_file_operations();
  init_cli_executable();
  init_utils2();
  init_cli_executable();
  init_directory_operations();
  init_file_operations();
  init_path_validation();
  init_utils2();
});

// ../../packages/core/src/services/generators/core/core-file-operations.ts
var init_core_file_operations = __esm(() => {
  init_file_operations2();
  init_file_operations2();
});

// ../../packages/core/src/services/generators/core/eslint-config-generators.ts
class EslintConfigGenerators {
  static generateEslintContent(config) {
    const isStrict = config.qualityLevel === 'strict';
    const isLight = config.qualityLevel === 'light';
    let eslintRules;
    if (isStrict) {
      eslintRules = EslintConfigGenerators.generateStrictRules();
    } else if (isLight) {
      eslintRules = EslintConfigGenerators.generateLightRules();
    } else {
      eslintRules = EslintConfigGenerators.generateDefaultRules();
    }
    const frameworkRules = EslintConfigGenerators.getFrameworkSpecificRules(config);
    return `// @ts-check
import js from '@eslint/js';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  eslint:recommended,
  ...tseslint.configs.recommended,
  {
    ignores: ['dist/**', 'node_modules/**', 'coverage/**'],
  },
  {
    rules: {
${eslintRules}
${frameworkRules}
    }
  }
);`;
  }
  static generateStrictRules() {
    return `      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/prefer-const': 'error',
      'prefer-const': 'error',
      'no-var': 'error',
      '@typescript-eslint/no-non-null-assertion': 'error',
      '@typescript-eslint/prefer-nullish-coalescing': 'error',
      '@typescript-eslint/prefer-optional-chain': 'error',
      'no-console': 'warn',
      'no-debugger': 'error'`;
  }
  static generateLightRules() {
    return `      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/no-explicit-any': 'off',
      'no-console': 'off',
      'no-debugger': 'off'`;
  }
  static generateDefaultRules() {
    return `      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/no-explicit-any': 'warn',
      'prefer-const': 'warn',
      'no-var': 'error',
      'no-console': 'warn'`;
  }
  static getFrameworkSpecificRules(config) {
    let frameworkRules = '';
    switch (config.framework) {
      case 'react':
        frameworkRules = `      // React-specific rules
      'react/jsx-uses-react': 'off',
      'react/react-in-jsx-scope': 'off',
      'react/prop-types': 'off'`;
        break;
      case 'vue':
        frameworkRules = `      // Vue-specific rules
      'vue/multi-word-component-names': 'off'`;
        break;
      case 'express':
        frameworkRules = `      // Express-specific rules
      'no-unused-vars': 'warn'`;
        break;
    }
    if (config.projectType === 'cli') {
      frameworkRules += frameworkRules
        ? `
`
        : '';
      frameworkRules += `      // CLI-specific rules
      'no-process-exit': 'off'`;
    }
    return frameworkRules
      ? `
${frameworkRules}`
      : '';
  }
  static createEslintFile(config) {
    return {
      path: 'eslint.config.mjs',
      type: 'file',
      content: EslintConfigGenerators.generateEslintContent(config),
    };
  }
}

// ../../packages/core/src/services/generators/core/gitignore-generators.ts
class GitignoreGenerators {
  static generateGitignoreContent(config) {
    return [
      GitignoreGenerators.generateDependencyIgnores(),
      GitignoreGenerators.generateBuildIgnores(),
      GitignoreGenerators.generateEnvironmentIgnores(),
      GitignoreGenerators.generateEditorIgnores(),
      GitignoreGenerators.generateOSIgnores(),
      GitignoreGenerators.generateLogIgnores(),
      GitignoreGenerators.generateRuntimeIgnores(),
      GitignoreGenerators.generateCoverageIgnores(),
      GitignoreGenerators.generateCacheIgnores(),
      GitignoreGenerators.generateTempIgnores(),
      GitignoreGenerators.generateProjectSpecificIgnores(config),
    ].join(`
`);
  }
  static generateDependencyIgnores() {
    return `# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
bun.lockb`;
  }
  static generateBuildIgnores() {
    return `# Build outputs
dist/
build/
*.tsbuildinfo
*.d.ts`;
  }
  static generateEnvironmentIgnores() {
    return `# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local`;
  }
  static generateEditorIgnores() {
    return `# Editor directories and files
.vscode/
.idea/
*.swp
*.swo
*~`;
  }
  static generateOSIgnores() {
    return `# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db`;
  }
  static generateLogIgnores() {
    return `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*`;
  }
  static generateRuntimeIgnores() {
    return `# Runtime data
pids
*.pid
*.seed
*.pid.lock`;
  }
  static generateCoverageIgnores() {
    return `# Coverage directory used by tools like istanbul
coverage/
*.lcov`;
  }
  static generateCacheIgnores() {
    return `# nyc test coverage
.nyc_output

# Dependency directories
node_modules/
jspm_packages/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Nimata cache directory
.nimata/cache/`;
  }
  static generateTempIgnores() {
    return `# Temporary folders
tmp/
temp/

# Temporary files
*.tmp`;
  }
  static generateProjectSpecificIgnores(config) {
    const ignores = [];
    if (config.projectType === 'cli') {
      ignores.push(`# CLI specific
bin/
*.cli`);
    }
    if (config.framework === 'react' || config.framework === 'vue') {
      ignores.push(`# Frontend specific
public/build/
dist-ssr/
*.local`);
    }
    ignores.push(`# Testing
/coverage
/reports`);
    return ignores.length > 0
      ? `
# Project specific
${ignores.join(`
`)}`
      : '';
  }
  static createGitignoreFile(config) {
    return {
      path: '.gitignore',
      type: 'file',
      content: GitignoreGenerators.generateGitignoreContent(config),
    };
  }
}

// ../../packages/core/src/services/generators/core/package-json-generators.ts
class PackageJsonGenerators {
  static createPackageJsonContent(metadata) {
    const basePackageJson = PackageJsonGenerators.createBasePackageJson(metadata);
    const projectSpecificConfig = PackageJsonGenerators.createProjectSpecificConfig(
      metadata.projectType,
      metadata.name
    );
    return { ...basePackageJson, ...projectSpecificConfig };
  }
  static createBasePackageJson(metadata) {
    return {
      name: metadata.name || 'new-project',
      version: metadata.version || '1.0.0',
      description: metadata.description || 'A modern TypeScript project',
      main: 'src/index.ts',
      type: 'module',
      scripts: PackageJsonGenerators.createPackageScripts(),
      keywords: metadata.keywords || [],
      author: metadata.author ?? 'Your Name',
      license: metadata.license || 'MIT',
      dependencies: {},
      devDependencies: PackageJsonGenerators.createPackageDevDependencies(),
      engines: PackageJsonGenerators.createPackageEngines(),
    };
  }
  static createProjectSpecificConfig(projectType, projectName) {
    switch (projectType) {
      case 'cli':
        return PackageJsonGenerators.createCliConfig(projectName);
      case 'web':
        return PackageJsonGenerators.createWebConfig();
      case 'library':
        return PackageJsonGenerators.createLibraryConfig();
      default:
        return {};
    }
  }
  static createCliConfig(projectName = 'cli-app') {
    return {
      bin: {
        [projectName]: `./bin/${projectName}`,
      },
      dependencies: {
        commander: '^12.0.0',
        chalk: '^5.0.0',
      },
    };
  }
  static createWebConfig() {
    return {
      dependencies: {
        react: '^18.2.0',
        'react-dom': '^18.2.0',
      },
    };
  }
  static createLibraryConfig() {
    return {
      main: './dist/index.js',
      module: './dist/index.esm.js',
      types: './dist/index.d.ts',
      exports: {
        '.': {
          import: './dist/index.js',
          types: './dist/index.d.ts',
        },
      },
    };
  }
  static createPackageScripts() {
    return {
      dev: `bun --watch src/index.ts`,
      build: `bun build src/index.ts --outdir dist --target node`,
      test: 'bun test',
      lint: 'eslint . --ext .ts,.js',
      'lint:fix': 'eslint . --ext .ts,.js --fix',
      format: 'prettier --write .',
      'format:check': 'prettier --check .',
    };
  }
  static createPackageDevDependencies() {
    return {
      '@types/node': '^20.0.0',
      '@types/bun': '^1.0.0',
      '@typescript-eslint/eslint-plugin': '^8.0.0',
      '@typescript-eslint/parser': '^8.0.0',
      'bun-types': '^1.0.0',
      eslint: '^9.0.0',
      prettier: '^3.0.0',
      typescript: '^5.0.0',
      vitest: '^1.0.0',
    };
  }
  static createPackageEngines() {
    return {
      node: '>=18.0.0',
      bun: '>=1.3.0',
    };
  }
  static createPackageJsonFile(metadata) {
    return {
      path: 'package.json',
      type: 'file',
      content: JSON.stringify(
        PackageJsonGenerators.createPackageJsonContent(metadata),
        null,
        JSON_INDENTATION2
      ),
    };
  }
}
var JSON_INDENTATION2 = 2;

// ../../packages/core/src/services/generators/core/typescript-config-generators.ts
class TypescriptConfigGenerators {
  static generateTsConfigContent(config) {
    const baseConfig = TypescriptConfigGenerators.createBaseTsConfig();
    const compilerOptions = TypescriptConfigGenerators.createTsCompilerOptions();
    const projectSpecificConfig = TypescriptConfigGenerators.applyProjectSpecificConfig(config);
    return JSON.stringify(
      {
        ...baseConfig,
        compilerOptions: {
          ...compilerOptions,
          ...projectSpecificConfig,
        },
      },
      null,
      JSON_INDENTATION3
    );
  }
  static createBaseTsConfig() {
    return {
      compilerOptions: {},
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist', 'build'],
    };
  }
  static createTsCompilerOptions() {
    return {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'bundler',
      allowImportingTsExtensions: true,
      resolveJsonModule: true,
      isolatedModules: true,
      noEmit: true,
      jsx: 'preserve',
      strict: true,
      noUnusedLocals: true,
      noUnusedParameters: true,
      noFallthroughCasesInSwitch: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      declaration: true,
      declarationMap: true,
      sourceMap: true,
      outDir: './dist',
      rootDir: './src',
      removeComments: false,
      esModuleInterop: true,
      allowSyntheticDefaultImports: true,
      experimentalDecorators: true,
      emitDecoratorMetadata: true,
    };
  }
  static applyProjectSpecificConfig(config) {
    const projectConfig = {};
    TypescriptConfigGenerators.applyProjectTypeConfig(projectConfig, config.projectType);
    TypescriptConfigGenerators.applyFrameworkConfig(projectConfig, config.framework);
    TypescriptConfigGenerators.applyQualityConfig(projectConfig, config.qualityLevel);
    return projectConfig;
  }
  static applyProjectTypeConfig(projectConfig, projectType) {
    switch (projectType) {
      case 'cli':
        projectConfig.moduleResolution = 'node';
        projectConfig.esModuleInterop = true;
        projectConfig.allowSyntheticDefaultImports = true;
        break;
      case 'library':
        projectConfig.declaration = true;
        projectConfig.declarationMap = true;
        projectConfig.outDir = './dist';
        break;
      case 'web':
        projectConfig.jsx = 'react-jsx';
        projectConfig.module = 'ESNext';
        projectConfig.moduleResolution = 'bundler';
        break;
    }
  }
  static applyFrameworkConfig(projectConfig, framework) {
    switch (framework) {
      case 'react':
        projectConfig.jsx = 'react-jsx';
        projectConfig.lib = ['DOM', 'DOM.Iterable', 'ES2022'];
        break;
      case 'vue':
        projectConfig.jsx = 'preserve';
        projectConfig.lib = ['DOM', 'DOM.Iterable', 'ES2022'];
        projectConfig.allowJs = true;
        break;
      case 'express':
        projectConfig.moduleResolution = 'node';
        projectConfig.esModuleInterop = true;
        projectConfig.allowSyntheticDefaultImports = true;
        break;
    }
  }
  static applyQualityConfig(projectConfig, qualityLevel) {
    if (qualityLevel === 'strict') {
      Object.assign(projectConfig, {
        strict: true,
        noImplicitAny: true,
        noImplicitReturns: true,
        noImplicitThis: true,
        noUnusedLocals: true,
        noUnusedParameters: true,
        exactOptionalPropertyTypes: true,
      });
    }
  }
  static createTsConfigFile(config) {
    return {
      path: 'tsconfig.json',
      type: 'file',
      content: TypescriptConfigGenerators.generateTsConfigContent(config),
    };
  }
}
var JSON_INDENTATION3 = 2;

// ../../packages/core/src/services/generators/core/configuration-generators.ts
import { promises as fs5 } from 'fs';
import { join as join3 } from 'path';

class ConfigurationGenerators {
  static async generatePackageJson(basePath, metadata) {
    const filePath = join3(basePath, PACKAGE_JSON_FILE);
    CoreFileOperations.validatePath(basePath, PACKAGE_JSON_FILE);
    const packageJson = PackageJsonGenerators.createPackageJsonContent(metadata);
    try {
      await fs5.writeFile(filePath, JSON.stringify(packageJson, null, JSON_INDENTATION4), {
        mode: DEFAULT_FILE_PERMISSIONS2,
      });
    } catch (error) {
      throw ConfigurationGenerators.createFileError('package.json', error);
    }
  }
  static async generateGitignore(basePath, config) {
    const filePath = join3(basePath, GITIGNORE_FILE);
    CoreFileOperations.validatePath(basePath, GITIGNORE_FILE);
    const content = GitignoreGenerators.generateGitignoreContent(config);
    try {
      await fs5.writeFile(filePath, content, { mode: DEFAULT_FILE_PERMISSIONS2 });
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to generate .gitignore: ${error.message}`);
      }
      throw new Error(`Failed to generate .gitignore: Unknown error`);
    }
  }
  static async generateTsConfig(basePath, config) {
    const filePath = join3(basePath, TSCONFIG_JSON_FILE);
    CoreFileOperations.validatePath(basePath, TSCONFIG_JSON_FILE);
    const content = TypescriptConfigGenerators.generateTsConfigContent(config);
    try {
      await fs5.writeFile(filePath, content, { mode: DEFAULT_FILE_PERMISSIONS2 });
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Failed to generate tsconfig.json: ${error.message}`);
      }
      throw new Error(`Failed to generate tsconfig.json: Unknown error`);
    }
  }
  static generateConfigurationFiles(config) {
    const files = [];
    files.push(GitignoreGenerators.createGitignoreFile(config));
    files.push(
      PackageJsonGenerators.createPackageJsonFile({
        name: config.name,
        description: config.description,
        author: config.author,
        license: config.license,
        projectType: config.projectType,
      })
    );
    files.push(TypescriptConfigGenerators.createTsConfigFile(config));
    files.push(EslintConfigGenerators.createEslintFile(config));
    return files;
  }
  static createFileError(fileName, originalError) {
    if (originalError instanceof Error) {
      return new Error(`Failed to generate ${fileName}: ${originalError.message}`);
    }
    return new Error(`Failed to generate ${fileName}: Unknown error`);
  }
}
var GITIGNORE_FILE = '.gitignore',
  PACKAGE_JSON_FILE = 'package.json',
  TSCONFIG_JSON_FILE = 'tsconfig.json',
  DEFAULT_FILE_PERMISSIONS2 = 420,
  JSON_INDENTATION4 = 2;
var init_configuration_generators = __esm(() => {
  init_core_file_operations();
});

// ../../packages/core/src/services/generators/core/entry-points-generator.ts
import { promises as fs6 } from 'fs';
import { join as join4 } from 'path';

class EntryPointsGenerator {
  static async generateMainEntryPoint(basePath, projectName) {
    const filePath = join4(basePath, MAIN_ENTRY_FILE);
    CoreFileOperations.validatePath(basePath, MAIN_ENTRY_FILE);
    const content = EntryPointsGenerator.createMainEntryPointContent(projectName);
    try {
      await EntryPointsGenerator.ensureSrcDirectoryExists(basePath);
      await fs6.writeFile(filePath, content, { mode: DEFAULT_FILE_PERMISSIONS3 });
    } catch (error) {
      throw EntryPointsGenerator.createFileError('main entry point', error);
    }
  }
  static async generateCliEntryPoint(basePath, cliName, config) {
    CoreFileOperations.validatePath(basePath, `bin/${cliName}`);
    const cliLauncher = EntryPointsGenerator.createCLILauncher(config);
    await CoreFileOperations.createCliExecutable(join4(basePath, `bin/${cliName}`), cliLauncher);
  }
  static generateEntryPoints(config) {
    const entryPoints = [
      {
        path: MAIN_ENTRY_FILE,
        type: 'file',
        content: EntryPointsGenerator.createMainEntryPointContent(config.name),
      },
    ];
    if (config.projectType === 'cli') {
      entryPoints.push(EntryPointsGenerator.createCLILauncherItem(config));
    }
    return entryPoints;
  }
  static createMainEntryPointContent(projectName) {
    return `/**
 * ${projectName}
 * Main entry point for ${projectName}
 *
 * @author Your Name
 * @license MIT
 * @version 1.0.0
 */

// Add your main exports here
export const VERSION = '1.0.0';
export const NAME = '${projectName}';

// Add your main functionality here
export function main(): void {
  console.log(\`Welcome to \${projectName} v\${VERSION}\`);
}

// Export any additional modules or functions
export default { main, VERSION, NAME };
`;
  }
  static createCLILauncher(config) {
    const header = EntryPointsGenerator.generateCLIHeader(config);
    const errorHandlers = EntryPointsGenerator.generateCLIErrorHandlers();
    const cliEntryPoint = EntryPointsGenerator.generateCLIEntryPoint(config);
    return `${header}

${errorHandlers}

${cliEntryPoint}`;
  }
  static createCLILauncherItem(config) {
    return {
      path: `bin/${config.name}`,
      type: 'file',
      content: EntryPointsGenerator.createCLILauncher(config),
      executable: true,
      mode: DEFAULT_EXECUTABLE_PERMISSIONS3,
    };
  }
  static generateCLIHeader(config) {
    return `#!/usr/bin/env bun
/**
 * ${config.name} CLI Entry Point
 *
 * Main CLI launcher for ${config.name}
 *
 * @author ${config.author || 'Your Name'}
 * @license ${config.license || 'MIT'}
 * @version 1.0.0
 */`;
  }
  static generateCLIErrorHandlers() {
    return `// Error handling for uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error.message);
  if (process.env.NODE_ENV === 'development') {
    console.error(error.stack);
  }
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});`;
  }
  static generateCLIEntryPoint(_config) {
    return [
      EntryPointsGenerator.generateCLIImports(),
      EntryPointsGenerator.generateCLIEntryPointFunction(),
      EntryPointsGenerator.generateCLIExecution(),
    ].join(`

`);
  }
  static generateCLIImports() {
    return `// Import CLI main function
import { main } from '../src/cli/index.js';`;
  }
  static generateCLIEntryPointFunction() {
    return [
      EntryPointsGenerator.generateCLIEntryPointHeader(),
      EntryPointsGenerator.generateCLIEntryPointTryBlock(),
      EntryPointsGenerator.generateCLIEntryPointCatchBlock(),
      EntryPointsGenerator.generateCLIEntryPointFooter(),
    ].join(`
`);
  }
  static generateCLIEntryPointHeader() {
    return `/**
 * CLI entry point wrapper with enhanced error handling
 */
async function cliEntryPoint(): Promise<void> {
  try {`;
  }
  static generateCLIEntryPointTryBlock() {
    return `    console.log('\uD83D\uDE80 Starting CLI...');

    // Parse command line arguments
    const args = process.argv.slice(2);

    // Show help if no arguments provided
    if (args.length === 0) {
      args.push('--help');
    }

    // Execute CLI main function
    await main(args);`;
  }
  static generateCLIEntryPointCatchBlock() {
    return `  } catch (error) {
    console.error('\u274C CLI Error:');
    if (error instanceof Error) {
      console.error(error.message);
      if (process.env.NODE_ENV === 'development' || process.env.VERBOSE) {
        console.error('\\nStack trace:');
        console.error(error.stack);
      }
    } else {
      console.error('Unknown error occurred');
    }

    // Exit with error code
    process.exit(1);`;
  }
  static generateCLIEntryPointFooter() {
    return `  }
}`;
  }
  static generateCLIExecution() {
    return `// Execute CLI entry point
cliEntryPoint();`;
  }
  static async ensureSrcDirectoryExists(basePath) {
    await fs6.mkdir(join4(basePath, 'src'), { recursive: true, mode: 493 });
  }
  static createFileError(fileName, originalError) {
    if (originalError instanceof Error) {
      return new Error(`Failed to generate ${fileName}: ${originalError.message}`);
    }
    return new Error(`Failed to generate ${fileName}: Unknown error`);
  }
  static generateWebEntryPoints(config) {
    return [
      {
        path: 'src/main.tsx',
        type: 'file',
        content: EntryPointsGenerator.generateWebMainEntry(config),
      },
      {
        path: 'src/vite-env.d.ts',
        type: 'file',
        content: EntryPointsGenerator.generateViteTypes(),
      },
    ];
  }
  static generateLibraryEntryPoints(config) {
    return [
      {
        path: 'src/lib/index.ts',
        type: 'file',
        content: EntryPointsGenerator.generateLibraryMainExport(config),
      },
    ];
  }
  static generateWebMainEntry(config) {
    return `/**
 * ${config.name} Web Application Entry Point
 *
 * Main entry point for the web application
 */

import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './styles/main.css';

// Initialize and render the app
const container = document.getElementById('root');

if (!container) {
  throw new Error('Root container not found');
}

const root = createRoot(container);
root.render(<App />);

// Enable hot module replacement in development
if (import.meta.hot) {
  import.meta.hot.accept();
}
`;
  }
  static generateViteTypes() {
    return `/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string;
  readonly VITE_API_URL: string;
  readonly DEV: boolean;
  readonly PROD: boolean;
  readonly MODE: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
  readonly hot: {
    readonly accept: () => void;
    readonly dispose: (callback: () => void) => void;
    readonly decline: () => void;
    readonly invalidate: () => void;
  } | undefined;
}
`;
  }
  static generateLibraryMainExport(config) {
    const className = config.name
      .split('-')
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join('');
    return `/**
 * ${config.name}
 *
${config.description || 'A modern TypeScript library'}
 *
 * @author ${config.author || 'Your Name'}
 * @license ${config.license || 'MIT'}
 * @version 1.0.0
 */

// Main exports
export { ${className} } from './core.js';
export type { ${className}Config, ${className}Options } from './types/index.js';

// Utility exports
export * from './utils/index.js';

// Default export
export { ${className} as default } from './core.js';
`;
  }
}
var MAIN_ENTRY_FILE = 'src/index.ts',
  DEFAULT_FILE_PERMISSIONS3 = 420,
  DEFAULT_EXECUTABLE_PERMISSIONS3 = 493;
var init_entry_points_generator = __esm(() => {
  init_core_file_operations();
});

// ../../packages/core/src/services/generators/core/modules/shared/common-generators.ts
function generateIndexDocumentation(config) {
  return `/**
 * ${config.name}
 * ${config.description || 'A modern TypeScript library built with Bun'}
 *
 * @author ${config.author || 'Unknown'}
 * @license ${config.license || 'MIT'}
 * @version 1.0.0
 *
 * This package was generated using ${config.template || 'basic'} template
 * with ${config.qualityLevel} quality standards.
 */`;
}
function getBaseInterface(config) {
  return `/**
 * ${config.name} configuration and utilities
 */
export interface ${toPascalCase(config.name)}Config {
  /**
   * Enable debug mode
   */
  debug?: boolean;

  /**
   * Custom options for ${config.name}
   */
  options?: Record<string, unknown>;
}`;
}
function getClassHeader(config, className) {
  return `/**
 * ${config.name} core functionality
 */
export class ${className} {
  private config: ${toPascalCase(config.name)}Config;`;
}
function getClassConstructor(config) {
  return `  constructor(config: ${toPascalCase(config.name)}Config = {}) {
    this.config = {
      debug: false,
      options: {},
      ...config
    };
  }`;
}
function getInitializeMethod(config) {
  return `  /**
   * Initialize ${config.name}
   */
  async initialize(): Promise<void> {
    if (this.config.debug) {
      console.log(\`${config.name} initialized with debug mode\`);
    }
  }`;
}
function getConfigMethod(className) {
  return `  /**
   * Get current configuration
   */
  getConfig(): ${className.replace('Core', '')}Config {
    return { ...this.config };
  }`;
}
function getSetConfigMethod(className) {
  return `  /**
   * Set configuration (replaces entire config)
   */
  setConfig(newConfig: ${className.replace('Core', '')}Config): void {
    this.config = { ...newConfig };
  }`;
}
function getUpdateConfigMethod(className) {
  return `  /**
   * Update configuration
   */
  updateConfig(newConfig: Partial<${className.replace('Core', '')}Config>): void {
    this.config = { ...this.config, ...newConfig };
  }`;
}
function getClassFooter() {
  return `}`;
}
function convertToPascalCase(str) {
  return toPascalCase(str);
}
var init_common_generators = () => {};

// ../../packages/core/src/services/generators/core/modules/cli/cli-classes.ts
function generateConstructor(className, config) {
  return `  constructor(config: Partial<${className}Config> = {}) {
    this.config = {
      name: '${config.name}',
      version: '1.0.0',
      debug: false,
      ...config
    };
  }`;
}
function generateInitializeMethod() {
  return `  /**
   * Initialize CLI application
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    if (this.config.debug) {
      console.log(\`\${this.config.name} CLI v\${this.config.version} initializing...\`);
    }

    // Initialize CLI-specific logic here
    this.initialized = true;

    if (this.config.debug) {
      console.log('CLI initialized successfully');
    }
  }`;
}
function generateExecuteCommandMethod() {
  return `  /**
   * Execute CLI command
   * @param {string} command - Command to execute
   * @param {string} args - Command arguments
   * @returns {string} Command result
   */
  async executeCommand(command: string, args: string[] = []): Promise<CommandResult> {
    if (!this.initialized) {
      throw new Error('CLI must be initialized before executing commands');
    }

    try {
      if (this.config.debug) {
        console.log(\`Executing command: \${command} with args: \${args.join(' ')}\`);
      }

      // Command execution logic here
      return {
        success: true,
        data: \`Command \${command} executed successfully\`,
        exitCode: 0,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        exitCode: 1,
      };
    }
  }`;
}
function generateConfigMethods(className) {
  return `  /**
   * Get current configuration
   */
  getConfig(): ${className}Config {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<${className}Config>): void {
    this.config = { ...this.config, ...updates };
  }`;
}
function generateCLIClass(config) {
  const className = convertToPascalCase(config.name);
  const constructorCode = generateConstructor(className, config);
  const initializeMethod = generateInitializeMethod();
  const executeCommandMethod = generateExecuteCommandMethod();
  const configMethods = generateConfigMethods(className);
  return `export class ${className}CLI {
  private config: ${className}Config;
  private initialized: boolean = false;

${constructorCode}

${initializeMethod}

${executeCommandMethod}

${configMethods}
}`;
}
var init_cli_classes = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/cli/cli-exports.ts
function generateCLIExports(config) {
  const className = convertToPascalCase(config.name);
  return `// Export main class and types
export { ${className}CLI as default, ${className}CLI };
export type { ${className}Config, CLIOptions, CommandResult };

// Convenience function
export async function createCLI(config?: Partial<${className}Config>): Promise<${className}CLI> {
  const cli = new ${className}CLI(config);
  await cli.initialize();
  return cli;
}`;
}
var init_cli_exports = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/cli/cli-interfaces.ts
function generateCLIInterface(config) {
  const className = convertToPascalCase(config.name);
  const configInterface = generateCLIConfigInterface(className);
  const optionsInterface = generateCLIOptionsInterface();
  const resultInterface = generateCommandResultInterface();
  return `${configInterface}

${optionsInterface}

${resultInterface}`;
}
function generateCLIConfigInterface(className) {
  return `export interface ${className}Config {
  /** CLI name */
  name: string;
  /** CLI version */
  version: string;
  /** Debug mode flag */
  debug: boolean;
  /** Default command */
  defaultCommand?: string;
  /** Global options */
  globalOptions?: Record<string, unknown>;
  /** Command-specific options */
  commandOptions?: Record<string, unknown>;
}`;
}
function generateCLIOptionsInterface() {
  return `export interface CLIOptions {
  /** Verbose output */
  verbose?: boolean;
  /** Configuration file path */
  config?: string;
  /** Disable colored output */
  noColor?: boolean;
  /** Custom options */
  [key: string]: unknown;
}`;
}
function generateCommandResultInterface() {
  return `export interface CommandResult {
  /** Success flag */
  success: boolean;
  /** Result data */
  data?: unknown;
  /** Error message */
  error?: string;
  /** Exit code */
  exitCode: number;
}`;
}
var init_cli_interfaces = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/cli/cli-index-generator.ts
function generateCLIIndexFile(config) {
  const documentation = generateIndexDocumentation(config);
  const interfaceCode = generateCLIInterface(config);
  const classCode = generateCLIClass(config);
  const exports = generateCLIExports(config);
  return `${documentation}

${interfaceCode}

${classCode}

${exports}`;
}
var init_cli_index_generator = __esm(() => {
  init_common_generators();
  init_cli_classes();
  init_cli_exports();
  init_cli_interfaces();
});

// ../../packages/core/src/services/generators/core/modules/web/web-classes.ts
var init_web_classes = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/web/web-exports.ts
var init_web_exports = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/web/web-interfaces.ts
var init_web_interfaces = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/web/web-index-generator.ts
function generateWebIndexFile(_config) {
  return `import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { App } from './App.js';
import './styles/main.css';

/**
 * Initialize and render the React application
 */
function initializeApp(): void {
  const container = document.getElementById('root');
  if (!container) {
    throw new Error('Root container not found');
  }

  const root = createRoot(container);
  root.render(
    <StrictMode>
      <App />
    </StrictMode>
  );
}

// Initialize the application
initializeApp();

export { initializeApp };`;
}
var init_web_index_generator = __esm(() => {
  init_common_generators();
  init_web_classes();
  init_web_exports();
  init_web_interfaces();
});

// ../../packages/core/src/services/generators/core/modules/library/library-classes.ts
var init_library_classes = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/library/library-exports.ts
var init_library_exports = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/library/library-interfaces.ts
function generateLibraryInterface(config) {
  const className = convertToPascalCase(config.name);
  const configInterface = generateLibraryConfigInterface(className);
  const optionsInterface = generateLibraryOptionsInterface(className);
  const resultInterface = generateLibraryResultInterface();
  return `${configInterface}

${optionsInterface}

${resultInterface}`;
}
function generateLibraryConfigInterface(className) {
  return `export interface ${className}Config {
  /** Library name */
  name: string;
  /** Library version */
  version: string;
  /** Debug mode flag */
  debug: boolean;
  /** Library options */
  options: Record<string, unknown>;
}`;
}
function generateLibraryOptionsInterface(className) {
  return `export interface ${className}Options {
  /** Processing mode */
  mode?: 'sync' | 'async';
  /** Timeout in milliseconds */
  timeout?: number;
  /** Retry attempts */
  retries?: number;
  /** Custom configuration */
  [key: string]: unknown;
}`;
}
function generateLibraryResultInterface() {
  return `export interface LibraryResult<T = unknown> {
  /** Success flag */
  success: boolean;
  /** Result data */
  data?: T;
  /** Error message */
  error?: string;
  /** Processing time in milliseconds */
  duration?: number;
  /** Timestamp */
  timestamp: string;
}`;
}
var init_library_interfaces = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/library/library-index-generator.ts
function generateLibraryIndexFile(config) {
  return [
    generateLibraryIndexHeader(config),
    generateLibraryIndexInterfaces(config),
    generateLibraryIndexClass(config),
    generateLibraryIndexExports(config),
    generateLibraryIndexUtilities(config),
  ].join(`

`);
}
function generateLibraryIndexHeader(config) {
  return `/**
 * ${config.name} - A modern TypeScript library
 *
 * @author ${config.author || 'Your Name'}
 * @license ${config.license || 'MIT'}
 * @version 1.0.0
 */`;
}
function generateLibraryIndexInterfaces(config) {
  return generateLibraryInterface(config);
}
function generateLibraryIndexClass(config) {
  const className = convertToPascalCase(config.name);
  return `// Main library class
export class ${className} {
  private version: string = '1.0.0';

  /**
   * Get library version
   */
  getVersion(): string {
    return this.version;
  }

  /**
   * Main library functionality
   */
  process(input: unknown): unknown {
    // TODO: Implement main library functionality
    return input;
  }
}`;
}
function generateLibraryIndexExports(config) {
  const className = convertToPascalCase(config.name);
  return `// Export all from internal modules
export * from './types/index.js';
export * from './utils/index.js';
export * from './services/index.js';

// Export main class explicitly
export { ${className} };

// Export types for library
export type { Config, ProcessResult };`;
}
function generateLibraryIndexUtilities(config) {
  const className = convertToPascalCase(config.name);
  return `// Export default and utilities
export default ${className};
export const VERSION = '1.0.0';
export const PACKAGE_NAME = '${config.name}';`;
}
var init_library_index_generator = __esm(() => {
  init_common_generators();
  init_library_classes();
  init_library_exports();
  init_library_interfaces();
});

// ../../packages/core/src/services/generators/core/modules/typescript/typescript-classes.ts
function generateTypeScriptClass(config) {
  const className = convertToPascalCase(config.name);
  return [
    generateTSClassHeader(className, config),
    generateTSConstructor(className, config),
    generateTSInitializeMethod(),
    generateTSValidateMethod(),
    generateTSAdaptMethod(),
    generateTSExecuteServiceMethod(),
    generateTSConfigMethods(className),
  ].join(`
`);
}
function generateTSClassHeader(className, _config) {
  return `export class ${className} {
  private config: ${className}Config;
  private initialized: boolean = false;`;
}
function generateTSConstructor(className, config) {
  return `  constructor(config: Partial<${className}Config> = {}) {
    this.config = {
      name: '${config.name}',
      version: '1.0.0',
      debug: false,
      options: {},
      ...config
    };
  }`;
}
function generateTSInitializeMethod() {
  return `  /**
   * Initialize TypeScript utilities
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    if (this.config.debug) {
      console.log(\`\${this.config.name} v\${this.config.version} initializing...\`);
    }

    // Initialize TypeScript-specific logic here
    this.initialized = true;

    if (this.config.debug) {
      console.log('TypeScript utilities initialized successfully');
    }
  }`;
}
function generateTSValidateMethod() {
  return `  /**
   * Validate input with validator
   * @param {string} validator - Validator to use
   * @param {string} input - Input to validate
   * @returns {string} Validation result
   */
  validate(validator: Validator, input: unknown): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!validator.validate(input)) {
      if (validator.errorMessage) {
        errors.push(validator.errorMessage);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }`;
}
function generateTSAdaptMethod() {
  return `  /**
   * Adapt data with adapter
   * @param {string} adapter - Adapter to use
   * @param {string} input - Input to adapt
   * @returns {string} Adapted data
   */
  adapt<T = unknown, U = unknown>(adapter: Adapter<T, U>, input: T): U {
    return adapter.adapt(input);
  }`;
}
function generateTSExecuteServiceMethod() {
  return `  /**
   * Execute service
   * @param {string} service - Service to execute
   * @param {string} input - Service input
   * @returns {string} Service result
   */
  async executeService<T = unknown, U = unknown>(
    service: Service<T>,
    input: T
  ): Promise<U> {
    return service.execute(input) as Promise<U>;
  }`;
}
function generateTSConfigMethods(className) {
  return `  /**
   * Get current configuration
   */
  getConfig(): ${className}Config {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<${className}Config>): void {
    this.config = { ...this.config, ...updates };
  }
}`;
}
var init_typescript_classes = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/typescript/typescript-exports.ts
function generateTypeScriptExports(config) {
  const className = convertToPascalCase(config.name);
  return `// Export main class and types
export { ${className} as default, ${className} };
export type { ${className}Config, Validator, Adapter, Service };

// Version information
export const VERSION = '1.0.0';
export const PACKAGE_NAME = '${config.name}';

// Re-export utilities
export * from './lib/validators/index.js';
export * from './lib/adapters/index.js';
export * from './lib/services/index.js';
export * from './lib/utils/index.js';`;
}
var init_typescript_exports = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/typescript/typescript-interfaces.ts
function generateTypeScriptInterface(config) {
  const className = convertToPascalCase(config.name);
  const configInterface = generateTypeScriptConfigInterface(className);
  const validatorInterface = generateValidatorInterface();
  const adapterInterface = generateAdapterInterface();
  const serviceInterface = generateServiceInterface();
  return `${configInterface}

${validatorInterface}

${adapterInterface}

${serviceInterface}`;
}
function generateTypeScriptConfigInterface(className) {
  return `export interface ${className}Config {
  /** Library name */
  name: string;
  /** Library version */
  version: string;
  /** Debug mode flag */
  debug: boolean;
  /** Library options */
  options: Record<string, unknown>;
}`;
}
function generateValidatorInterface() {
  return `export interface Validator {
  /** Validation function */
  validate: (input: unknown) => boolean | string;
  /** Error message */
  errorMessage?: string;
}`;
}
function generateAdapterInterface() {
  return `export interface Adapter<T = unknown, U = unknown> {
  /** Adapt input to output */
  adapt: (input: T) => U;
  /** Reverse adaptation */
  reverse?: (output: U) => T;
}`;
}
function generateServiceInterface() {
  return `export interface Service<T = unknown> {
  /** Service name */
  name: string;
  /** Execute service */
  execute: (input: T) => Promise<unknown>;
  /** Service configuration */
  config?: Record<string, unknown>;
}`;
}
var init_typescript_interfaces = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/typescript/typescript-index-generator.ts
function generateTypeScriptIndexFile(config) {
  const documentation = generateIndexDocumentation(config);
  const interfaceCode = generateTypeScriptInterface(config);
  const classCode = generateTypeScriptClass(config);
  const exports = generateTypeScriptExports(config);
  return `${documentation}

${interfaceCode}

${classCode}

${exports}`;
}
var init_typescript_index_generator = __esm(() => {
  init_common_generators();
  init_typescript_classes();
  init_typescript_exports();
  init_typescript_interfaces();
});

// ../../packages/core/src/services/generators/core/modules/framework/framework-classes.ts
function generateFrameworkClass(config) {
  switch (config.projectType) {
    case 'bun-react':
      return generateReactClass(config);
    case 'bun-vue':
      return generateVueClass(config);
    case 'bun-express':
      return generateExpressClass(config);
    default:
      return generateBasicClass(config);
  }
}
function generateReactClass(config) {
  const className = convertToPascalCase(config.name);
  return `export class ${className}Core {
  private config: ${className}Config;

  constructor(config: Partial<${className}Config> = {}) {
    this.config = {
      debug: false,
      props: {},
      ...config
    };
  }

  /**
   * Initialize React component
   */
  async initialize(): Promise<void> {
    if (this.config.debug) {
      console.log('React component initialized');
    }
  }
}`;
}
function generateVueClass(config) {
  const className = convertToPascalCase(config.name);
  return `export class ${className}Core {
  private config: ${className}Config;

  constructor(config: Partial<${className}Config> = {}) {
    this.config = {
      debug: false,
      props: {},
      ...config
    };
  }

  /**
   * Initialize Vue component
   */
  async initialize(): Promise<void> {
    if (this.config.debug) {
      console.log('Vue component initialized');
    }
  }
}`;
}
function generateExpressClass(config) {
  const className = convertToPascalCase(config.name);
  return `export class ${className}Core {
  private config: Record<string, unknown>;

  constructor(config: Record<string, unknown> = {}) {
    this.config = config;
  }

  /**
   * Initialize Express server
   */
  async initialize(): Promise<void> {
    if (this.config.debug) {
      console.log('Express server initialized');
    }
  }
}`;
}
function generateBasicClass(config) {
  const className = `${convertToPascalCase(config.name)}Core`;
  const configType = `${convertToPascalCase(config.name)}Config`;
  return [
    generateBasicClassHeader(className, configType, config),
    generateBasicConstructor(className, configType),
    generateBasicInitializeMethod(config),
    generateBasicConfigMethods(className, configType),
  ].join(`
`);
}
function generateBasicClassHeader(className, configType, config) {
  return `/**
 * ${config.name} core functionality
 */
export class ${className} {
  private config: ${configType};`;
}
function generateBasicConstructor(className, configType) {
  return `  constructor(config: ${configType} = {}) {
    this.config = {
      debug: false,
      options: {},
      ...config
    };
  }`;
}
function generateBasicInitializeMethod(config) {
  return `  /**
   * Initialize ${config.name}
   */
  async initialize(): Promise<void> {
    if (this.config.debug) {
      console.log(\`${config.name} initialized with debug mode\`);
    }
  }`;
}
function generateBasicConfigMethods(className, configType) {
  return `  /**
   * Get current configuration
   */
  getConfig(): ${configType} {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(newConfig: Partial<${configType}>): void {
    this.config = { ...this.config, ...newConfig };
  }
}`;
}
var init_framework_classes = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/framework/framework-exports.ts
function generateFrameworkExports(config) {
  const className = convertToPascalCase(config.name);
  switch (config.projectType) {
    case 'bun-react':
      return `// Export main class and types
export { ${className}Core as default, ${className}Core };
export type { ${className}Props };`;
    case 'bun-vue':
      return `// Export main class and types
export { ${className}Core as default, ${className}Core };
export type { ${className}Config };`;
    case 'bun-express':
      return `// Export main class and types
export { ${className}Core as default, ${className}Core };
export type { ${className}Middleware };`;
    default:
      return `// Export main class and types
export { ${className}Core as default, ${className}Core };`;
  }
}
var init_framework_exports = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/framework/framework-interfaces.ts
function generateFrameworkInterface(config) {
  switch (config.projectType) {
    case 'bun-react':
      return getReactInterface(config);
    case 'bun-vue':
      return getVueInterface(config);
    case 'bun-express':
      return getExpressInterface(config);
    default:
      return getBaseInterface2(config);
  }
}
function getVueInterface(config) {
  return `export interface ${convertToPascalCase(config.name)}Config {
  /** Component name */
  name: string;
  /** Debug mode flag */
  debug: boolean;
  /** Component props */
  props?: Record<string, unknown>;
}`;
}
function getReactInterface(config) {
  return `export interface ${convertToPascalCase(config.name)}Props {
  /**
   * Component children
   */
  children?: React.ReactNode;
}`;
}
function getExpressInterface(config) {
  return `export interface ${convertToPascalCase(config.name)}Middleware {
  /**
   * Express middleware function
   */
  (req: unknown, res: unknown, next: unknown): void;
}`;
}
function getBaseInterface2(config) {
  return `/**
 * ${config.name} configuration and utilities
 */
export interface ${convertToPascalCase(config.name)}Config {
  /**
   * Enable debug mode
   */
  debug?: boolean;

  /**
   * Custom options for ${config.name}
   */
  options?: Record<string, unknown>;
}`;
}
var init_framework_interfaces = __esm(() => {
  init_common_generators();
});

// ../../packages/core/src/services/generators/core/modules/framework/framework-index-generator.ts
function generateFrameworkIndexFile(config) {
  const documentation = generateIndexDocumentation(config);
  const interfaceCode = generateFrameworkInterface(config);
  const classCode = generateFrameworkClass(config);
  const exports = generateFrameworkExports(config);
  return `${documentation}

${interfaceCode}

${classCode}

${exports}`;
}
var init_framework_index_generator = __esm(() => {
  init_common_generators();
  init_framework_classes();
  init_framework_exports();
  init_framework_interfaces();
});

// ../../packages/core/src/services/generators/core/modules/index.ts
var init_modules2 = __esm(() => {
  init_framework_interfaces();
  init_common_generators();
  init_cli_index_generator();
  init_cli_interfaces();
  init_cli_classes();
  init_cli_exports();
  init_web_index_generator();
  init_web_interfaces();
  init_web_classes();
  init_web_exports();
  init_library_index_generator();
  init_library_interfaces();
  init_library_classes();
  init_library_exports();
  init_typescript_index_generator();
  init_typescript_interfaces();
  init_typescript_classes();
  init_typescript_exports();
  init_framework_index_generator();
  init_framework_classes();
  init_framework_exports();
});

// ../../packages/core/src/services/generators/core/index-generator.ts
class IndexGenerator {
  generateIndexFile(config) {
    switch (config.projectType) {
      case 'cli':
        return this.generateCLIIndexFile(config);
      case 'web':
        return this.generateWebIndexFile(config);
      case 'library':
        return this.generateLibraryIndexFile(config);
      case `${BUN_FRAMEWORK_PREFIX}typescript`:
        return this.generateTypeScriptIndexFile(config);
      case `${BUN_FRAMEWORK_PREFIX}react`:
      case `${BUN_FRAMEWORK_PREFIX}vue`:
      case `${BUN_FRAMEWORK_PREFIX}express`:
        return this.generateFrameworkIndexFile(config);
      case 'basic':
      default:
        return this.generateBasicIndexFile(config);
    }
  }
  generateCLIIndexFile(config) {
    return generateCLIIndexFile(config);
  }
  generateWebIndexFile(config) {
    return generateWebIndexFile(config);
  }
  generateLibraryIndexFile(config) {
    return generateLibraryIndexFile(config);
  }
  generateTypeScriptIndexFile(config) {
    return generateTypeScriptIndexFile(config);
  }
  generateFrameworkIndexFile(config) {
    return generateFrameworkIndexFile(config);
  }
  generateBasicIndexFile(config) {
    const exportInterface = this.generateExportInterface(config);
    const exportClass = this.generateExportClass(config);
    const documentation = generateIndexDocumentation(config);
    return `${documentation}

${exportInterface}

${exportClass}`;
  }
  generateExportInterface(config) {
    return getBaseInterface(config);
  }
  generateExportClass(config) {
    const className = `${this.toPascalCase(config.name)}Core`;
    return [
      getClassHeader(config, className),
      getClassConstructor(config),
      getInitializeMethod(config),
      getConfigMethod(className),
      getSetConfigMethod(className),
      getUpdateConfigMethod(className),
      getClassFooter(),
    ].join(`
`);
  }
  toPascalCase(str) {
    return str
      .replace(/(?:^\w)|[A-Z]|(?:\b\w)/g, (word) => {
        return word.toUpperCase();
      })
      .replace(/\s+/g, '')
      .replace(/-/g, '')
      .replace(/_/g, '');
  }
}
var BUN_FRAMEWORK_PREFIX = 'bun-';
var init_index_generator = __esm(() => {
  init_modules2();
});

// ../../packages/core/src/services/generators/core/project-type-generators.ts
class ProjectTypeGenerators {
  static generateBaseStructure() {
    return [
      { path: 'src', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'src/core', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'src/services', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'src/utils', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'src/types', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'src/interfaces', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'tests', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'bin', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'docs', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: '.nimata', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: '.nimata/cache', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: '.nimata/config', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: '.claude', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: '.github', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'tests/unit', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'tests/integration', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'tests/e2e', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'tests/fixtures', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'tests/factories', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'docs/api', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
      { path: 'docs/examples', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
    ];
  }
  static generateProjectTypeStructure(projectType) {
    switch (projectType) {
      case 'cli':
        return [
          { path: 'src/cli', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'tests/unit/cli', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
        ];
      case 'web':
        return [
          { path: 'public', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'src/components', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'src/styles', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'tests/unit/components', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          {
            path: 'tests/integration/components',
            type: 'directory',
            mode: DEFAULT_DIR_PERMISSIONS3,
          },
        ];
      case 'library':
        return [
          { path: 'dist', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'src/lib', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'src/lib/utils', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'src/lib/constants', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'examples', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'examples/basic', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'examples/advanced', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'benchmarks', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
          { path: 'tests/unit/library', type: 'directory', mode: DEFAULT_DIR_PERMISSIONS3 },
        ];
      default:
        return [];
    }
  }
  static generateWebCoreFiles(config) {
    return [
      {
        path: 'index.html',
        type: 'file',
        content: ProjectTypeGenerators.generateWebIndexHtml(config),
      },
      {
        path: 'src/App.tsx',
        type: 'file',
        content: ProjectTypeGenerators.generateWebAppFile(config),
      },
      {
        path: 'public/styles.css',
        type: 'file',
        content: ProjectTypeGenerators.generateWebStylesFile(config),
      },
      {
        path: 'src/styles/main.css',
        type: 'file',
        content: ProjectTypeGenerators.generateWebMainStylesFile(config),
      },
    ];
  }
  static generateLibraryCoreFiles(config) {
    return [
      {
        path: 'src/index.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryMainExport(config),
      },
      {
        path: 'src/lib/index.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryMainExport(config),
      },
      {
        path: 'src/lib/core.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryCoreModule(config),
      },
      {
        path: 'src/types/index.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryTypeExports(config),
      },
      {
        path: 'src/lib/utils/index.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryUtilsExports(config),
      },
      {
        path: 'src/lib/constants/index.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryConstantsExports(config),
      },
      {
        path: 'examples/basic/usage.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryBasicExample(config),
      },
      {
        path: 'examples/advanced/usage.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryAdvancedExample(config),
      },
      {
        path: 'benchmarks/performance.test.ts',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryPerformanceBenchmark(config),
      },
      {
        path: 'docs/api.md',
        type: 'file',
        content: ProjectTypeGenerators.generateLibraryAPIDocumentation(config),
      },
    ];
  }
  static generateGitkeepFiles(config) {
    const directoriesToKeep = [
      'dist',
      'tests/unit',
      'tests/integration',
      'tests/e2e',
      'tests/fixtures',
      'tests/factories',
      'docs/api',
      'docs/examples',
      '.nimata/cache',
      '.nimata/config',
      'bin',
      'docs',
    ];
    if (config.projectType === 'cli') {
      directoriesToKeep.push('src/cli');
    }
    if (config.projectType === 'web') {
      directoriesToKeep.push('public');
      directoriesToKeep.push('src/components');
      directoriesToKeep.push('src/styles');
    }
    if (config.projectType === 'library') {
      directoriesToKeep.push('src/lib');
      directoriesToKeep.push('src/lib/utils');
      directoriesToKeep.push('src/lib/constants');
      directoriesToKeep.push('examples');
      directoriesToKeep.push('examples/basic');
      directoriesToKeep.push('examples/advanced');
      directoriesToKeep.push('benchmarks');
    }
    return directoriesToKeep.map((dir) => ({
      path: `${dir}/.gitkeep`,
      type: 'file',
      content: '',
      mode: 420,
    }));
  }
  static generateWebIndexHtml(config) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${config.name}</title>
    <link rel="stylesheet" href="./src/styles/main.css">
</head>
<body>
    <div id="root"></div>
    <script type="module" src="./src/index.ts"></script>
</body>
</html>`;
  }
  static generateWebAppFile(config) {
    return [
      ProjectTypeGenerators.generateWebAppImports(),
      ProjectTypeGenerators.generateWebAppComponent(config),
      ProjectTypeGenerators.generateWebAppInitialization(),
      ProjectTypeGenerators.generateWebAppExport(),
    ].join(`

`);
  }
  static generateWebAppImports() {
    return `import React from 'react';
import { createRoot } from 'react-dom/client';
import './styles/main.css';`;
  }
  static generateWebAppComponent(config) {
    return `/**
 * Main App component for ${config.name}
 */
function App() {
  return (
    <div className="app">
      <header>
        <h1>Welcome to ${config.name}</h1>
      </header>
      <main>
        <p>Your React application is ready!</p>
      </main>
    </div>
  );
}`;
  }
  static generateWebAppInitialization() {
    return `// Initialize and render the app
const container = document.getElementById('root');
if (container) {
  const root = createRoot(container);
  root.render(<App />);
}`;
  }
  static generateWebAppExport() {
    return `export default App;`;
  }
  static generateWebStylesFile(config) {
    return `/* Public styles for ${config.name} */

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  line-height: 1.6;
  color: #333;
}

.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

header {
  background-color: #f8f9fa;
  padding: 1rem;
  border-bottom: 1px solid #dee2e6;
}

main {
  flex: 1;
  padding: 2rem;
}`;
  }
  static generateWebMainStylesFile(config) {
    return `/* Main styles for ${config.name} */

.app {
  text-align: center;
}

h1 {
  color: #2c3e50;
  margin-bottom: 1rem;
}

p {
  color: #7f8c8d;
  font-size: 1.1rem;
}`;
  }
  static generateLibraryMainExport(config) {
    return `/**
 * ${config.name}
 * ${config.description || 'A modern TypeScript library'}
 */

// Export core functionality
export * from './lib/core.js';

// Export types
export type * from './types/index.js';

// Export utilities
export * from './lib/utils/index.js';

// Export constants
export * from './lib/constants/index.js';
`;
  }
  static generateLibraryCoreModule(config) {
    return `/**
 * Core functionality for ${config.name}
 */

// TODO: Implement core library functionality

export function main(): void {
  console.log('${config.name} - Core functionality placeholder');
}

export const VERSION = '1.0.0';
`;
  }
  static generateLibraryTypeExports(config) {
    return `/**
 * Type definitions for ${config.name}
 */

// Core types
export interface Config {
  debug?: boolean;
  version?: string;
}

// Function signatures
export interface MainFunction {
  (): void;
}

// Error types
export class LibraryError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'LibraryError';
  }
}
`;
  }
  static generateLibraryUtilsExports(config) {
    return `/**
 * Utility functions for ${config.name}
 */

export function createLogger(prefix: string) {
  return (message: string, ...args: any[]) => {
    console.log(\`[\${prefix}] \${message}\`, ...args);
  };
}

export function validateInput(input: unknown): boolean {
  return input !== null && input !== undefined;
}
`;
  }
  static generateLibraryConstantsExports(config) {
    return `/**
 * Constants for ${config.name}
 */

export const LIBRARY_NAME = '${config.name}';
export const DEFAULT_CONFIG = {
  debug: false,
  version: '1.0.0',
};

export const ERROR_MESSAGES = {
  INVALID_INPUT: 'Invalid input provided',
  MISSING_CONFIG: 'Configuration is required',
} as const;
`;
  }
  static generateLibraryBasicExample(config) {
    return `/**
 * Basic usage example for ${config.name}
 */

import { main } from '../../src/index.js';

// Basic usage
main();

console.log('Basic example completed successfully');
`;
  }
  static generateLibraryAdvancedExample(config) {
    return `/**
 * Advanced usage example for ${config.name}
 */

import { main, Config } from '../../src/index.js';

// Advanced usage with configuration
const config: Config = {
  debug: true,
};

console.log('Running advanced example with config:', config);
main();

console.log('Advanced example completed successfully');
`;
  }
  static generateLibraryPerformanceBenchmark(config) {
    return `/**
 * Performance benchmarks for ${config.name}
 */

import { test, describe, expect } from 'bun:test';
import { main } from '../src/index.js';

describe('Performance Benchmarks', () => {
  test('main function performance', () => {
    const startTime = performance.now();

    // Run main function multiple times
    for (let i = 0; i < 1000; i++) {
      main();
    }

    const endTime = performance.now();
    const duration = endTime - startTime;

    // Should complete within reasonable time (adjust as needed)
    expect(duration).toBeLessThan(1000);

    console.log(\`Main function completed 1000 iterations in \${duration.toFixed(2)}ms\`);
  });
});
`;
  }
  static generateLibraryAPIDocumentation(config) {
    return `# API Documentation

## Overview

${config.description || 'A modern TypeScript library'}

## Installation

\`\`\`bash
npm install ${config.name}
\`\`\`

## Usage

\`\`\`typescript
import { main } from '${config.name}';

// TODO: Add usage examples
\`\`\`

## API Reference

### Functions

\`\`\`typescript
// TODO: Add function documentation
\`\`\`

## Contributing

Please see the main README.md for contribution guidelines.

## License

${config.license || 'MIT'}
`;
  }
}
var DEFAULT_DIR_PERMISSIONS3 = 493;

// ../../packages/core/src/services/generators/core/quality/ci-config-generator.ts
class CIConfigGenerator {
  static generateCIConfig(config) {
    return [
      CIConfigGenerator.generateCIHeader(config),
      CIConfigGenerator.generateCIJobs(),
      CIConfigGenerator.generateCIFooter(),
    ].join(`

`);
  }
  static generateCIHeader(_config) {
    return `name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:`;
  }
  static generateCIJobs() {
    return `  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - uses: actions/checkout@v4

    - name: Use Node.js \${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: \${{ matrix.node-version }}

    - name: Install Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: Install dependencies
      run: bun install

    - name: Run tests
      run: bunx turbo test

    - name: Run linting
      run: bunx turbo lint

    - name: Build project
      run: bunx turbo build`;
  }
  static generateCIFooter() {
    return `  code-quality:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - uses: actions/checkout@v4

    - name: Install Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: Install dependencies
      run: bun install

    - name: Run mutation testing
      run: bunx stryker run

    - name: Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info`;
  }
}

// ../../packages/core/src/services/generators/core/quality/eslint-config-generator.ts
class ESLintConfigGenerator2 {
  static generateESLintConfig() {
    return [
      ESLintConfigGenerator2.generateESLintBase(),
      ESLintConfigGenerator2.generateESLintRules(),
    ].join(`

`);
  }
  static generateESLintBase() {
    return JSON.stringify(
      {
        env: {
          browser: true,
          es2022: true,
          node: true,
        },
        extends: [
          'eslint:recommended',
          '@typescript-eslint/recommended',
          '@typescript-eslint/recommended-requiring-type-checking',
        ],
        parser: '@typescript-eslint/parser',
        parserOptions: {
          ecmaVersion: 'latest',
          sourceType: 'module',
          project: './tsconfig.json',
        },
        plugins: ['@typescript-eslint'],
        root: true,
      },
      null,
      JSON_INDENTATION5
    );
  }
  static generateESLintRules() {
    const typeScriptRules = ESLintConfigGenerator2.getTypeScriptRules();
    const generalRules = ESLintConfigGenerator2.getGeneralRules();
    const codeStyleRules = ESLintConfigGenerator2.getCodeStyleRules();
    const bestPracticeRules = ESLintConfigGenerator2.getBestPracticeRules();
    const rules = {
      ...typeScriptRules,
      ...generalRules,
      ...codeStyleRules,
      ...bestPracticeRules,
    };
    return JSON.stringify({ rules }, null, JSON_INDENTATION5);
  }
  static getTypeScriptRules() {
    return {
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/no-explicit-any': 'warn',
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-non-null-assertion': 'warn',
      '@typescript-eslint/prefer-const': 'error',
      '@typescript-eslint/no-var-requires': 'error',
    };
  }
  static getGeneralRules() {
    return {
      'no-console': 'warn',
      'no-debugger': 'error',
      'no-alert': 'error',
      'no-eval': 'error',
      'no-implied-eval': 'error',
      'no-new-func': 'error',
      'no-script-url': 'error',
      'no-void': 'error',
      'no-with': 'error',
    };
  }
  static getCodeStyleRules() {
    return {
      eqeqeq: ['error', 'always'],
      curly: ['error', 'all'],
      'brace-style': ['error', '1tbs'],
      'comma-dangle': ['error', 'always-multiline'],
      quotes: ['error', 'single'],
      semi: ['error', 'always'],
      indent: ['error', DEFAULT_TAB_WIDTH],
      'max-len': ['error', { code: 100, ignoreUrls: true }],
      'no-trailing-spaces': 'error',
      'eol-last': 'error',
    };
  }
  static getBestPracticeRules() {
    return {
      'no-unused-vars': 'off',
      'no-undef': 'off',
      'prefer-const': 'error',
      'no-var': 'error',
      'object-shorthand': 'error',
      'prefer-arrow-callback': 'error',
      'prefer-template': 'error',
      'template-curly-spacing': 'error',
      'arrow-spacing': 'error',
      'generator-star-spacing': 'error',
      'yield-star-spacing': 'error',
    };
  }
}
var JSON_INDENTATION5 = 2,
  DEFAULT_TAB_WIDTH = 2;

// ../../packages/core/src/services/generators/core/quality/typescript-config-generator.ts
class TypeScriptConfigGenerator2 {
  static generateTypeScriptConfig(config) {
    const baseConfig = TypeScriptConfigGenerator2.buildBaseTypeScriptConfig();
    TypeScriptConfigGenerator2.applyProjectTypeSpecificConfig(baseConfig, config.projectType);
    return JSON.stringify(baseConfig, null, JSON_INDENTATION6);
  }
  static buildBaseTypeScriptConfig() {
    return {
      compilerOptions: TypeScriptConfigGenerator2.buildCompilerOptions(),
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist', 'tests'],
    };
  }
  static buildCompilerOptions() {
    return {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'node',
      allowSyntheticDefaultImports: true,
      esModuleInterop: true,
      allowJs: true,
      strict: true,
      noEmit: true,
      declaration: true,
      outDir: './dist',
      rootDir: './src',
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      resolveJsonModule: true,
      isolatedModules: true,
      verbatimModuleSyntax: true,
      noUncheckedIndexedAccess: true,
      exactOptionalPropertyTypes: true,
      noImplicitReturns: true,
      noFallthroughCasesInSwitch: true,
      noImplicitOverride: true,
      noPropertyAccessFromIndexSignature: false,
      allowUnusedLabels: false,
      allowUnreachableCode: false,
    };
  }
  static applyProjectTypeSpecificConfig(config, projectType) {
    if (projectType === 'web') {
      config.compilerOptions.lib = ['ES2022', 'DOM', 'DOM.Iterable'];
      config.compilerOptions.jsx = 'react-jsx';
    } else if (projectType === 'cli') {
      config.compilerOptions.lib = ['ES2022'];
    }
  }
}
var JSON_INDENTATION6 = 2;

// ../../packages/core/src/services/generators/core/quality-config-generators.ts
class QualityConfigGenerators {
  static generateQualityConfigs(config) {
    return [
      QualityConfigGenerators.generateTypeScriptConfigFile(config),
      QualityConfigGenerators.generateESLintConfigFile(),
      QualityConfigGenerators.generatePrettierConfigFile(),
      QualityConfigGenerators.generateStrykerConfigFile(),
      QualityConfigGenerators.generateCIConfigFile(config),
    ];
  }
  static generateTypeScriptConfigFile(config) {
    return {
      path: 'tsconfig.json',
      type: 'file',
      content: TypeScriptConfigGenerator2.generateTypeScriptConfig(config),
    };
  }
  static generateESLintConfigFile() {
    return {
      path: 'eslint.config.mjs',
      type: 'file',
      content: ESLintConfigGenerator2.generateESLintConfig(),
    };
  }
  static generatePrettierConfigFile() {
    return {
      path: '.prettierrc.json',
      type: 'file',
      content: QualityConfigGenerators.generatePrettierConfig(),
    };
  }
  static generateStrykerConfigFile() {
    return {
      path: 'stryker.config.json',
      type: 'file',
      content: QualityConfigGenerators.generateStrykerConfig(),
    };
  }
  static generateCIConfigFile(config) {
    return {
      path: '.github/workflows/ci.yml',
      type: 'file',
      content: CIConfigGenerator.generateCIConfig(config),
    };
  }
  static generatePrettierConfig() {
    const baseConfig = this.getPrettierBaseConfig();
    const overrides = this.getPrettierOverrides();
    return JSON.stringify(
      {
        ...baseConfig,
        overrides,
      },
      null,
      JSON_INDENTATION7
    );
  }
  static getPrettierBaseConfig() {
    return {
      semi: true,
      trailingComma: 'es5',
      singleQuote: true,
      printWidth: 100,
      tabWidth: DEFAULT_TAB_WIDTH2,
      useTabs: false,
      quoteProps: 'as-needed',
      bracketSpacing: true,
      arrowParens: 'always',
      endOfLine: 'lf',
      bracketSameLine: false,
    };
  }
  static getPrettierOverrides() {
    const jsonOverride = this.getJsonPrettierOverride();
    const markdownOverride = this.getMarkdownPrettierOverride();
    return [jsonOverride, markdownOverride];
  }
  static getJsonPrettierOverride() {
    return {
      files: '*.json',
      options: {
        printWidth: 120,
      },
    };
  }
  static getMarkdownPrettierOverride() {
    return {
      files: '*.md',
      options: {
        printWidth: 80,
        proseWrap: 'always',
      },
    };
  }
  static generateStrykerConfig() {
    return JSON.stringify(
      {
        _comment:
          'This config was generated using stryker init. Please take a look at: https://stryker-mutator.io/docs/stryker-js/configuration/ for more information.',
        packageManager: 'bun',
        reporters: ['progress', 'clear-text', 'html'],
        testRunner: 'vitest',
        coverageAnalysis: 'perTest',
        mutate: [
          'src/**/*.js',
          'src/**/*.ts',
          'src/**/*.jsx',
          'src/**/*.tsx',
          '!src/**/*.d.ts',
          '!src/**/*.stories.@(js|jsx|ts|tsx)',
          '!src/**/*.test.@(js|jsx|ts|tsx)',
          '!src/index.ts',
        ],
        thresholds: {
          high: 80,
          low: 60,
          break: null,
        },
      },
      null,
      JSON_INDENTATION7
    );
  }
}
var JSON_INDENTATION7 = 2,
  DEFAULT_TAB_WIDTH2 = 2;
var init_quality_config_generators = () => {};

// ../../packages/core/src/services/generators/basic/basic-structure-generator.ts
class BasicStructureGenerator {
  generate(config) {
    return [
      { path: 'src/utils', type: 'directory', mode: 493 },
      { path: 'src/constants', type: 'directory', mode: 493 },
      {
        path: 'src/utils/helpers.ts',
        type: 'file',
        content: this.generateHelpers(config),
      },
      {
        path: 'src/constants/index.ts',
        type: 'file',
        content: this.generateConstants(config),
      },
    ];
  }
  generateHelpers(_config) {
    return [
      this.getHelpersHeader(),
      this.getFormatDateFunction(),
      this.getDelayFunction(),
      this.getRandomStringFunction(),
      this.getDeepCloneFunction(),
      this.getIsObjectFunction(),
      this.getNestedValueFunction(),
    ].join(`

`);
  }
  getHelpersHeader() {
    return `/**
 * Utility helper functions
 */`;
  }
  getFormatDateFunction() {
    return `/**
 * Format a date as ISO string
 */
export function formatDate(date: Date = new Date()): string {
  return date.toISOString();
}`;
  }
  getDelayFunction() {
    return `/**
 * Delay execution for specified milliseconds
 */
export function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}`;
  }
  getRandomStringFunction() {
    return `/**
 * Generate a random string
 */
export function generateRandomString(length: number = 10): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}`;
  }
  getDeepCloneFunction() {
    return `/**
 * Deep clone an object
 */
export function deepClone<T>(obj: T): T {
  return JSON.parse(JSON.stringify(obj));
}`;
  }
  getIsObjectFunction() {
    return `/**
 * Check if a value is a valid object
 */
export function isObject(value: unknown): value is Record<string, unknown> {
  return value !== null && typeof value === 'object' && !Array.isArray(value);
}`;
  }
  getNestedValueFunction() {
    return `/**
 * Safely access nested object properties
 */
export function getNestedValue<T = any>(
  obj: Record<string, unknown>,
  path: string
): T | undefined {
  return path.split('.').reduce((current, key) => {
    return isObject(current) ? current[key] as T : undefined;
  }, obj) as T | undefined;
}`;
  }
  generateConstants(config) {
    return `/**
 * Application constants
 */

export const APP_NAME = '${config.name}';
export const APP_VERSION = '1.0.0';
export const APP_DESCRIPTION = '${config.description || 'A modern TypeScript library'}';

export const HTTP_STATUS_CODES = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500
} as const;

export const VALIDATION_RULES = {
  MIN_PASSWORD_LENGTH: 8,
  MAX_USERNAME_LENGTH: 50,
  MAX_EMAIL_LENGTH: 100
} as const;

export const API_LIMITS = {
  MAX_REQUEST_SIZE: '10mb',
  RATE_LIMIT_REQUESTS: 100,
  RATE_LIMIT_WINDOW_MS: 15 * 60 * 1000 // 15 minutes
} as const;`;
  }
}

// ../../packages/core/src/services/validators/validation-constants.ts
var BASIC = 'basic',
  WEB = 'web',
  CLI = 'cli',
  LIBRARY = 'library',
  BUN_REACT = 'bun-react',
  BUN_VUE = 'bun-vue',
  BUN_EXPRESS = 'bun-express',
  BUN_TYPESCRIPT = 'bun-typescript',
  LIGHT = 'light',
  MEDIUM = 'medium',
  STRICT = 'strict',
  HIGH = 'high',
  CLAUDE_CODE = 'claude-code',
  COPILOT = 'copilot',
  GITHUB_COPILOT = 'github-copilot',
  AI_CONTEXT = 'ai-context',
  CURSOR = 'cursor',
  MIT = 'MIT',
  APACHE_2_0 = 'Apache-2.0',
  GPL_3_0 = 'GPL-3.0',
  BSD_3_CLAUSE = 'BSD-3-Clause',
  ISC = 'ISC',
  MAX_PROJECT_NAME_LENGTH = 214,
  MAX_DESCRIPTION_LENGTH = 1000,
  MAX_AUTHOR_LENGTH = 100,
  MAX_AI_ASSISTANTS = 5,
  DEFAULT_DEV_PORT = 3000,
  DIRECTORY_PERMISSIONS = 493,
  FILE_PERMISSIONS2 = 420,
  VALID_PROJECT_TYPES,
  VALID_QUALITY_LEVELS,
  VALID_AI_ASSISTANTS2,
  COMMON_LICENSES,
  PROJECT_NAME_PATTERN,
  RESERVED_PROJECT_NAMES,
  DANGEROUS_NAME_PATTERNS,
  DANGEROUS_AUTHOR_PATTERNS,
  XSS_PATTERNS,
  DANGEROUS_DIRECTORIES,
  ERROR_MESSAGES;
var init_validation_constants = __esm(() => {
  VALID_PROJECT_TYPES = [BASIC, WEB, CLI, LIBRARY, BUN_REACT, BUN_VUE, BUN_EXPRESS, BUN_TYPESCRIPT];
  VALID_QUALITY_LEVELS = [LIGHT, MEDIUM, STRICT, HIGH];
  VALID_AI_ASSISTANTS2 = [CLAUDE_CODE, COPILOT, GITHUB_COPILOT, AI_CONTEXT, CURSOR];
  COMMON_LICENSES = [MIT, APACHE_2_0, GPL_3_0, BSD_3_CLAUSE, ISC];
  PROJECT_NAME_PATTERN = /^[\d_a-z-]+$/;
  RESERVED_PROJECT_NAMES = [
    'node',
    'npm',
    'bun',
    'deno',
    'yarn',
    'pnpm',
    'test',
    'spec',
    'mock',
    'stub',
    'fixture',
    'lib',
    'bin',
    'src',
    'dist',
    'build',
    'out',
    'package',
    'module',
    'index',
    'main',
    'app',
  ];
  DANGEROUS_NAME_PATTERNS = [
    /^\.+\//,
    /["*:<>?\\|]/,
    /^(con|prn|aux|nul|com[1-9]|lpt[1-9])$/i,
    /^[A-Za-z]:/,
    /\s/,
  ];
  DANGEROUS_AUTHOR_PATTERNS = [/<\/?script>/i, /javascript:/i, /on\w+\s*=/i];
  XSS_PATTERNS = [/<script/i, /javascript:/i, /on\w+\s*=/i, /data:text\/html/i];
  DANGEROUS_DIRECTORIES = ['etc', 'bin', 'usr', 'var', 'sys', 'proc', 'dev'];
  ERROR_MESSAGES = {
    PROJECT_NAME_REQUIRED: 'Project name is required',
    PROJECT_NAME_FORMAT:
      'Project name should contain only lowercase letters, numbers, hyphens, and underscores',
    INVALID_PROJECT_TYPE: (type) =>
      `Invalid project type: ${type}. Valid types: ${VALID_PROJECT_TYPES.join(', ')}`,
    INVALID_QUALITY_LEVEL: (level) =>
      `Invalid quality level: ${level}. Valid levels: ${VALID_QUALITY_LEVELS.join(', ')}`,
    INVALID_AI_ASSISTANT: (assistant) =>
      `Invalid AI assistant: ${assistant}. Valid assistants: ${VALID_AI_ASSISTANTS2.join(', ')}`,
    INVALID_LICENSE: (license) =>
      `License '${license}' is not a common open source license. Consider using: ${COMMON_LICENSES.join(', ')}`,
    TEMPLATE_INCOMPATIBLE: (template, projectType) =>
      `Template '${template}' may not be compatible with project type '${projectType}'`,
  };
});

// ../../packages/core/src/services/generators/cli/cli-command-generators.ts
class CLICommandGenerators {
  generateCommandsIndex(_config) {
    return [
      this.generateCommandsHeader(),
      this.generateCommandExports(),
      this.generateCommandRegistry(),
      this.generateCommandHelpers(),
    ].join(`
`);
  }
  generateCommandsHeader() {
    return `/**
 * Commands Index
 *
 * Exports all available CLI commands
 */`;
  }
  generateCommandExports() {
    return `export { default as helloCommand } from './hello-command.js';
export { default as helpCommand } from './help-command.js';
export { default as versionCommand } from './version-command.js';`;
  }
  generateCommandRegistry() {
    return `/**
 * Command registry for dynamic command loading
 */
export const commandRegistry = new Map([
  ['hello', () => import('./hello-command.js')],
  ['help', () => import('./help-command.js')],
  ['version', () => import('./version-command.js')],
]);`;
  }
  generateCommandHelpers() {
    return [
      this.generateGetAvailableCommands(),
      this.generateHasCommandFunction(),
      this.generateLoadCommandFunction(),
    ].join(`
`);
  }
  generateGetAvailableCommands() {
    return `/**
 * Get all available commands
   * @returns {string} Array of command information
 */
export const getAvailableCommands = () => [
  { name: 'hello', description: 'Say hello to the world' },
  { name: 'help', description: 'Show help information' },
  { name: 'version', description: 'Show version information' },
];`;
  }
  generateHasCommandFunction() {
    return `/**
 * Check if a command exists
   * @param {string} name - Command name
   * @returns {boolean} if command exists
 */
export const hasCommand = (name: string): boolean => {
  return commandRegistry.has(name);
};`;
  }
  generateLoadCommandFunction() {
    return `/**
 * Load a command dynamically
   * @param {string} name - Command name
   * @returns {string} Command module
 */
export const loadCommand = async (name: string) => {
  const loader = commandRegistry.get(name);
  if (!loader) {
    throw new Error(\`Command '\${name}' not found\`);
  }

  return loader();
};`;
  }
  generateHelloCommand(_config) {
    return [
      this.generateHelloCommandHeader(),
      this.generateHelloCommandImports(),
      this.generateHelloCommandInterface(),
      this.generateHelloCommandExecute(),
      this.generateHelloCommandConfigure(),
      this.generateHelloCommandExport(),
    ].join(`
`);
  }
  generateHelloCommandHeader() {
    return `/**
 * Hello Command
 *
 * Simple greeting command implementation
 */`;
  }
  generateHelloCommandImports() {
    return `import type { Command } from 'commander';
import type { Logger } from '../utils/logger.js';`;
  }
  generateHelloCommandInterface() {
    return `interface HelloOptions {
  caps?: boolean;
  fancy?: boolean;
}`;
  }
  generateHelloCommandExecute() {
    return `/**
 * Execute hello command
   * @param {string} name - Name to greet
   * @param {string} options - Command options
   * @param {string} logger - Logger instance
 */
function execute(name: string, options: HelloOptions, logger: Logger): void {
  let greeting = 'Hello';

  if (options.fancy) {
    greeting = '\uD83D\uDC4B Greetings';
  }

  let message = \`\${greeting}, \${name || 'World'}!\`;

  if (options.caps) {
    message = message.toUpperCase();
  }

  if (options.fancy) {
    message = \`\u2728 \${message} \u2728\`;
  }

  logger.info(message);
}`;
  }
  generateHelloCommandConfigure() {
    return `/**
 * Configure hello command
   * @param {string} program - Commander program instance
   * @param {string} logger - Logger instance
   * @returns {string} Configured command
 */
function configure(program: Command, logger: Logger): Command {
  return program
    .command('hello')
    .description('Say hello to someone')
    .argument('[name]', 'Name to greet')
    .option('-c, --caps', 'Display message in uppercase')
    .option('-f, --fancy', 'Display fancy greeting with emojis')
    .action((name, options) => execute(name, options, logger));
}`;
  }
  generateHelloCommandExport() {
    return `/**
 * Hello command module
 */
export default {
  execute,
  configure,
};`;
  }
}

// ../../packages/core/src/services/generators/cli/cli-index-generators.ts
class CLIIndexGenerators {
  generateCLIIndex(config) {
    const { name } = config;
    const className = toPascalCase(name);
    return `${this.generateCLIIndexHeader()}
${this.generateCLIIndexImports()}
${this.generateCLIIndexClass(className, name, config)}
${this.generateCLIIndexMain(className)}
${this.generateCLIIndexErrorHandlers()}
${this.generateCLIIndexEntry(className)}`;
  }
  generateCLIIndexHeader() {
    return `/**
 * ${this.generateCLIIndexOptions()}
 *
 * ${this.generateCLIIndexParseOptions()}
 * ${this.generateCLIIndexMain('className')}
 */`;
  }
  generateCLIIndexOptions() {
    return 'CLI Application Entry Point';
  }
  generateCLIIndexImports() {
    return `import { Command } from 'commander';
import { Logger } from './utils/logger.js';
import { helloCommand } from './commands/index.js';
import { appConfig } from './config/app-config.js';`;
  }
  generateCLIIndexClass(className, name, _config) {
    return [
      this.generateClassDeclaration(className, name),
      this.generateClassConstructor(name),
      this.generateClassMethods(className, name),
    ].join(`
`);
  }
  generateClassDeclaration(className, _name) {
    return `/**
 * ${className} CLI Application
 */
export class ${className}CLI {
  private readonly program: Command;
  private readonly logger: Logger;`;
  }
  generateClassConstructor(name) {
    return `  constructor() {
    this.program = new Command();
    this.logger = new Logger({ prefix: '${name}' });

    this.setupProgram();
    this.setupCommands();
  }`;
  }
  generateClassMethods(_className, _name) {
    return [
      this.generateSetupProgramMethod(),
      this.generateSetupCommandsMethod(),
      this.generateRunMethod(),
      this.generateParseGlobalOptionsMethod(),
      this.generateHandleErrorMethod(),
      this.generateClassClosing(),
    ].join(`
`);
  }
  generateSetupProgramMethod() {
    return `  /**
   * Setup the main program
   */
  private setupProgram(): void {
    this.program
      .name(appConfig.name)
      .description(appConfig.description)
      .version(appConfig.version)
      .option('-v, --verbose', 'Enable verbose logging')
      .option('-q, --quiet', 'Suppress non-error output')
      .option('--no-color', 'Disable colored output')
      .option('--log-level <level>', 'Set log level', 'info')
      .option('--config <path>', 'Path to configuration file');
  }`;
  }
  generateSetupCommandsMethod() {
    return `  /**
   * Setup available commands
   */
  private setupCommands(): void {
    // Register commands
    helloCommand.configure(this.program, this.logger);

    // TODO: Add more commands as they are implemented
    // buildCommand.configure(this.program, this.logger);
    // deployCommand.configure(this.program, this.logger);
  }`;
  }
  generateRunMethod() {
    return `  /**
   * Run the CLI application
   * @param {string} argv - Command line arguments
   */
  async run(argv: string[]): Promise<void> {
    try {
      // Parse global options
      this.parseGlobalOptions();

      // Execute command
      await this.program.parseAsync(argv);
    } catch (error) {
      this.handleError(error);
      process.exit(1);
    }
  }`;
  }
  generateParseGlobalOptionsMethod() {
    return `  /**
   * Parse global options and configure logger
   */
  private parseGlobalOptions(): void {
    const options = this.program.opts();

    // Configure logging
    if (options.quiet) {
      this.logger.setLevel('error');
    } else if (options.verbose) {
      this.logger.setLevel('debug');
    } else if (options.logLevel) {
      this.logger.setLevel(options.logLevel);
    }

    // Configure colors
    this.logger.setColorEnabled(options.color !== false);

    // Load configuration if specified
    if (options.config) {
      // TODO: Implement configuration loading
      this.logger.debug(\`Loading configuration from: \${options.config}\`);
    }
  }`;
  }
  generateHandleErrorMethod() {
    return [
      this.generateHandleErrorMethodStart(),
      this.generateHandleCommanderError(),
      this.generateHandleValidationError(),
      this.generateHandleUnexpectedError(),
      this.generateHandleErrorMethodEnd(),
    ].join(`
`);
  }
  generateHandleErrorMethodStart() {
    return `  /**
   * Handle application errors
   * @param {string} error - Error to handle
   */
  private handleError(error: Error): void {`;
  }
  generateHandleCommanderError() {
    return `    if (error.name === 'CommanderError') {
      // Handle commander.js specific errors
      if (error.code === 'commander.help') {
        // Help was requested, exit gracefully
        process.exit(0);
      }

      this.logger.error(error.message);
      process.exit(1);
    }`;
  }
  generateHandleValidationError() {
    return `    if (error.name === 'ValidationError') {
      this.logger.error(\`Validation error: \${error.message}\`);
      if (error.suggestions) {
        this.logger.info('Suggestions:');
        error.suggestions.forEach((suggestion: string) => {
          this.logger.info(\`  - \${suggestion}\`);
        });
      }
      process.exit(1);
    }`;
  }
  generateHandleUnexpectedError() {
    return `    // Handle unexpected errors
    this.logger.error('An unexpected error occurred:', error.message);
    this.logger.debug(error.stack);

    process.exit(1);`;
  }
  generateHandleErrorMethodEnd() {
    return `  }`;
  }
  generateClassClosing() {
    return `}`;
  }
  generateCLIIndexParseOptions() {
    return 'Main CLI application class with command handling';
  }
  generateCLIIndexMain(className) {
    return `/**
 * Main function - entry point for the CLI application
 */
async function main(): Promise<void> {
  const cli = new ${className}CLI();
  await cli.run(process.argv);
}

// Run the application if this file is executed directly
if (import.meta.url === \`file://\${process.argv[1]}\`) {
  main().catch((error) => {
    process.stderr.write('Failed to start CLI application: ' + String(error) + '\\n');
    process.exit(1);
  });
}`;
  }
  generateCLIIndexErrorHandlers() {
    return `/**
 * Global error handlers
 */

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  process.stderr.write('Uncaught Exception: ' + String(error) + '\\n');
  process.exit(1);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  process.stderr.write('Unhandled Rejection at: ' + String(promise) + ', reason: ' + String(reason) + '\\n');
  process.exit(1);
});

// Handle SIGINT (Ctrl+C)
process.on('SIGINT', () => {
  process.stdout.write('\\nReceived SIGINT. Gracefully shutting down...\\n');
  process.exit(0);
});

// Handle SIGTERM
process.on('SIGTERM', () => {
  process.stdout.write('\\nReceived SIGTERM. Gracefully shutting down...\\n');
  process.exit(0);
});`;
  }
  generateCLIIndexEntry(className) {
    return `/**
 * Export the CLI class for programmatic usage
 */
export { ${className}CLI as CLI };
export default CLI;`;
  }
}
var init_cli_index_generators = () => {};

// ../../packages/core/src/services/generators/cli/modules/basic-cli-config-generators.ts
function generateCLIConfigHeader() {
  return `/**
 * CLI Configuration
 *
 * Default configuration for CLI application
 */`;
}
function generateCLIConfigImports() {
  return `import type { ConfigFileOptions, CommandConfig, PluginConfig, HookConfig } from './types.js';
import type { Logger } from 'winston';
import { createLogger } from 'winston';
import { Console } from 'winston/transports';`;
}
function generateCLIConfigBody(config) {
  return [generateAppConfig(config), generateLoggingConfig()].join(`

`);
}
function generateAppConfig(config) {
  return `/**
 * Default application configuration
 */
const appConfig = {
  name: '${config.name}',
  version: '${config.version}',
  description: '${config.description}',
  author: '${config.author}',
  license: '${config.license}',
  homepage: '${config.homepage || ''}',
  repository: '${config.repository || ''}',
  bugs: '${config.bugs || ''}',
  keywords: ${JSON.stringify(config.keywords || [])},
  engines: {
    node: '>=18.0.0',
    bun: '>=1.0.0',
  },
};`;
}
function generateLoggingConfig() {
  return `/**
 * Default logging configuration
 */
const loggingConfig = {
  level: process.env.LOG_LEVEL || 'info',
  format: process.env.NODE_ENV === 'production' ? 'json' : 'simple',
  output: process.env.LOG_OUTPUT || 'console',
  file: process.env.LOG_FILE ? {
    path: process.env.LOG_FILE,
    maxSize: process.env.LOG_MAX_SIZE || '10m',
    maxFiles: parseInt(process.env.LOG_MAX_FILES || '5', 10),
  } : undefined,
};`;
}

// ../../packages/core/src/services/generators/cli/modules/command-config-generators.ts
function generateCommandConfigs(config) {
  return `/**
 * Command configurations
 */
const commands: CommandConfig[] = [
  ${generateHelloCommandConfig(config)},
  ${generateBuildCommandConfig(config)},
  ${generateDeployCommandConfig(config)},
];`;
}
function generateHelloCommandConfig(config) {
  return `{
    name: 'hello',
    description: 'Say hello to the world',
    handler: 'handleHelloCommand',
    options: [
      {
        name: 'name',
        description: 'Name to greet',
        type: 'string',
        default: 'World',
      },
      {
        name: 'loud',
        description: 'Make the greeting loud',
        type: 'boolean',
        default: false,
      },
    ],
    examples: [
      '${config.name} hello',
      '${config.name} hello --name Alice',
      '${config.name} hello --name Alice --loud',
    ],
  }`;
}
function generateBuildCommandConfig(config) {
  return `{
    name: 'build',
    description: 'Build the project',
    options: {
      ${generateBuildCommandOptions()},
    },
    examples: ${generateBuildCommandExamples(config)},
  }`;
}
function generateBuildCommandOptions() {
  return [
    `watch: {
        description: 'Enable watch mode',
        type: 'boolean',
        default: false,
      },
      minify: {
        description: 'Minify output',
        type: 'boolean',
        default: true,
      },
      sourcemap: {
        description: 'Generate source maps',
        type: 'boolean',
        default: false,
      },
      target: {
        description: 'Target environment',
        type: 'string',
        default: 'node',
        choices: ['node', 'browser', 'bun'],
      },
      output: {
        description: 'Output directory',
        type: 'string',
        default: './dist',
      },`,
  ].join(`
      `);
}
function generateBuildCommandExamples(config) {
  return `[
      '${config.name} build',
      '${config.name} build --watch',
      '${config.name} build --minify false --sourcemap',
    ]`;
}
function generateDeployCommandConfig(config) {
  return `{
    name: 'deploy',
    description: 'Deploy the project',
    options: {
      environment: {
        description: 'Deployment environment',
        type: 'string',
        default: 'production',
        choices: ['development', 'staging', 'production'],
      },
      dryRun: {
        description: 'Perform a dry run without making changes',
        type: 'boolean',
        default: false,
      },
      force: {
        description: 'Force deployment even if checks fail',
        type: 'boolean',
        default: false,
      },
    },
    examples: [
      '${config.name} deploy',
      '${config.name} deploy --environment staging',
      '${config.name} deploy --dry-run',
    ],
  }`;
}

// ../../packages/core/src/services/generators/cli/modules/config-helper-generators.ts
function generateConfigHelpers() {
  return [generateGetConfigFunction(), generateValidateConfigFunction()].join(`

`);
}
function generateGetConfigFunction() {
  return `/**
 * Get configuration based on environment
   * @param {string} env - Environment name
   * @returns {boolean}ied environment
 */
export const getConfig = (env: string = 'development'): ConfigFileOptions => {
  switch (env) {
    case 'production':
      return prodConfig;
    case 'test':
      return testConfig;
    default:
      return devConfig;
  }
};`;
}
function generateValidateConfigFunction() {
  return `/**
 * Validate configuration
   * @param {string} config - Configuration to validate
 * @throws Error if configuration is invalid
 */
export const validateConfig = (config: ConfigFileOptions): void => {
  if (!config.commands || config.commands.length === 0) {
    throw new Error('Configuration must include at least one command');
  }

  if (config.commands) {
    const commandNames = config.commands.map(cmd => cmd.name);
    const duplicates = commandNames.filter((name, index) => commandNames.indexOf(name) !== index);

    if (duplicates.length > 0) {
      throw new Error(\`Duplicate command names: \${duplicates.join(', ')}\`);
    }
  }
};`;
}
function generateConfigDefaultExport() {
  return `/**
 * Default configuration export
 */
export default devConfig;`;
}

// ../../packages/core/src/services/generators/cli/modules/environment-config-generators.ts
function generateEnvironmentConfigs(config) {
  return [generateDevelopmentConfig(), generateProductionConfig(), generateTestConfig(config)]
    .join(`

`);
}
function generateDevelopmentConfig() {
  return `/**
 * Development configuration
 */
export const devConfig: ConfigFileOptions = {
  app: appConfig,
  commands,
  plugins,
  hooks,
  logging: {
    ...loggingConfig,
    level: 'debug',
    colorEnabled: true,
    timestamp: true,
    output: 'console',
  },
};`;
}
function generateProductionConfig() {
  return `/**
 * Production configuration
 */
export const prodConfig: ConfigFileOptions = {
  app: appConfig,
  commands,
  plugins,
  hooks,
  logging: {
    ...loggingConfig,
    level: 'info',
    colorEnabled: false,
    timestamp: true,
    output: 'file',
    file: {
      path: './logs/app.log',
      maxSize: '10m',
      maxFiles: 5,
    },
  },
};`;
}
function generateTestConfig(config) {
  return `/**
 * Test configuration
 */
export const testConfig: ConfigFileOptions = {
  app: {
    ...appConfig,
    name: '${config.name}-test',
  },
  commands,
  plugins,
  hooks,
  logging: {
    ...loggingConfig,
    level: 'debug',
    colorEnabled: false,
    timestamp: false,
    output: 'memory', // Store logs in memory for testing
  },
};`;
}

// ../../packages/core/src/services/generators/cli/modules/plugin-hook-generators.ts
function generatePluginConfigs() {
  return `/**
 * Plugin configurations
 */
const plugins: PluginConfig[] = [
  ${generateLoggerPluginConfig()},
];

/**
 * Hook configurations
 */
const hooks: HookConfig[] = [
  ${generateHooksConfig()},
];`;
}
function generateLoggerPluginConfig() {
  return `{
    name: 'logger',
    enabled: true,
    options: {
      level: loggingConfig.level,
      format: loggingConfig.format,
      output: loggingConfig.output,
    },
  }`;
}
function generateHooksConfig() {
  return `{
    name: 'logging-hook',
    command: 'build',
    event: 'before',
    handler: 'logBuildStart',
  },
  {
    name: 'logging-hook',
    command: 'build',
    event: 'after',
    handler: 'logBuildComplete',
  }`;
}

// ../../packages/core/src/services/generators/cli/cli-config-generator.ts
class CLIConfigGenerator {
  generateCLIConfig(config) {
    return [
      generateCLIConfigHeader(),
      generateCLIConfigImports(),
      generateCLIConfigBody(config),
      generateCommandConfigs(config),
      generatePluginConfigs(),
      generateEnvironmentConfigs(config),
      generateConfigHelpers(),
      generateConfigDefaultExport(),
    ].join(`
`);
  }
}
var init_cli_config_generator = () => {};

// ../../packages/core/src/services/generators/cli/modules/basic-cli-types.ts
function generateCommandTypes() {
  return `/**
 * Available CLI commands
 */
export type CLICommand = 'hello' | 'build' | 'deploy' | 'test' | 'lint' | 'clean';

/**
 * Command result interface
 */
export interface CommandResult {
  success: boolean;
  message?: string;
  data?: unknown;
  error?: Error;
}

/**
 * Command handler function type
 */
export type CommandHandler = (args: unknown, options: unknown) => Promise<CommandResult>;`;
}
function generateApplicationTypes() {
  return [
    generateAppConfigInterface(),
    generateCLIApplicationInterface(),
    generateCLIStateInterface(),
  ].join(`

`);
}
function generateAppConfigInterface() {
  return `/**
 * Application configuration interface
 */
export interface AppConfig {
  name: string;
  version: string;
  description: string;
  author: string;
  license: string;
  homepage?: string;
  repository?: string;
  bugs?: string;
  keywords?: string[];
  engines?: Record<string, string>;
}`;
}
function generateCLIApplicationInterface() {
  return `/**
 * CLI application interface
 */
export interface CLIApplication {
  config: AppConfig;
  commands: Record<CLICommand, CommandHandler>;
  logger: Logger;
  plugins: CLIPlugin[];
}`;
}
function generateCLIStateInterface() {
  return `/**
 * CLI state interface
 */
export interface CLIState {
  currentCommand?: CLICommand;
  isRunning: boolean;
  exitCode: number;
  startTime: Date;
  endTime?: Date;
}`;
}
function generateCommandOptionTypes() {
  return [
    generateGlobalOptions(),
    generateBuildOptions(),
    generateDeployOptions(),
    generateTestOptions(),
  ].join(`

`);
}
function generateGlobalOptions() {
  return `/**
 * Global CLI options
 */
export interface GlobalOptions {
  verbose?: boolean;
  quiet?: boolean;
  config?: string;
  help?: boolean;
  version?: boolean;
}`;
}
function generateBuildOptions() {
  return `/**
 * Build command options
 */
export interface BuildOptions extends GlobalOptions {
  watch?: boolean;
  minify?: boolean;
  sourcemap?: boolean;
  target?: string;
  output?: string;
}`;
}
function generateDeployOptions() {
  return `/**
 * Deploy command options
 */
export interface DeployOptions extends GlobalOptions {
  environment?: string;
  dryRun?: boolean;
  force?: boolean;
  skipBuild?: boolean;
}`;
}
function generateTestOptions() {
  return `/**
 * Test command options
 */
export interface TestOptions extends GlobalOptions {
  watch?: boolean;
  coverage?: boolean;
  pattern?: string;
  reporter?: string;
}`;
}

// ../../packages/core/src/services/generators/cli/modules/cli-config-types.ts
function generateConfigurationTypes() {
  return [
    generateMainConfigInterfaces(),
    generateCommandRelatedInterfaces(),
    generatePluginAndHookInterfaces(),
    generateLoggingInterface(),
  ].join(`

`);
}
function generateMainConfigInterfaces() {
  return `/**
 * Configuration file options interface
 */
export interface ConfigFileOptions {
  app: AppConfig;
  commands: CommandConfig[];
  plugins: PluginConfig[];
  hooks: HookConfig[];
  logging: LoggingConfig;
}`;
}
function generateCommandRelatedInterfaces() {
  return [
    generateCommandConfigInterface(),
    generateOptionConfigInterface(),
    generateArgumentConfigInterface(),
  ].join(`

`);
}
function generateCommandConfigInterface() {
  return `/**
 * Command configuration interface
 */
export interface CommandConfig {
  name: CLICommand;
  description: string;
  handler: string;
  options?: OptionConfig[];
  arguments?: ArgumentConfig[];
  examples?: string[];
}`;
}
function generateOptionConfigInterface() {
  return `/**
 * Option configuration interface
 */
export interface OptionConfig {
  name: string;
  description: string;
  type: 'string' | 'number' | 'boolean';
  required?: boolean;
  default?: unknown;
  choices?: unknown[];
}`;
}
function generateArgumentConfigInterface() {
  return `/**
 * Argument configuration interface
 */
export interface ArgumentConfig {
  name: string;
  description: string;
  type: 'string' | 'number' | 'boolean';
  required?: boolean;
  default?: unknown;
}`;
}
function generatePluginAndHookInterfaces() {
  return `/**
 * Plugin configuration interface
 */
export interface PluginConfig {
  name: string;
  enabled: boolean;
  options?: Record<string, unknown>;
}

/**
 * Hook configuration interface
 */
export interface HookConfig {
  name: string;
  command: CLICommand;
  event: 'before' | 'after' | 'error';
  handler: string;
}`;
}
function generateLoggingInterface() {
  return `/**
 * Logging configuration interface
 */
export interface LoggingConfig {
  level: 'error' | 'warn' | 'info' | 'debug';
  format: 'json' | 'simple' | 'detailed';
  output: 'console' | 'file' | 'memory';
  file?: {
    path: string;
    maxSize: string;
    maxFiles: number;
  };
}`;
}

// ../../packages/core/src/services/generators/cli/modules/cli-error-types.ts
function generateErrorTypes() {
  return [generateErrorCodeEnum(), generateErrorClass(), generateErrorHandlerType()].join(`

`);
}
function generateErrorCodeEnum() {
  return `/**
 * CLI error codes
 */
export enum CLIErrorCode {
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
  COMMAND_NOT_FOUND = 'COMMAND_NOT_FOUND',
  INVALID_ARGUMENTS = 'INVALID_ARGUMENTS',
  CONFIGURATION_ERROR = 'CONFIGURATION_ERROR',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  NETWORK_ERROR = 'NETWORK_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
}`;
}
function generateErrorClass() {
  return `/**
 * Custom CLI error class
 */
export class CLIError extends Error {
  public readonly code: CLIErrorCode;
  public readonly details?: Record<string, unknown>;

  constructor(code: CLIErrorCode, message: string, details?: Record<string, unknown>) {
    super(message);
    this.name = 'CLIError';
    this.code = code;
    this.details = details;
  }
}`;
}
function generateErrorHandlerType() {
  return `/**
 * Error handler function type
 */
export type ErrorHandler = (error: CLIError) => void;`;
}

// ../../packages/core/src/services/generators/cli/modules/cli-project-types.ts
function generateProjectSpecificTypes(className) {
  return `/**
 * Project-specific CLI interface
 */
export interface ${className}CLI extends CLIApplication {
  // Add project-specific properties and methods here
}

/**
 * Project-specific configuration
 */
export interface ${className}Config extends ConfigFileOptions {
  // Add project-specific configuration options here
}

/**
 * Project-specific command results
 */
export interface ${className}CommandResult extends CommandResult {
  // Add project-specific result properties here
}`;
}

// ../../packages/core/src/services/generators/cli/modules/cli-runtime-types.ts
function generateRuntimeTypes() {
  return [generatePluginTypes(), generateHookTypes(), generateManagerInterfaces()].join(`

`);
}
function generatePluginTypes() {
  return `/**
 * Plugin interface
 */
export interface CLIPlugin {
  name: string;
  version: string;
  description: string;
  initialize: (app: CLIApplication) => Promise<void>;
  destroy?: () => Promise<void>;
}

/**
 * Plugin manager interface
 */
export interface PluginManager {
  register(plugin: CLIPlugin): Promise<void>;
  unregister(pluginName: string): Promise<void>;
  get(pluginName: string): CLIPlugin | undefined;
  list(): CLIPlugin[];
  initializeAll(): Promise<void>;
  destroyAll(): Promise<void>;
}`;
}
function generateHookTypes() {
  return `/**
 * Hook function type
 */
export type HookFunction = (context: HookContext) => Promise<void>;

/**
 * Hook context interface
 */
export interface HookContext {
  command: CLICommand;
  event: 'before' | 'after' | 'error';
  args: unknown;
  options: unknown;
  result?: CommandResult;
  error?: Error;
  startTime: Date;
}

/**
 * Hook manager interface
 */
export interface HookManager {
  add(command: CLICommand, event: 'before' | 'after' | 'error', handler: HookFunction): void;
  remove(command: CLICommand, event: 'before' | 'after' | 'error', handler: HookFunction): void;
  execute(context: HookContext): Promise<void>;
}`;
}
function generateManagerInterfaces() {
  return '';
}

// ../../packages/core/src/services/generators/cli/modules/cli-utility-types.ts
function generateUtilityTypes() {
  return [
    generateTransformUtilityTypes(),
    generateAsyncUtilityTypes(),
    generateInterfaceUtilityTypes(),
  ].join(`

`);
}
function generateTransformUtilityTypes() {
  return `/**
 * Deep partial utility type
 */
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Required keys utility type
 */
export type RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>;

/**
 * Optional keys utility type
 */
export type OptionalKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;`;
}
function generateAsyncUtilityTypes() {
  return `/**
 * Async function type
 */
export type AsyncFunction<T extends unknown[] = unknown[], R = unknown> = (...args: T) => Promise<R>;`;
}
function generateInterfaceUtilityTypes() {
  return `/**
 * Event emitter interface
 */
export interface EventEmitter {
  on(event: string, listener: (...args: unknown[]) => void): void;
  off(event: string, listener: (...args: unknown[]) => void): void;
  emit(event: string, ...args: unknown[]): void;
}

/**
 * Progress reporter interface
 */
export interface ProgressReporter {
  start(message: string, total?: number): void;
  update(current: number, message?: string): void;
  finish(message?: string): void;
  error(message: string): void;
}`;
}

// ../../packages/core/src/services/generators/cli/cli-types-generator.ts
class CLITypesGenerator {
  generateCLITypes(config) {
    const { name } = config;
    const className = toPascalCase(name);
    return [
      this.generateCLITypesHeader(),
      this.generateCLITypesImports(),
      generateCommandTypes(),
      generateApplicationTypes(),
      generateCommandOptionTypes(),
      generateErrorTypes(),
      generateConfigurationTypes(),
      generateRuntimeTypes(),
      generateUtilityTypes(),
      generateProjectSpecificTypes(className),
    ].join(`
`);
  }
  generateCLITypesHeader() {
    return `/**
 * CLI Types
 *
 * Type definitions for CLI application
 */`;
  }
  generateCLITypesImports() {
    return `import type { Command, Argument, Option } from 'commander';
import type { Logger } from 'winston';`;
  }
}
var init_cli_types_generator = () => {};

// ../../packages/core/src/services/generators/cli/cli-type-config-generators.ts
class CLITypeConfigGenerators {
  typesGenerator;
  configGenerator;
  constructor() {
    this.typesGenerator = new CLITypesGenerator();
    this.configGenerator = new CLIConfigGenerator();
  }
  generateCLITypes(config) {
    return this.typesGenerator.generateCLITypes(config);
  }
  generateCLIConfig(config) {
    return this.configGenerator.generateCLIConfig(config);
  }
}
var init_cli_type_config_generators = __esm(() => {
  init_cli_config_generator();
  init_cli_types_generator();
});

// ../../packages/core/src/services/generators/cli/cli-util-generators.ts
class CLIUtilGenerators {
  generateLoggerUtil(_config) {
    return [
      this.generateLoggerHeader(),
      this.generateLoggerTypes(),
      this.generateLoggerClass(),
      this.generateLoggerExports(),
    ].join(`
`);
  }
  generateLoggerHeader() {
    return `/**
 * Logger Utility
 *
 * Comprehensive logging utility for CLI applications
 */`;
  }
  generateLoggerTypes() {
    return `export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LoggerOptions {
  level?: LogLevel;
  colorEnabled?: boolean;
  prefix?: string;
}`;
  }
  generateLoggerClass() {
    return [
      this.generateLoggerClassDeclaration(),
      this.generateLoggerConstructor(),
      this.generateLoggerSetters(),
      this.generateLoggerHelperMethods(),
      this.generateLoggerLogMethods(),
      this.generateLoggerSuccessMethod(),
      this.generateLoggerChildMethod(),
      this.generateLoggerClassClosing(),
    ].join(`
`);
  }
  generateLoggerClassDeclaration() {
    return `/**
 * Logger Class
 */
export class Logger {
  private level: LogLevel = 'info';
  private colorEnabled: boolean = true;
  private prefix?: string;`;
  }
  generateLoggerConstructor() {
    return `  constructor(options: LoggerOptions = {}) {
    this.level = options.level || 'info';
    this.colorEnabled = options.colorEnabled !== false;
    this.prefix = options.prefix;
  }`;
  }
  generateLoggerSetters() {
    return `  /**
   * Set log level
   * @param {string} level - New log level
   */
  setLevel(level: LogLevel): void {
    this.level = level;
  }

  /**
   * Enable/disable colors
   * @param {string} enabled - Whether to enable colors
   */
  setColorEnabled(enabled: boolean): void {
    this.colorEnabled = enabled;
  }`;
  }
  generateLoggerHelperMethods() {
    return [this.generateShouldLogMethod(), this.generateFormatMessageMethod()].join(`
`);
  }
  generateShouldLogMethod() {
    return `  /**
   * Check if a log level should be output
   * @param {string} level - Log level to check
   * @returns {boolean} if should log
   */
  private shouldLog(level: LogLevel): boolean {
    const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];
    const currentLevelIndex = levels.indexOf(this.level);
    const checkLevelIndex = levels.indexOf(level);

    return checkLevelIndex >= currentLevelIndex;
  }`;
  }
  generateFormatMessageMethod() {
    return `  /**
   * Format log message with colors and timestamp
   * @param {string} level - Log level
   * @param {string} message - Message to format
   * @returns {string} Formatted message
   */
  private formatMessage(level: LogLevel, message: string): string {
    const timestamp = new Date().toISOString();
    const prefix = this.prefix ? \`[\${this.prefix}] \` : '';

    if (!this.colorEnabled) {
      return \`[\${timestamp}] \${prefix}[\${level.toUpperCase()}] \${message}\`;
    }

    const colors = {
      debug: '\\x1b[36m', // Cyan
      info: '\\x1b[32m',  // Green
      warn: '\\x1b[33m',  // Yellow
      error: '\\x1b[31m', // Red
      reset: '\\x1b[0m',   // Reset,
    };

    const levelColors = {
      debug: colors.debug,
      info: colors.info,
      warn: colors.warn,
      error: colors.error,
    };

    return \`\${colors.reset}[\${timestamp}] \${prefix}\${levelColors[level]}[\${level.toUpperCase()}]\${colors.reset} \${message}\`;
  }`;
  }
  generateLoggerLogMethods() {
    return [
      this.generateDebugMethod(),
      this.generateInfoMethod(),
      this.generateWarnMethod(),
      this.generateErrorMethod(),
    ].join(`
`);
  }
  generateDebugMethod() {
    return `  /**
   * Log debug message
   * @param {string} message - Message to log
   * @param {string} args - Additional arguments
   */
  debug(message: string, ...args: any[]): void {
    if (this.shouldLog('debug')) {
      console.debug(this.formatMessage('debug', message), ...args);
    }
  }`;
  }
  generateInfoMethod() {
    return `  /**
   * Log info message
   * @param {string} message - Message to log
   * @param {string} args - Additional arguments
   */
  info(message: string, ...args: any[]): void {
    if (this.shouldLog('info')) {
      console.info(this.formatMessage('info', message), ...args);
    }
  }`;
  }
  generateWarnMethod() {
    return `  /**
   * Log warning message
   * @param {string} message - Message to log
   * @param {string} args - Additional arguments
   */
  warn(message: string, ...args: any[]): void {
    if (this.shouldLog('warn')) {
      console.warn(this.formatMessage('warn', message), ...args);
    }
  }`;
  }
  generateErrorMethod() {
    return `  /**
   * Log error message
   * @param {string} message - Message to log
   * @param {string} args - Additional arguments
   */
  error(message: string, ...args: any[]): void {
    if (this.shouldLog('error')) {
      console.error(this.formatMessage('error', message), ...args);
    }
  }`;
  }
  generateLoggerSuccessMethod() {
    return `  /**
   * Log success message (alias for info with green color)
   * @param {string} message - Message to log
   * @param {string} args - Additional arguments
   */
  success(message: string, ...args: any[]): void {
    if (this.colorEnabled) {
      const greenColor = '\\x1b[32m';
      const resetColor = '\\x1b[0m';
      message = \`\${greenColor}\${message}\${resetColor}\`;
    }

    if (this.shouldLog('info')) {
      console.info(this.formatMessage('info', message), ...args);
    }
  }`;
  }
  generateLoggerChildMethod() {
    return `  /**
   * Create child logger with prefix
   * @param {string} prefix - Prefix for child logger
   * @returns {string} New logger instance with prefix
   */
  child(prefix: string): Logger {
    const fullPrefix = this.prefix ? \`\${this.prefix}:\${prefix}\` : prefix;
    return new Logger({
      level: this.level,
      colorEnabled: this.colorEnabled,
      prefix: fullPrefix,
    });
  }`;
  }
  generateLoggerClassClosing() {
    return `}`;
  }
  generateLoggerExports() {
    return `/**
 * Default logger instance
 */
export const logger = new Logger();

/**
 * Create logger with custom options
   * @param {string} options - Logger options
   * @returns {string} New logger instance
 */
export const createLogger = (options?: LoggerOptions): Logger => {
  return new Logger(options);
};`;
  }
}

// ../../packages/core/src/services/generators/cli/cli-structure-generator.ts
class CLIStructureGenerator {
  commandGenerators;
  utilGenerators;
  typeConfigGenerators;
  indexGenerators;
  constructor() {
    this.commandGenerators = new CLICommandGenerators();
    this.utilGenerators = new CLIUtilGenerators();
    this.typeConfigGenerators = new CLITypeConfigGenerators();
    this.indexGenerators = new CLIIndexGenerators();
  }
  generate(config) {
    const directories = this.getCLIDirectories();
    const files = this.getCLIFiles(config);
    return [...directories, ...files];
  }
  getCLIDirectories() {
    return [
      { path: 'src/commands', type: 'directory', mode: DIRECTORY_PERMISSIONS },
      { path: 'src/utils', type: 'directory', mode: DIRECTORY_PERMISSIONS },
      { path: 'src/types', type: 'directory', mode: DIRECTORY_PERMISSIONS },
      { path: 'src/services', type: 'directory', mode: DIRECTORY_PERMISSIONS },
      { path: 'src/config', type: 'directory', mode: DIRECTORY_PERMISSIONS },
      { path: 'tests', type: 'directory', mode: DIRECTORY_PERMISSIONS },
      { path: 'tests/unit', type: 'directory', mode: DIRECTORY_PERMISSIONS },
      { path: 'tests/integration', type: 'directory', mode: DIRECTORY_PERMISSIONS },
    ];
  }
  getCLIFiles(config) {
    const coreFiles = this.getCoreCLIFiles(config);
    const commandFiles = this.getCommandFiles(config);
    const utilFiles = this.getUtilFiles(config);
    return [...coreFiles, ...commandFiles, ...utilFiles];
  }
  getCoreCLIFiles(config) {
    return [
      {
        path: 'src/index.ts',
        type: 'file',
        mode: FILE_PERMISSIONS2,
        content: this.indexGenerators.generateCLIIndex(config),
      },
      {
        path: 'src/types/index.ts',
        type: 'file',
        mode: FILE_PERMISSIONS2,
        content: this.typeConfigGenerators.generateCLITypes(config),
      },
      {
        path: 'src/config/app-config.ts',
        type: 'file',
        mode: FILE_PERMISSIONS2,
        content: this.typeConfigGenerators.generateCLIConfig(config),
      },
    ];
  }
  getCommandFiles(config) {
    return [
      {
        path: 'src/commands/index.ts',
        type: 'file',
        mode: FILE_PERMISSIONS2,
        content: this.commandGenerators.generateCommandsIndex(config),
      },
      {
        path: 'src/commands/hello-command.ts',
        type: 'file',
        mode: FILE_PERMISSIONS2,
        content: this.commandGenerators.generateHelloCommand(config),
      },
    ];
  }
  getUtilFiles(config) {
    return [
      {
        path: 'src/utils/logger.ts',
        type: 'file',
        mode: FILE_PERMISSIONS2,
        content: this.utilGenerators.generateLoggerUtil(config),
      },
    ];
  }
}
var init_cli_structure_generator = __esm(() => {
  init_validation_constants();
  init_cli_index_generators();
  init_cli_type_config_generators();
});

// ../../packages/core/src/services/generators/express/express-config-generator.ts
class ExpressConfigCodeGenerator {
  generateEnvironmentConfig(_config) {
    return [
      this.getConfigImports(),
      this.getConfigInterface(),
      this.getConfigValidation(),
      this.getConfigImplementation(),
      this.getCorsConfig(),
      this.getDatabaseConfig(),
    ].join(`

`);
  }
  getConfigImports() {
    return `import { config } from 'dotenv';

// Simple validation functions (replacing zod)
function validateNumber(value: string | undefined, defaultValue: number, min?: number, max?: number): number {
  const num = Number(value);
  if (isNaN(num)) return defaultValue;
  if (min !== undefined && num < min) return defaultValue;
  if (max !== undefined && num > max) return defaultValue;
  return num;
}

function validateBoolean(value: string | undefined, defaultValue: boolean): boolean {
  if (!value) return defaultValue;

  const normalizedValue = value.toLowerCase();
  if (normalizedValue === 'true') return true;
  if (normalizedValue === 'false') return false;

  return defaultValue;
}

function validateString(value: string | undefined, defaultValue: string): string {
  return value?.trim() || defaultValue;
}`;
  }
  getConfigInterface() {
    return [
      this.getInterfaceHeader(),
      this.getServerConfigInterface(),
      this.getCorsConfigInterface(),
      this.getDatabaseConfigInterface(),
      this.getSecurityConfigInterface(),
      this.getLoggingConfigInterface(),
      this.getInterfaceFooter(),
    ].join(`
`);
  }
  getInterfaceHeader() {
    return `/**
 * Application configuration interface
 */
export interface AppConfig {`;
  }
  getServerConfigInterface() {
    return `  // Server configuration
  port: number;
  environment: 'development' | 'production' | 'test';
  nodeEnv: string;`;
  }
  getCorsConfigInterface() {
    return `  // CORS configuration
  cors: {
    origin: string | string[];
    credentials: boolean;
    methods: string[];
    allowedHeaders: string[];
  };`;
  }
  getDatabaseConfigInterface() {
    return `  // Database configuration
  database: {
    host: string;
    port: number;
    name: string;
    username: string;
    password: string;
    ssl: boolean;
    url?: string;
  };`;
  }
  getSecurityConfigInterface() {
    return `  // Security configuration
  jwt: {
    secret: string;
    expiresIn: string;
    issuer: string;
  };`;
  }
  getLoggingConfigInterface() {
    return `  // Logging configuration
  logging: {
    level: 'debug' | 'info' | 'warn' | 'error';
    format: 'json' | 'simple';
  };`;
  }
  getInterfaceFooter() {
    return `}`;
  }
  getConfigValidation() {
    return `/**
 * Configuration validation schema
 */
const configSchema = z.object({
  // Server configuration
  PORT: z.string().transform(Number).default('3000'),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),

  // CORS configuration
  CORS_ORIGIN: z.string().default('http://localhost:3000'),
  CORS_CREDENTIALS: z.string().transform(Boolean).default('true'),

  // Database configuration
  DB_HOST: z.string().default('localhost'),
  DB_PORT: z.string().transform(Number).default('5432'),
  DB_NAME: z.string().default('app'),
  DB_USER: z.string().default('postgres'),
  DB_PASSWORD: z.string().default('password'),
  DB_SSL: z.string().transform(Boolean).default('false'),

  // Security configuration
  JWT_SECRET: z.string().min(32),
  JWT_EXPIRES_IN: z.string().default('24h'),
  JWT_ISSUER: z.string().default('app'),

  // Logging configuration
  LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
  LOG_FORMAT: z.enum(['json', 'simple']).default('simple')
});`;
  }
  getConfigImplementation() {
    return [
      this.getConfigHeader(),
      this.getAppConfigExport(),
      this.getConfigExportHeader(),
      this.getServerConfigExport(),
      this.getCorsConfigExport(),
      this.getDatabaseConfigExport(),
      this.getSecurityConfigExport(),
      this.getLoggingConfigExport(),
      this.getConfigExportFooter(),
    ].join(`
`);
  }
  getConfigHeader() {
    return `// Load environment variables
config();`;
  }
  getAppConfigExport() {
    return `/**
 * Validate and export configuration
 */
export const appConfig = configSchema.parse(process.env);`;
  }
  getConfigExportHeader() {
    return `/**
 * Export configuration object with proper typing
 */
export const config: AppConfig = {`;
  }
  getServerConfigExport() {
    return `  // Server configuration
  port: appConfig.PORT,
  environment: appConfig.NODE_ENV,
  nodeEnv: process.env.NODE_ENV || 'development',`;
  }
  getCorsConfigExport() {
    return `  // CORS configuration
  cors: {
    origin: appConfig.CORS_ORIGIN.split(',').map(origin => origin.trim()),
    credentials: appConfig.CORS_CREDENTIALS,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
  },`;
  }
  getDatabaseConfigExport() {
    return `  // Database configuration
  database: {
    host: appConfig.DB_HOST,
    port: appConfig.DB_PORT,
    name: appConfig.DB_NAME,
    username: appConfig.DB_USER,
    password: appConfig.DB_PASSWORD,
    ssl: appConfig.DB_SSL,
    url: \`postgresql://\${appConfig.DB_USER}:\${appConfig.DB_PASSWORD}@\${appConfig.DB_HOST}:\${appConfig.DB_PORT}/\${appConfig.DB_NAME}\`
  },`;
  }
  getSecurityConfigExport() {
    return `  // Security configuration
  jwt: {
    secret: appConfig.JWT_SECRET,
    expiresIn: appConfig.JWT_EXPIRES_IN,
    issuer: appConfig.JWT_ISSUER
  },`;
  }
  getLoggingConfigExport() {
    return `  // Logging configuration
  logging: {
    level: appConfig.LOG_LEVEL,
    format: appConfig.LOG_FORMAT
  }`;
  }
  getConfigExportFooter() {
    return `};`;
  }
  getCorsConfig() {
    return `/**
 * Get CORS options for Express
   * @returns {object}
 */
export function getCorsOptions(): {
  origin: string | string[];
  credentials: boolean;
  methods: string[];
  allowedHeaders: string[];
} {
  return {
    origin: config.cors.origin,
    credentials: config.cors.credentials,
    methods: config.cors.methods,
    allowedHeaders: config.cors.allowedHeaders
  };
}`;
  }
  getDatabaseConfig() {
    return `/**
 * Get database connection configuration
   * @returns {object}
 */
export function getDatabaseConfig(): {
  host: string;
  port: number;
  database: string;
  username: string;
  password: string;
  ssl: boolean;
  connectionString?: string;
} {
  return {
    host: config.database.host,
    port: config.database.port,
    database: config.database.name,
    username: config.database.username,
    password: config.database.password,
    ssl: config.database.ssl,
    connectionString: config.database.url
  };
}`;
  }
}

// ../../packages/core/src/services/generators/express/express-controller-generator.ts
class ExpressControllerCodeGenerator {
  generateAppController(config) {
    return [
      this.getControllerImports(),
      this.getControllerInterface(),
      this.getControllerClass(config),
      this.getControllerExport(),
    ].join(`

`);
  }
  getControllerImports() {
    return `import { Request, Response, NextFunction } from 'express';`;
  }
  getControllerInterface() {
    return `/**
 * Interface for application controller responses
 */
export interface ApiResponse {
  success: boolean;
  message: string;
  data?: unknown;
  error?: string;
  timestamp: string;
}`;
  }
  getControllerClass(config) {
    return [
      this.getControllerClassHeader(),
      this.getControllerConstructor(config),
      this.getGetAppInfoMethod(),
      this.getHealthCheckMethod(),
      this.getTestEndpointMethod(),
      this.getControllerClassFooter(),
    ].join(`
`);
  }
  getControllerClassHeader() {
    return `/**
 * Main Application Controller
 * Handles basic application endpoints
 */
export class AppController {
  private readonly serviceName: string;`;
  }
  getControllerConstructor(config) {
    return `  constructor() {
    this.serviceName = '${config.name}';
  }`;
  }
  getGetAppInfoMethod() {
    return `  /**
   * Get application information
   * @param {string} req - Express request object
   * @param {string} res - Express response object
   * @param {string} next - Express next function
   */
  public getAppInfo(req: Request, res: Response, next: NextFunction): void {
    try {
      const response: ApiResponse = {
        success: true,
        message: 'Application information retrieved successfully',
        data: {
          name: this.serviceName,
          version: '1.0.0',
          environment: process.env.NODE_ENV || 'development',
          uptime: process.uptime(),
          memory: process.memoryUsage(),
          timestamp: new Date().toISOString()
        },
        timestamp: new Date().toISOString()
      };

      res.json(response);
    } catch (error) {
      next(error);
    }
  }`;
  }
  getHealthCheckMethod() {
    return `  /**
   * Health check endpoint
   * @param {string} req - Express request object
   * @param {string} res - Express response object
   * @param {string} next - Express next function
   */
  public healthCheck(req: Request, res: Response, next: NextFunction): void {
    try {
      const response: ApiResponse = {
        success: true,
        message: 'Service is healthy',
        data: {
          status: 'healthy',
          service: this.serviceName,
          timestamp: new Date().toISOString()
        },
        timestamp: new Date().toISOString()
      };

      res.json(response);
    } catch (error) {
      next(error);
    }
  }`;
  }
  getTestEndpointMethod() {
    return `  /**
   * Test endpoint for development
   * @param {string} req - Express request object
   * @param {string} res - Express response object
   * @param {string} next - Express next function
   */
  public testEndpoint(req: Request, res: Response, next: NextFunction): void {
    try {
      const response: ApiResponse = {
        success: true,
        message: 'Test endpoint working',
        data: {
          query: req.query,
          params: req.params,
          headers: req.headers,
          timestamp: new Date().toISOString()
        },
        timestamp: new Date().toISOString()
      };

      res.json(response);
    } catch (error) {
      next(error);
    }
  }`;
  }
  getControllerClassFooter() {
    return `}`;
  }
  getControllerExport() {
    return `// Export singleton instance
export const appController = new AppController();`;
  }
}

// ../../packages/core/src/services/generators/express/express-middleware-generator.ts
class ExpressMiddlewareCodeGenerator {
  generateErrorMiddleware(_config) {
    return [
      this.getMiddlewareImports(),
      this.getErrorInterface(),
      this.getErrorMiddlewareImplementation(),
      this.get404Handler(),
      this.getValidationMiddleware(),
      this.getLoggingMiddleware(),
    ].join(`

`);
  }
  getMiddlewareImports() {
    return `import { Request, Response, NextFunction } from 'express';`;
  }
  getErrorInterface() {
    return `/**
 * Extended error interface for application errors
 */
export interface AppError extends Error {
  statusCode?: number;
  isOperational?: boolean;
  code?: string;
  details?: Record<string, unknown>;
}`;
  }
  getErrorMiddlewareImplementation() {
    return [this.getErrorMiddlewareSignature(), this.getErrorMiddlewareBody()].join(`
`);
  }
  getErrorMiddlewareSignature() {
    return `/**
 * Global error handling middleware
 * @param {string} error - Error object
 * @param {string} req - Express request object
 * @param {string} res - Express response object
 * @param {string} next - Express next function
 */
export function errorHandler(
  error: AppError,
  req: Request,
  res: Response,
  next: NextFunction
): void {`;
  }
  getErrorMiddlewareBody() {
    return [
      this.getErrorContext(),
      this.getErrorLogging(),
      this.getErrorResponsePreparation(),
      this.getErrorSending(),
    ].join(`

`);
  }
  getErrorContext() {
    return `  const statusCode = error.statusCode || 500;
  const isOperational = error.isOperational || false;`;
  }
  getErrorLogging() {
    return `  // Log error details using structured logging
  const logData = {
    message: error.message,
    stack: error.stack,
    statusCode,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
    timestamp: new Date().toISOString()
  };

  // In production, use a proper logging service
  if (process.env.NODE_ENV === 'production') {
    // Send to logging service (e.g., Winston, Pino, etc.)
    // For now, we'll write to stderr as a fallback
    process.stderr.write(JSON.stringify({ level: 'error', ...logData }) + '\\n');
  } else {
    // Development logging
    process.stderr.write(\`ERROR: \${JSON.stringify(logData, null, 2)}\\n\`);
  }`;
  }
  getErrorResponsePreparation() {
    return `  // Prepare error response
  const errorResponse = {
    success: false,
    error: {
      message: isOperational ? error.message : 'Internal Server Error',
      code: error.code || 'INTERNAL_ERROR',
      ...(isOperational && error.details ? { details: error.details } : {}),
      ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
    },
    timestamp: new Date().toISOString()
  };`;
  }
  getErrorSending() {
    return `  res.status(statusCode).json(errorResponse);`;
  }
  get404Handler() {
    return `/**
 * 404 Not Found handler
 * @param {string} req - Express request object
 * @param {string} res - Express response object
 * @param {string} next - Express next function
 */
export function notFoundHandler(req: Request, res: Response, next: NextFunction): void {
  const error: AppError = new Error(\`Route \${req.originalUrl} not found\`);
  error.statusCode = 404;
  error.isOperational = true;
  next(error);
}`;
  }
  getValidationMiddleware() {
    return [this.getValidationMiddlewareSignature(), this.getValidationMiddlewareBody()].join(`
`);
  }
  getValidationMiddlewareSignature() {
    return `/**
 * Request validation middleware
 * @param {string} schema - Validation schema
 * @returns {string} Validation middleware function
 */
export function validateRequest(schema: {
  body?: Record<string, unknown>;
  params?: Record<string, unknown>;
  query?: Record<string, unknown>;
}) {
  return (req: Request, res: Response, next: NextFunction): void => {`;
  }
  getValidationMiddlewareBody() {
    return `    try {
      // Basic validation implementation
      if (schema.body) {
        req.body = req.body || {};
      }
      if (schema.params) {
        req.params = req.params || {};
      }
      if (schema.query) {
        req.query = req.query || {};
      }

      next();
    } catch (error) {
      const appError: AppError = new Error('Validation failed');
      appError.statusCode = 400;
      appError.isOperational = true;
      appError.details = { validationErrors: error };
      next(appError);
    }
  };
}`;
  }
  getLoggingMiddleware() {
    return [this.getLoggingMiddlewareSignature(), this.getLoggingMiddlewareBody()].join(`
`);
  }
  getLoggingMiddlewareSignature() {
    return `/**
 * Request logging middleware
 * @param {string} req - Express request object
 * @param {string} res - Express response object
 * @param {string} next - Express next function
 */
export function requestLogger(req: Request, res: Response, next: NextFunction): void {`;
  }
  getLoggingMiddlewareBody() {
    return [this.getRequestTimingStart(), this.getResponseLogging(), this.getNextCall()].join(`

`);
  }
  getRequestTimingStart() {
    return `  const startTime = Date.now();`;
  }
  getResponseLogging() {
    return `  res.on('finish', () => {
    const duration = Date.now() - startTime;
    const logData = {
      method: req.method,
      url: req.originalUrl,
      statusCode: res.statusCode,
      duration: \`\${duration}ms\`,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      timestamp: new Date().toISOString()
    };

    // In production, use a proper logging service
    if (process.env.NODE_ENV === 'production') {
      // Send to logging service (e.g., Winston, Pino, etc.)
      // For now, we'll write to stdout as a fallback
      process.stdout.write(JSON.stringify({ level: 'info', ...logData }) + '\\n');
    } else {
      // Development logging
      process.stdout.write(\`ACCESS: \${JSON.stringify(logData, null, 2)}\\n\`);
    }
  });`;
  }
  getNextCall() {
    return `  next();`;
  }
}

// ../../packages/core/src/services/generators/express/express-server-generator.ts
class ExpressServerCodeGenerator {
  generateExpressServer(config) {
    return [
      this.getServerImports(),
      this.getCreateAppFunction(config),
      this.getStartServerFunction(),
      this.getAutoStartScript(),
    ].join(`

`);
  }
  getServerImports() {
    return `import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import { errorHandler } from './middleware/error-handler.js';
import { indexRouter } from './routes/index.js';
import { config } from './config/environment.js';`;
  }
  getCreateAppFunction(config) {
    return [
      this.getCreateAppSignature(),
      this.getCreateAppInitialization(),
      this.getCreateAppSecurity(config),
      this.getCreateAppLogging(config),
      this.getCreateAppBodyParsing(),
      this.getCreateAppRoutes(),
      this.getCreateAppHealthCheck(config),
      this.getCreateApp404Handler(),
      this.getCreateAppErrorHandler(),
      this.getCreateAppReturn(),
    ].join(`
`);
  }
  getCreateAppSignature() {
    return `/**
 * Create and configure Express application
 */
export function createApp(): express.Application {`;
  }
  getCreateAppInitialization() {
    return `  const app = express();`;
  }
  getCreateAppSecurity(_config) {
    return `  // Security middleware
  app.use(helmet());
  app.use(cors({
    origin: config.cors.origin,
    credentials: true
  }));`;
  }
  getCreateAppLogging(_config) {
    return `  // Logging
  if (config.environment === 'development') {
    app.use(morgan('dev'));
  }`;
  }
  getCreateAppBodyParsing() {
    return `  // Body parsing
  app.use(express.json({ limit: '10mb' }));
  app.use(express.urlencoded({ extended: true }));`;
  }
  getCreateAppRoutes() {
    return `  // API routes
  app.use('/api', indexRouter);`;
  }
  getCreateAppHealthCheck(config) {
    return `  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: '${config.name}',
      version: '1.0.0'
    });
  });`;
  }
  getCreateApp404Handler() {
    return `  // 404 handler
  app.use('*', (req, res) => {
    res.status(404).json({
      error: 'Route not found',
      path: req.originalUrl,
      method: req.method
    });
  });`;
  }
  getCreateAppErrorHandler() {
    return `  // Error handling middleware (must be last)
  app.use(errorHandler);`;
  }
  getCreateAppReturn() {
    return `  return app;
}`;
  }
  getStartServerFunction() {
    return `/**
 * Start the Express server
 */
export function startServer(): void {
  const PORT = config.port || 3000;

  createApp().listen(PORT, () => {
    console.log(\`\uD83D\uDE80 Server is running on port \${PORT}\`);
    console.log(\`\uD83D\uDCD6 API documentation: http://localhost:\${PORT}/api\`);
    console.log(\`\uD83C\uDFE5 Health check: http://localhost:\${PORT}/health\`);
  });
}`;
  }
  getAutoStartScript() {
    return `// Auto-start server if this file is run directly
if (require.main === module) {
  startServer().catch((error) => {
    console.error('Failed to start server:', error);
    process.exit(1);
  });
}`;
  }
}

// ../../packages/core/src/services/generators/express/express-structure-generator.ts
class ExpressStructureGenerator {
  serverGenerator;
  controllerGenerator;
  middlewareGenerator;
  configGenerator;
  constructor() {
    this.serverGenerator = new ExpressServerCodeGenerator();
    this.controllerGenerator = new ExpressControllerCodeGenerator();
    this.middlewareGenerator = new ExpressMiddlewareCodeGenerator();
    this.configGenerator = new ExpressConfigCodeGenerator();
  }
  generate(config) {
    const directories = this.getExpressDirectories();
    const files = this.getExpressFiles(config);
    return [...directories, ...files];
  }
  getExpressDirectories() {
    return [
      { path: 'src/routes', type: 'directory' },
      { path: 'src/middleware', type: 'directory' },
      { path: 'src/controllers', type: 'directory' },
      { path: 'src/services', type: 'directory' },
      { path: 'src/utils', type: 'directory' },
      { path: 'src/config', type: 'directory' },
    ];
  }
  getExpressFiles(config) {
    return [
      {
        path: 'src/server.ts',
        type: 'file',
        content: this.serverGenerator.generateExpressServer(config),
      },
      {
        path: 'src/routes/index.ts',
        type: 'file',
        content: this.generateMainRoute(config),
      },
      {
        path: 'src/controllers/app.controller.ts',
        type: 'file',
        content: this.controllerGenerator.generateAppController(config),
      },
      {
        path: 'src/middleware/error-handler.ts',
        type: 'file',
        content: this.middlewareGenerator.generateErrorMiddleware(config),
      },
      {
        path: 'src/config/environment.ts',
        type: 'file',
        content: this.configGenerator.generateEnvironmentConfig(config),
      },
    ];
  }
  generateMainRoute(_config) {
    return `import { Router } from 'express';
import { appController } from '../controllers/app.controller.js';

const router = Router();

/**
 * @route GET /api
 * @desc Get basic API information
 * @access Public
 */
router.get('/', appController.getAppInfo.bind(appController));

/**
 * @route GET /api/health
 * @desc Health check endpoint
 * @access Public
 */
router.get('/health', appController.healthCheck.bind(appController));

/**
 * @route GET /api/test
 * @desc Test endpoint for development
 * @access Public
 */
router.get('/test', appController.testEndpoint.bind(appController));

export { router as indexRouter };`;
  }
}
var init_express_structure_generator = () => {};

// ../../packages/core/src/services/generators/library/components/constants-generator.ts
class ConstantsGenerator {
  generateConstantsExports(config) {
    const className = toPascalCase(config.name);
    const defaultConfig = this.generateDefaultConfig(config, className);
    const errorCodes = this.generateErrorCodes();
    const eventTypes = this.generateEventTypes();
    const defaultOptions = this.generateDefaultOptions();
    const libraryInfo = this.generateLibraryInfo(config);
    return `/**
 * ${config.name} Constants
 *
 * Default values and constants
 */

import type { ${className}Config } from '../types/index.js';

${defaultConfig}

${errorCodes}

${eventTypes}

${defaultOptions}

${libraryInfo}
`;
  }
  generateDefaultConfig(config, className) {
    return `/**
 * Default configuration
 */
export const DEFAULT_CONFIG: ${className}Config = {
  name: '${config.name}',
  version: '1.0.0',
  debug: false,
  options: {},
};`;
  }
  generateErrorCodes() {
    return `/**
 * Error codes
 */
export const ERROR_CODES = {
  INITIALIZATION_FAILED: 'INIT_FAILED',
  NOT_INITIALIZED: 'NOT_INITIALIZED',
  INVALID_CONFIG: 'INVALID_CONFIG',
  PROCESSING_FAILED: 'PROCESSING_FAILED',
  TIMEOUT: 'TIMEOUT',
  VALIDATION_FAILED: 'VALIDATION_FAILED',
} as const;`;
  }
  generateEventTypes() {
    return `/**
 * Event types
 */
export const EVENT_TYPES = {
  INITIALIZED: 'initialized',
  DESTROYED: 'destroyed',
  CONFIG_UPDATED: 'config_updated',
  PROCESSING_STARTED: 'processing_started',
  PROCESSING_COMPLETED: 'processing_completed',
  ERROR_OCCURRED: 'error_occurred',
} as const;`;
  }
  generateDefaultOptions() {
    return `/**
 * Default options
 */
export const DEFAULT_OPTIONS = {
  mode: 'async' as const,
  timeout: 30000,
  retries: 3,
};`;
  }
  generateLibraryInfo(config) {
    return `/**
 * Library metadata
 */
export const LIBRARY_INFO = {
  name: '${config.name}',
  version: '1.0.0',
  description: '${config.description || 'A modern TypeScript library'}',
  author: '${config.author || 'Your Name'}',
  license: '${config.license || 'MIT'}',
  repository: 'https://github.com/your-username/${config.name}',
  homepage: 'https://github.com/your-username/${config.name}#readme',
  bugs: 'https://github.com/your-username/${config.name}/issues',
} as const;`;
  }
}
var init_constants_generator = () => {};

// ../../packages/core/src/services/generators/library/components/core-module-generator.ts
class CoreModuleGenerator {
  generateCoreModule(config) {
    const className = toPascalCase(config.name);
    const constructor = this.generateConstructor(className);
    const initializeMethod = this.generateInitializeMethod();
    const configMethods = this.generateConfigMethods(className);
    const processMethod = this.generateProcessMethod(className);
    return `/**
 * ${className} Core Module
 *
 * Main library implementation
 */

import type { ${className}Config, ${className}Options } from './types/index.js';
import { DEFAULT_CONFIG } from './constants/index.js';
import { validateConfig, mergeConfigs } from './utils/index.js';

/**
 * Main ${className} class
 */
export class ${className} {
  private config: ${className}Config;
  private initialized: boolean = false;

  ${constructor}

  ${initializeMethod}

  ${configMethods}

  ${processMethod}
}`;
  }
  generateConstructor(className) {
    return `/**
   * Create a new ${className} instance
   * @param {string} config - Configuration options
   */
  constructor(config?: Partial<${className}Config>) {
    this.config = mergeConfigs(DEFAULT_CONFIG, config);
  }`;
  }
  generateInitializeMethod() {
    return `/**
   * Initialize the library
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      // Validate configuration
      validateConfig(this.config);

      if (this.config.debug) {
        console.log(\`\${this.config.name} v\${this.config.version} initializing...\`);
      }

      // Perform initialization logic here
      this.initialized = true;

      if (this.config.debug) {
        console.log(\`\${this.config.name} initialized successfully\`);
      }
    } catch (error) {
      console.error(\`Failed to initialize \${this.config.name}:\`, error);
      throw error;
    }
  }`;
  }
  generateConfigMethods(className) {
    return `/**
   * Get current configuration
   * @returns {string} Current configuration
   */
  getConfig(): ${className}Config {
    return { ...this.config };
  }

  /**
   * Update configuration
   * @param {string} updates - Configuration updates
   */
  updateConfig(updates: Partial<${className}Config>): void {
    this.config = mergeConfigs(this.config, updates);
    validateConfig(this.config);
  }`;
  }
  generateProcessMethod(className) {
    const methodSignature = this.generateProcessMethodSignature(className);
    const methodBody = this.generateProcessMethodBody();
    const doProcessMethod = this.generateDoProcessMethod();
    return `${methodSignature}

${methodBody}

${doProcessMethod}`;
  }
  generateProcessMethodSignature(className) {
    return `/**
   * Perform main library operation
   * @param {string} input - Input data
   * @param {string} options - Operation options
   * @returns {string} Operation result
   */
  async process<T = unknown>(
    input: T,
    options?: ${className}Options
  ): Promise<T> {`;
  }
  generateProcessMethodBody() {
    return `  if (!this.initialized) {
    throw new Error(\`\${this.config.name} must be initialized before use\`);
  }

  try {
    const mergedOptions = mergeConfigs(this.config.options, options || {});

    if (this.config.debug) {
      console.log('Processing input:', { input, options: mergedOptions });
    }

    // Main processing logic goes here
    const result = await this.doProcess(input, mergedOptions);

    if (this.config.debug) {
      console.log('Processing result:', result);
    }

    return result;
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(\`Processing failed: \${error.message}\`);
    }
    throw new Error('Processing failed: Unknown error');
  }
}`;
  }
  generateDoProcessMethod() {
    return `/**
   * Internal processing method (to be implemented by specific libraries)
   * @param {string} input - Input data
   * @param {string} options - Processing options
   * @returns {string} Processed data
   */
  private async doProcess<T = unknown>(input: T, options: unknown): Promise<T> {
    // Default implementation - should be overridden by specific libraries
    return input;
  }`;
  }
}
var init_core_module_generator = () => {};

// ../../packages/core/src/services/generators/library/components/examples-generator.ts
class ExamplesGenerator {
  generateBasicExample(config) {
    const className = toPascalCase(config.name);
    const header = this.generateExampleHeader(className, config, 'Basic Usage Example');
    const example1 = this.generateBasicExample1(className);
    const example2 = this.generateBasicExample2(className);
    const example3 = this.generateBasicExample3(className);
    const runFunction = this.generateRunFunction(['example1', 'example2', 'example3']);
    return [header, example1, example2, example3, runFunction].join(`

`);
  }
  generateAdvancedExample(config) {
    const className = toPascalCase(config.name);
    const header = this.generateExampleHeader(className, config, 'Advanced Usage Example');
    const configExample = this.generateAdvancedConfig(className);
    const examples = this.generateAdvancedExamples(className);
    const runFunction = this.generateAdvancedRunFunction();
    return [header, configExample, examples, runFunction].join(`

`);
  }
  generateExampleHeader(className, config, title) {
    return `/**
 * ${title}
 *
 * Demonstrates ${title.toLowerCase()} of ${config.name}
 */

import { ${className}, create${className}, quickProcess } from '../../src/lib/index.js';`;
  }
  generateBasicExample1(className) {
    return `/**
 * Example 1: Basic usage with constructor
 */
async function example1() {
  console.log('=== Example 1: Basic Usage ===');

  // Create instance
  const instance = new ${className}({
    debug: true,
  });

  // Initialize
  await instance.initialize();

  // Process some data
  const result = await instance.process('Hello, World!');

  console.log('Result:', result);

  // Clean up
  await instance.destroy();
}`;
  }
  generateBasicExample2(className) {
    return `/**
 * Example 2: Using convenience function
 */
async function example2() {
  console.log('=== Example 2: Convenience Function ===');

  // Create and initialize in one step
  const instance = await create${className}({
    debug: true,
  });

  // Use the instance
  const result = await instance.process('Quick start example');

  console.log('Result:', result);
}`;
  }
  generateBasicExample3(_className) {
    return `/**
 * Example 3: Quick processing
 */
async function example3() {
  console.log('=== Example 3: Quick Processing ===');

  // One-off processing
  const result = await quickProcess(
    'Quick example',
    {
      debug: true,
    },
    {
      mode: 'async',
      timeout: 5000,
    }
  );

  console.log('Result:', result);
}`;
  }
  generateAdvancedConfig(_className) {
    return `/**
 * Custom configuration
 */
const customConfig = {
  debug: true,
  options: {
    customFeature: true,
    maxItems: 100,
    timeout: 10000,
  },
};`;
  }
  generateAdvancedExamples(className) {
    const example1 = this.generateAdvancedExample1(className);
    const example2 = this.generateAdvancedExample2(className);
    const example3 = this.generateAdvancedExample3(className);
    return `${example1}

${example2}

${example3}`;
  }
  generateAdvancedExample1(className) {
    return `/**
 * Example 1: Custom configuration
 */
async function example1() {
  console.log('=== Example 1: Custom Configuration ===');

  const instance = new ${className}(customConfig);
  await instance.initialize();

  // Show configuration
  console.log('Config:', instance.getConfig());

  await instance.destroy();
}`;
  }
  generateAdvancedExample2(className) {
    return `/**
 * Example 2: Error handling
 */
async function example2() {
  console.log('=== Example 2: Error Handling ===');

  try {
    const instance = new ${className}({
      debug: true,
    });

    await instance.initialize();

    // Simulate an error scenario
    console.log('Error handling example completed successfully');

    await instance.destroy();
  } catch (error) {
    console.error('Caught error:', error);
  }
}`;
  }
  generateAdvancedExample3(className) {
    return `/**
 * Example 3: Performance monitoring
 */
async function example3() {
  console.log('=== Example 3: Performance Monitoring ===');

  const instance = new ${className}({
    debug: true,
  });

  await instance.initialize();

  // Perform some operations
  const startTime = performance.now();

  for (let i = 0; i < 100; i++) {
    await instance.process(\`item-\${i}\`);
  }

  const endTime = performance.now();
  const duration = endTime - startTime;

  console.log(\`Processed 100 items in \${duration.toFixed(2)}ms\`);
  console.log(\`Average time per item: \${(duration / 100).toFixed(2)}ms\`);

  await instance.destroy();
}`;
  }
  generateRunFunction(exampleNames) {
    const exampleCalls = exampleNames.map((name) => `    await ${name}();`).join(`
`);
    const separators = Array(exampleNames.length - 1).fill("    console.log('\\n---\\n');").join(`
`);
    return `/**
 * Run all examples
 */
async function runExamples() {
  try {
${exampleCalls}

${separators}
  } catch (error) {
    console.error('Example failed:', error);
  }
}

// Run examples if this file is executed directly
if (import.meta.url === \`file://\${process.argv[1]}\`) {
  runExamples();
}

export { ${exampleNames.join(', ')}, runExamples };`;
  }
  generateAdvancedRunFunction() {
    return `/**
 * Run examples
 */
async function runAdvancedExamples() {
  await example1();
  await example2();
  await example3();
}

// Export for usage
export { example1, example2, example3, runAdvancedExamples };`;
  }
}
var init_examples_generator = () => {};

// ../../packages/core/src/services/generators/library/components/main-export-generator.ts
class MainExportGenerator {
  generateMainExport(config) {
    const className = toPascalCase(config.name);
    const header = this.generateMainHeader(config, className);
    const coreExports = this.generateCoreExports(className);
    const typeExports = this.generateTypeExports(className);
    const utilityExports = this.generateUtilityExports();
    const constantExports = this.generateConstantExports();
    const defaultExport = this.generateDefaultExport(className);
    return [header, coreExports, typeExports, utilityExports, constantExports, defaultExport].join(`
`);
  }
  generateMainHeader(config, _className) {
    return `/**
 * ${config.name}
 *
${config.description || 'A modern TypeScript library'}
 *
 * @author ${config.author || 'Your Name'}
 * @version 1.0.0
 * @license ${config.license || 'MIT'}
 */`;
  }
  generateCoreExports(className) {
    return `// Core exports
export { ${className} } from './core.js';`;
  }
  generateTypeExports(className) {
    return `export type { ${className}Config, ${className}Options } from './types/index.js';`;
  }
  generateUtilityExports() {
    return `// Utility exports
export * from './utils/index.js';`;
  }
  generateConstantExports() {
    return `// Constant exports
export * from './constants/index.js';`;
  }
  generateDefaultExport(className) {
    return `// Default export
export { ${className} as default } from './core.js';`;
  }
}
var init_main_export_generator = () => {};

// ../../packages/core/src/services/generators/library/components/performance-benchmark-generator.ts
class PerformanceBenchmarkGenerator {
  generatePerformanceBenchmark(config) {
    const className = toPascalCase(config.name);
    const header = this.generateBenchmarkHeader(config);
    const initializationTests = this.generateInitializationTests(className);
    const processingTests = this.generateProcessingTests(className);
    const memoryTests = this.generateMemoryTests();
    const throughputTests = this.generateThroughputTests();
    const scalabilityTests = this.generateScalabilityTests();
    return [
      header,
      initializationTests,
      processingTests,
      memoryTests,
      throughputTests,
      scalabilityTests,
    ].join(`

`);
  }
  generateBenchmarkHeader(config) {
    const className = toPascalCase(config.name);
    return `/**
 * Performance Benchmarks
 *
 * Performance tests for ${config.name}
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { ${className}, create${className} } from '../../src/lib/index.js';

describe('${config.name} Performance', () => {
  let instance: ${className};

  beforeEach(async () => {
    instance = await create${className}({
      debug: false, // Disable debug for performance tests
    });
  });`;
  }
  generateInitializationTests(className) {
    return `  describe('Initialization Performance', () => {
    it('should initialize in under 100ms', async () => {
      const startTime = performance.now();

      const newInstance = new ${className}();
      await newInstance.initialize();

      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(100);

      await newInstance.destroy();
    });

    it('should create and initialize in under 150ms', async () => {
      const startTime = performance.now();

      const newInstance = await create${className}();

      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(150);
    });
  });`;
  }
  generateProcessingTests(_className) {
    const singleItemTest = this.generateSingleItemTest();
    const batchTest100 = this.generateBatchTest100();
    const batchTest1000 = this.generateBatchTest1000();
    const concurrentTest = this.generateConcurrentTest();
    return `  describe('Processing Performance', () => {
    ${singleItemTest}

    ${batchTest100}

    ${batchTest1000}

    ${concurrentTest}
  });`;
  }
  generateSingleItemTest() {
    return `it('should process single item in under 10ms', async () => {
      const testData = 'Performance test data';

      const startTime = performance.now();
      const result = await instance.process(testData);
      const duration = performance.now() - startTime;

      expect(duration).toBeLessThan(10);
      expect(result).toBeDefined();
    });`;
  }
  generateBatchTest100() {
    return `it('should process 100 items in under 500ms', async () => {
      const items = Array.from({ length: 100 }, (_, i) => \`Item \${i}\`);

      const startTime = performance.now();

      for (const item of items) {
        await instance.process(item);
      }

      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(500);
    });`;
  }
  generateBatchTest1000() {
    return `it('should process 1000 items in under 2000ms', async () => {
      const items = Array.from({ length: 1000 }, (_, i) => \`Item \${i}\`);

      const startTime = performance.now();

      for (const item of items) {
        await instance.process(item);
      }

      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(2000);
    });`;
  }
  generateConcurrentTest() {
    return `it('should handle concurrent processing', async () => {
      const items = Array.from({ length: 50 }, (_, i) => \`Item \${i}\`);

      const startTime = performance.now();

      const promises = items.map(item => instance.process(item));
      await Promise.all(promises);

      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(1000);
    });`;
  }
  generateMemoryTests() {
    return `  describe('Memory Usage', () => {
    it('should not leak memory during processing', async () => {
      const initialMemory = process.memoryUsage().heapUsed;

      // Process many items
      for (let i = 0; i < 1000; i++) {
        await instance.process(\`Item \${i}\`);
      }

      // Force garbage collection if available
      if (global.gc) {
        global.gc();
      }

      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = finalMemory - initialMemory;

      // Memory increase should be reasonable (less than 10MB)
      expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024);
    });
  });`;
  }
  generateThroughputTests() {
    return `  describe('Throughput', () => {
    it('should achieve at least 100 operations per second', async () => {
      const items = Array.from({ length: 100 }, (_, i) => \`Item \${i}\`);

      const startTime = performance.now();

      for (const item of items) {
        await instance.process(item);
      }

      const duration = performance.now() - startTime;
      const throughput = items.length / (duration / 1000);

      expect(throughput).toBeGreaterThan(100);
    });
  });`;
  }
  generateScalabilityTests() {
    return `  describe('Scalability', () => {
    it('should handle large data efficiently', async () => {
      const largeData = 'x'.repeat(10000); // 10KB string

      const startTime = performance.now();
      const result = await instance.process(largeData);
      const duration = performance.now() - startTime;

      expect(duration).toBeLessThan(50); // Should handle large data quickly
      expect(result).toBeDefined();
    });
  });
});`;
  }
}
var init_performance_benchmark_generator = () => {};

// ../../packages/core/src/services/generators/library/components/types-generator.ts
class TypesGenerator {
  generateTypeExports(config) {
    const className = toPascalCase(config.name);
    const configInterface = this.generateConfigInterface(className);
    const optionsInterface = this.generateOptionsInterface(className);
    const resultInterface = this.generateResultInterface(className);
    const eventInterface = this.generateEventInterface(className);
    const errorInterface = this.generateErrorInterface(className);
    const eventHandlerType = this.generateEventHandlerType(className);
    const pluginInterface = this.generatePluginInterface(className);
    return `/**
 * ${className} Types
 *
 * Type definitions for ${config.name}
 */

${configInterface}

${optionsInterface}

${resultInterface}

${eventInterface}

${errorInterface}

${eventHandlerType}

${pluginInterface}
`;
  }
  generateConfigInterface(className) {
    return `export interface ${className}Config {
  /** Library name */
  name: string;
  /** Library version */
  version: string;
  /** Debug mode flag */
  debug: boolean;
  /** Additional options */
  options?: Record<string, unknown>;
}`;
  }
  generateOptionsInterface(className) {
    return `export interface ${className}Options {
  /** Operation mode */
  mode?: 'sync' | 'async';
  /** Timeout in milliseconds */
  timeout?: number;
  /** Retry attempts */
  retries?: number;
  /** Custom data */
  data?: Record<string, unknown>;
}`;
  }
  generateResultInterface(className) {
    return `export interface ${className}Result<T = unknown> {
  /** Success flag */
  success: boolean;
  /** Result data */
  data?: T;
  /** Error message */
  error?: string;
  /** Processing time in milliseconds */
  duration?: number;
  /** Timestamp */
  timestamp: string;
}`;
  }
  generateEventInterface(className) {
    return `export interface ${className}Event {
  /** Event type */
  type: string;
  /** Event data */
  data: unknown;
  /** Timestamp */
  timestamp: string;
}`;
  }
  generateErrorInterface(className) {
    return `export interface ${className}Error extends Error {
  /** Error code */
  code: string;
  /** Error details */
  details?: Record<string, unknown>;
}`;
  }
  generateEventHandlerType(className) {
    return `export type ${className}EventHandler<T = unknown> = (event: ${className}Event<T>) => void | Promise<void>;`;
  }
  generatePluginInterface(className) {
    return `export interface ${className}Plugin {
  /** Plugin name */
  name: string;
  /** Plugin version */
  version: string;
  /** Initialize plugin */
  initialize?(config: ${className}Config): Promise<void> | void;
  /** Destroy plugin */
  destroy?(): Promise<void> | void;
}`;
  }
}
var init_types_generator = () => {};

// ../../packages/core/src/services/generators/library/components/utils-generator.ts
class UtilsGenerator {
  generateUtilsExports(config) {
    const className = toPascalCase(config.name);
    const deepMergeFunction = this.generateDeepMergeFunction();
    const mergeConfigsFunction = this.generateMergeConfigsFunction(className);
    const validateConfigFunction = this.generateValidateConfigFunction(className);
    return `/**
 * ${className} Utilities
 *
 * Utility functions for ${config.name}
 */

import type { ${className}Config } from '../types/index.js';

${deepMergeFunction}

${mergeConfigsFunction}

${validateConfigFunction}
`;
  }
  generateDeepMergeFunction() {
    const functionSignature = this.generateDeepMergeSignature();
    const functionBody = this.generateDeepMergeBody();
    const helperFunctions = this.generateDeepMergeHelpers();
    return `${functionSignature}

${functionBody}

${helperFunctions}`;
  }
  generateDeepMergeSignature() {
    return `/**
 * Deep merge two objects
   * @param {string} target - Target object
   * @param {string} source - Source object
   * @returns {object}
 */
export function deepMerge<T extends Record<string, unknown>>(
  target: T,
  source: Partial<T>
): T {`;
  }
  generateDeepMergeBody() {
    return `  const result = { ...target };

  for (const key in source) {
    if (source[key] !== undefined) {
      result[key] = isMergeableValue(source[key], result[key])
        ? deepMerge(result[key] as Record<string, unknown>, source[key] as Record<string, unknown>) as T[Extract<keyof T, string>]
        : source[key] as T[Extract<keyof T, string>];
    }
  }

  return result;
}`;
  }
  generateDeepMergeHelpers() {
    return `/**
 * Check if a value is mergeable (object and not array)
   * @param {string} sourceValue - Source value to check
   * @param {string} targetValue - Target value to check
   * @returns {boolean} values can be merged
 */
function isMergeableValue(
  sourceValue: unknown,
  targetValue: unknown
): boolean {
  return (
    typeof sourceValue === 'object' &&
    sourceValue !== null &&
    !Array.isArray(sourceValue) &&
    typeof targetValue === 'object' &&
    targetValue !== null &&
    !Array.isArray(targetValue)
  );
}`;
  }
  generateMergeConfigsFunction(className) {
    return `/**
 * Merge configuration objects
   * @param {string} defaultConfig - Default configuration
   * @param {string} userConfig - User configuration
   * @returns {string} Merged configuration
 */
export function mergeConfigs(
  defaultConfig: ${className}Config,
  userConfig?: Partial<${className}Config>
): ${className}Config {
  if (!userConfig) {
    return defaultConfig;
  }

  return deepMerge(defaultConfig, userConfig);
}`;
  }
  generateValidateConfigFunction(className) {
    return `/**
 * Validate configuration object
   * @param {string} config - Configuration to validate
 * @throws Error if configuration is invalid
 */
export function validateConfig(config: ${className}Config): void {
  if (!config) {
    throw new Error('Configuration is required');
  }

  if (!config.name || typeof config.name !== 'string') {
    throw new Error('Configuration must have a valid name');
  }

  if (!config.version || typeof config.version !== 'string') {
    throw new Error('Configuration must have a valid version');
  }

  // Add more validation as needed
}`;
  }
}
var init_utils_generator = () => {};

// ../../packages/core/src/services/generators/library/library-structure-generator.ts
class LibraryStructureGenerator {
  constantsGenerator;
  coreModuleGenerator;
  examplesGenerator;
  mainExportGenerator;
  performanceBenchmarkGenerator;
  typesGenerator;
  utilsGenerator;
  constructor() {
    this.constantsGenerator = new ConstantsGenerator();
    this.coreModuleGenerator = new CoreModuleGenerator();
    this.examplesGenerator = new ExamplesGenerator();
    this.mainExportGenerator = new MainExportGenerator();
    this.performanceBenchmarkGenerator = new PerformanceBenchmarkGenerator();
    this.typesGenerator = new TypesGenerator();
    this.utilsGenerator = new UtilsGenerator();
  }
  generate(config) {
    const directories = this.getLibraryDirectories();
    const files = this.getLibraryFiles(config);
    return [...directories, ...files];
  }
  getLibraryDirectories() {
    return [
      { path: 'src/types', type: 'directory' },
      { path: 'src/lib', type: 'directory' },
      { path: 'src/lib/utils', type: 'directory' },
      { path: 'src/lib/constants', type: 'directory' },
      { path: 'examples', type: 'directory' },
      { path: 'examples/basic', type: 'directory' },
      { path: 'examples/advanced', type: 'directory' },
      { path: 'benchmarks', type: 'directory' },
      { path: 'docs/api', type: 'directory' },
    ];
  }
  getLibraryFiles(config) {
    const coreFiles = this.generateCoreFiles(config);
    const exampleFiles = this.generateExampleFiles(config);
    const benchmarkFiles = this.generateBenchmarkFiles(config);
    return [...coreFiles, ...exampleFiles, ...benchmarkFiles];
  }
  generateCoreFiles(config) {
    const fileContents = this.generateCoreFileContents(config);
    const filePaths = [
      'src/index.ts',
      'src/lib/index.ts',
      'src/lib/core.ts',
      'src/types/index.ts',
      'src/lib/utils/index.ts',
      'src/lib/constants/index.ts',
    ];
    return filePaths.map((path2, index) => ({
      path: path2,
      type: 'file',
      content: fileContents[index],
    }));
  }
  generateCoreFileContents(config) {
    return [
      this.mainExportGenerator.generateMainExport(config),
      this.mainExportGenerator.generateMainExport(config),
      this.coreModuleGenerator.generateCoreModule(config),
      this.typesGenerator.generateTypeExports(config),
      this.utilsGenerator.generateUtilsExports(config),
      this.constantsGenerator.generateConstantsExports(config),
    ];
  }
  generateExampleFiles(config) {
    const basicExample = this.examplesGenerator.generateBasicExample(config);
    const advancedExample = this.examplesGenerator.generateAdvancedExample(config);
    return [
      {
        path: 'examples/basic/usage.ts',
        type: 'file',
        content: basicExample,
      },
      {
        path: 'examples/advanced/usage.ts',
        type: 'file',
        content: advancedExample,
      },
    ];
  }
  generateBenchmarkFiles(config) {
    const performanceBenchmark =
      this.performanceBenchmarkGenerator.generatePerformanceBenchmark(config);
    return [
      {
        path: 'benchmarks/performance.test.ts',
        type: 'file',
        content: performanceBenchmark,
      },
    ];
  }
}
var init_library_structure_generator = __esm(() => {
  init_constants_generator();
  init_core_module_generator();
  init_examples_generator();
  init_main_export_generator();
  init_performance_benchmark_generator();
  init_types_generator();
  init_utils_generator();
});

// ../../packages/core/src/services/generators/react/templates/react-component-templates.ts
class ReactComponentTemplates {
  getAppComponentTemplate(componentName, config) {
    return `import React from 'react';
import { ${componentName} } from './components/${componentName}.js';
import { useAppState } from './hooks/useAppState.js';
import './index.css';

/**
 * Main application component
 */
export function App(): JSX.Element {
  const { state, setState } = useAppState();

  return (
    <div className="app">
      <header className="app-header">
        <h1>${config.name}</h1>
        <p>${config.description || 'A modern React application'}</p>
      </header>

      <main className="app-main">
        <${componentName}
          debug={state.debug}
          onStateChange={setState}
        />
      </main>

      <footer className="app-footer">
        <p>Built with Bun, React, and TypeScript</p>
      </footer>
    </div>
  );
}

export default App;`;
  }
  getComponentTemplate(componentName, config) {
    const imports = this.getComponentImports();
    const interfaces = this.getComponentInterfaces(componentName);
    const component = this.getComponentImplementation(componentName, config);
    return `${imports}

${interfaces}

${component}`;
  }
  getComponentImports() {
    return `import React, { useState, useEffect } from 'react';`;
  }
  getComponentInterfaces(componentName) {
    return `interface ${componentName}Props {
  /**
   * Enable debug mode
   */
  debug?: boolean;

  /**
   * Callback when component state changes
   */
  onStateChange?: (state: any) => void;
}

interface ${componentName}State {
  /**
   * Component initialization state
   */
  initialized: boolean;

  /**
   * Current user data
   */
  userData: {
    name: string;
    timestamp: Date;
  } | null;

  /**
   * Error state
   */
  error: string | null;
}`;
  }
  getComponentImplementation(componentName, config) {
    const componentBody = this.getComponentBody(componentName, config);
    const exportStatement = `export default ${componentName};`;
    return `/**
 * ${componentName} component
 */
export function ${componentName}({
  debug = false,
  onStateChange
}: ${componentName}Props): JSX.Element {
  ${componentBody}
}

${exportStatement}`;
  }
  getComponentBody(componentName, config) {
    const stateInit = this.getStateInitialization(componentName);
    const effectHook = this.getEffectHook(componentName, config);
    const renderLogic = this.getRenderLogic(componentName);
    return `${stateInit}

  ${effectHook}

  ${renderLogic}`;
  }
  getStateInitialization(componentName) {
    return `const [state, setState] = useState<${componentName}State>({
    initialized: false,
    userData: null,
    error: null
  });`;
  }
  getEffectHook(componentName, config) {
    return `useEffect(() => {
    const initializeComponent = async () => {
      try {
        ${this.getInitializationLogic(componentName, config)}
      } catch (error) {
        ${this.getErrorHandlingLogic()}
      }
    };

    initializeComponent();
  }, [debug, onStateChange]);`;
  }
  getInitializationLogic(componentName, config) {
    return `if (debug) {
          console.log('${componentName}: Initializing component');
        }

        // Simulate async initialization
        await new Promise(resolve => setTimeout(resolve, 100));

        const newState = {
          initialized: true,
          userData: {
            name: '${config.name}',
            timestamp: new Date()
          },
          error: null
        };

        setState(newState);
        onStateChange?.(newState);`;
  }
  getErrorHandlingLogic() {
    return `const errorState = {
          initialized: false,
          userData: null,
          error: error instanceof Error ? error.message : 'Unknown error'
        };

        setState(errorState);
        onStateChange?.(errorState);`;
  }
  getRenderLogic(componentName) {
    return `if (state.error) {
    return ${this.getErrorRender()};
  }

  if (!state.initialized) {
    return ${this.getLoadingRender(componentName)};
  }

  return ${this.getSuccessRender(componentName)};`;
  }
  getErrorRender() {
    return `(
      <div className="component-error">
        <h3>Error</h3>
        <p>{state.error}</p>
      </div>
    )`;
  }
  getLoadingRender(componentName) {
    return `(
      <div className="component-loading">
        <p>Loading ${componentName}...</p>
      </div>
    )`;
  }
  getSuccessRender(componentName) {
    return `(
    <div className="${componentName.toLowerCase()}">
      <h2>${componentName}</h2>
      {state.userData && (
        <div className="user-data">
          <p>Name: {state.userData.name}</p>
          <p>Initialized: {state.userData.timestamp.toLocaleString()}</p>
        </div>
      )}
      {debug && (
        <div className="debug-info">
          <h4>Debug Information</h4>
          <pre>{JSON.stringify(state, null, 2)}</pre>
        </div>
      )}
    </div>
  )`;
  }
}

// ../../packages/core/src/services/generators/react/templates/react-config-templates.ts
class ReactConfigTemplates {
  getHtmlTemplate(config) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>${config.name}</title>
  <meta name="description" content="${config.description || 'A modern application built with Bun'}" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
</head>
<body>
  <div id="root"></div>
  <script type="module" src="/src/index.tsx"></script>
</body>
</html>`;
  }
  getViteConfigTemplate() {
    return `import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
    open: true
  },
  build: {
    outDir: 'dist',
    sourcemap: true
  }
});`;
  }
}

// ../../packages/core/src/services/generators/react/templates/react-css-templates.ts
class ReactCssTemplates {
  getMainCSSTemplate(config) {
    const cssVariables = this.getCSSVariables();
    const baseStyles = this.getBaseCSSStyles();
    const appStyles = this.getAppCSSStyles();
    const componentStyles = this.getComponentCSSStyles();
    const responsiveStyles = this.getResponsiveCSSStyles();
    return `/* ${config.name} - Main Styles */

${cssVariables}

${baseStyles}

${appStyles}

${componentStyles}

${responsiveStyles}`;
  }
  getCSSVariables() {
    const themeColor = '#61dafb';
    return `:root {
  --primary-color: ${themeColor};
  --secondary-color: #282c34;
  --text-color: #333;
  --background-color: #fff;
  --error-color: #ff6b6b;
  --success-color: #51cf66;
  --border-radius: 8px;
  --spacing-unit: 1rem;
}`;
  }
  getBaseCSSStyles() {
    return `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: var(--text-color);
  background-color: var(--background-color);
  line-height: 1.6;
}`;
  }
  getAppCSSStyles() {
    return `${this.getAppLayoutStyles()}
${this.getAppHeaderStyles()}
${this.getAppMainStyles()}
${this.getAppFooterStyles()}`;
  }
  getAppLayoutStyles() {
    return `.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}`;
  }
  getAppHeaderStyles() {
    return `.app-header {
  background-color: var(--primary-color);
  color: white;
  padding: calc(var(--spacing-unit) * 2);
  text-align: center;
}

.app-header h1 {
  font-size: 2.5rem;
  margin-bottom: var(--spacing-unit);
}

.app-header p {
  font-size: 1.2rem;
  opacity: 0.9;
}`;
  }
  getAppMainStyles() {
    return `.app-main {
  flex: 1;
  padding: calc(var(--spacing-unit) * 2);
  max-width: 1200px;
  margin: 0 auto;
  width: 100%;
}`;
  }
  getAppFooterStyles() {
    return `.app-footer {
  background-color: var(--secondary-color);
  color: white;
  text-align: center;
  padding: var(--spacing-unit);
}`;
  }
  getComponentCSSStyles() {
    return `.component-loading,
.component-error {
  text-align: center;
  padding: calc(var(--spacing-unit) * 2);
}

.component-error {
  color: var(--error-color);
}

.debug-info {
  margin-top: var(--spacing-unit);
  padding: var(--spacing-unit);
  background-color: #f5f5f5;
  border-radius: var(--border-radius);
  border: 1px solid #ddd;
}

.debug-info pre {
  font-size: 0.9rem;
  white-space: pre-wrap;
}

.user-data {
  margin: var(--spacing-unit) 0;
  padding: var(--spacing-unit);
  background-color: #f8f9fa;
  border-radius: var(--border-radius);
}`;
  }
  getResponsiveCSSStyles() {
    return `/* Responsive design */
@media (max-width: 768px) {
  .app-header h1 {
    font-size: 2rem;
  }

  .app-main {
    padding: var(--spacing-unit);
  }
}`;
  }
}

// ../../packages/core/src/services/generators/react/templates/react-hook-templates.ts
class ReactHookTemplates {
  getUseAppHookTemplate() {
    const imports = this.getHookImports();
    const interfaces = this.getHookInterfaces();
    const hook = this.getHookImplementation();
    return `${imports}

${interfaces}

${hook}`;
  }
  getHookImports() {
    return `import { useState, useCallback } from 'react';`;
  }
  getHookInterfaces() {
    return `interface AppState {
  debug: boolean;
  theme: 'light' | 'dark';
  user: {
    id?: string;
    name?: string;
  } | null;
}`;
  }
  getHookImplementation() {
    const stateInit = this.getHookStateInitialization();
    const callbacks = this.getHookCallbacks();
    const returnStatement = this.getHookReturnStatement();
    return `/**
 * Hook for managing global application state
 */
export function useAppState() {
  ${stateInit}

  ${callbacks}

  ${returnStatement}`;
  }
  getHookStateInitialization() {
    return `const [state, setState] = useState<AppState>({
    debug: false,
    theme: 'light',
    user: null
  });`;
  }
  getHookCallbacks() {
    return `const toggleDebug = useCallback(() => {
    setState(prev => ({ ...prev, debug: !prev.debug }));
  }, []);

  const setTheme = useCallback((theme: 'light' | 'dark') => {
    setState(prev => ({ ...prev, theme }));
  }, []);

  const setUser = useCallback((user: AppState['user']) => {
    setState(prev => ({ ...prev, user }));
  }, []);

  const clearUser = useCallback(() => {
    setState(prev => ({ ...prev, user: null }));
  }, []);`;
  }
  getHookReturnStatement() {
    return `return {
    state,
    setState,
    toggleDebug,
    setTheme,
    setUser,
    clearUser
  };`;
  }
}

// ../../packages/core/src/services/generators/react/react-structure-generator.ts
class ReactStructureGenerator {
  componentTemplates;
  hookTemplates;
  cssTemplates;
  configTemplates;
  constructor() {
    this.componentTemplates = new ReactComponentTemplates();
    this.hookTemplates = new ReactHookTemplates();
    this.cssTemplates = new ReactCssTemplates();
    this.configTemplates = new ReactConfigTemplates();
  }
  generate(config) {
    const componentName = toPascalCase(config.name);
    return [...this.getReactDirectories(), ...this.getReactFiles(config, componentName)];
  }
  getReactDirectories() {
    return [
      { path: 'src', type: 'directory' },
      { path: 'src/components', type: 'directory' },
      { path: 'src/hooks', type: 'directory' },
      { path: 'public', type: 'directory' },
    ];
  }
  getReactFiles(config, componentName) {
    return [
      this.createAppFile(config),
      this.createComponentFile(componentName, config),
      this.createHookFile(config),
      this.createHtmlFile(config),
      this.createViteConfigFile(config),
      this.createCssFile(config),
    ];
  }
  createAppFile(config) {
    const componentName = toPascalCase(config.name);
    const content = this.componentTemplates.getAppComponentTemplate(componentName, config);
    return {
      path: 'src/App.tsx',
      type: 'file',
      content,
    };
  }
  createComponentFile(componentName, config) {
    const content = this.componentTemplates.getComponentTemplate(componentName, config);
    return {
      path: `src/components/${componentName}.tsx`,
      type: 'file',
      content,
    };
  }
  createHookFile(_config) {
    const content = this.hookTemplates.getUseAppHookTemplate();
    return {
      path: 'src/hooks/useAppState.ts',
      type: 'file',
      content,
    };
  }
  createHtmlFile(config) {
    const content = this.configTemplates.getHtmlTemplate(config);
    return {
      path: 'public/index.html',
      type: 'file',
      content,
    };
  }
  createViteConfigFile(_config) {
    const content = this.configTemplates.getViteConfigTemplate();
    return {
      path: 'vite.config.ts',
      type: 'file',
      content,
    };
  }
  createCssFile(config) {
    const content = this.cssTemplates.getMainCSSTemplate(config);
    return {
      path: 'src/index.css',
      type: 'file',
      content,
    };
  }
}
var init_react_structure_generator = () => {};

// ../../packages/core/src/services/generators/typescript/typescript-directory-generator.ts
class TypeScriptDirectoryGenerator {
  generateTypeScriptDirectories() {
    return [
      { path: 'src/lib', type: 'directory' },
      { path: 'src/lib/types', type: 'directory' },
      { path: 'src/lib/interfaces', type: 'directory' },
      { path: 'src/lib/enums', type: 'directory' },
      { path: 'src/lib/errors', type: 'directory' },
      { path: 'src/lib/utils', type: 'directory' },
      { path: 'src/lib/validators', type: 'directory' },
      { path: 'src/lib/adapters', type: 'directory' },
      { path: 'src/lib/services', type: 'directory' },
      { path: 'tests/unit', type: 'directory' },
      { path: 'tests/integration', type: 'directory' },
      { path: 'tests/benchmarks', type: 'directory' },
      { path: 'tests/fixtures', type: 'directory' },
      { path: 'tests/mocks', type: 'directory' },
      { path: 'docs/api', type: 'directory' },
      { path: 'docs/guides', type: 'directory' },
      { path: 'examples', type: 'directory' },
      { path: 'scripts', type: 'directory' },
    ];
  }
}

// ../../packages/core/src/services/generators/typescript/typescript-config-generator.ts
class TypeScriptConfigGenerator3 {
  generate(config) {
    return this.generateTypeScriptConfig(config);
  }
  generateTypeScriptConfig(_config) {
    const compilerOptions = this.buildCompilerOptions();
    const baseConfig = this.buildTypeScriptBaseConfig(compilerOptions);
    return JSON.stringify(baseConfig, null, JSON_INDENTATION);
  }
  buildTypeScriptBaseConfig(compilerOptions) {
    return {
      compilerOptions,
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist', 'tests'],
    };
  }
  buildCompilerOptions() {
    const basicOptions = this.getBasicCompilerOptions();
    const strictOptions = this.getStrictTypeCheckingOptions();
    const outputOptions = this.getOutputOptions();
    const moduleOptions = this.getModuleOptions();
    const advancedOptions = this.getAdvancedOptions();
    return {
      ...basicOptions,
      ...strictOptions,
      ...outputOptions,
      ...moduleOptions,
      ...advancedOptions,
    };
  }
  getBasicCompilerOptions() {
    return {
      target: 'ES2022',
      lib: ['ES2022'],
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
    };
  }
  getStrictTypeCheckingOptions() {
    return {
      noImplicitAny: true,
      noImplicitReturns: true,
      noImplicitThis: true,
      noUnusedLocals: true,
      noUnusedParameters: true,
      exactOptionalPropertyTypes: true,
      noImplicitOverride: true,
      noPropertyAccessFromIndexSignature: false,
      noUncheckedIndexedAccess: true,
    };
  }
  getOutputOptions() {
    return {
      outDir: './dist',
      rootDir: './src',
      declaration: true,
      declarationMap: true,
      sourceMap: true,
      removeComments: false,
    };
  }
  getModuleOptions() {
    return {
      module: 'ESNext',
      moduleResolution: 'node',
      resolveJsonModule: true,
      allowSyntheticDefaultImports: true,
    };
  }
  getAdvancedOptions() {
    return {
      experimentalDecorators: true,
      emitDecoratorMetadata: true,
    };
  }
}
var init_typescript_config_generator2 = __esm(() => {
  init_constants2();
});

// ../../packages/core/src/services/generators/typescript/typescript-core-module-generator.ts
class TypeScriptCoreModuleGenerator {
  generateCoreModule(config) {
    const header = this.generateCoreModuleHeader(config);
    const imports = this.generateCoreModuleImports(config);
    const constants = this.generateCoreModuleConstants(config);
    const classDefinition = this.generateCoreClassDefinition(config);
    return `${header}

${imports}

${constants}

${classDefinition}
`;
  }
  generateCoreModuleHeader(config) {
    const className = toPascalCase(config.name);
    const description = config.description || `Main implementation class for ${config.name}`;
    return `/**
 * Core ${className} class
 *
 * ${description}
 */`;
  }
  generateCoreModuleImports(config) {
    const className = toPascalCase(config.name);
    return `import type { ${className}Config } from '../types/index.js';
import { ErrorCode, ${className}Error } from '../errors/index.js';
import { deepMerge, isEmpty } from '../utils/index.js';`;
  }
  generateCoreModuleConstants(config) {
    const className = toPascalCase(config.name);
    return `/**
 * Default configuration for ${className}
 */
const DEFAULT_CONFIG: Partial<${className}Config> = {
  debug: false,
  timeout: 5000,
  maxRetries: 3,
  enableMetrics: false,
};`;
  }
  generateCoreClassDefinition(config) {
    const className = toPascalCase(config.name);
    const constructor = this.generateCoreConstructor(className);
    const publicMethods = this.generateCorePublicMethods(className);
    const privateMethods = this.generateCorePrivateMethods(className);
    return `/**
 * Main ${className} class
 */
export class ${className} {
  private readonly config: ${className}Config;
  private initialized: boolean = false;

${constructor}

${publicMethods}

${privateMethods}
}`;
  }
  generateCoreConstructor(className) {
    return `  constructor(config?: Partial<${className}Config>) {
    this.config = this.mergeWithDefaults(config);
  }`;
  }
  generateCorePublicMethods(className) {
    const initializeMethod = this.generateCoreInitializeMethod(className);
    const configMethods = this.generateCoreConfigMethods(className);
    const stateMethods = this.generateCoreStateMethods(className);
    return `${initializeMethod}

${configMethods}

${stateMethods}`;
  }
  generateCoreInitializeMethod(className) {
    return `  /**
   * Initialize the ${className} instance
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    this.validateConfig(this.config);

    if (this.config.debug) {
      console.log('Initializing ${className}...');
    }

    // Initialize components here
    this.initialized = true;

    if (this.config.debug) {
      console.log('${className} initialized successfully');
    }
  }`;
  }
  generateCoreConfigMethods(className) {
    return `  /**
   * Get current configuration
   */
  getConfig(): ${className}Config {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<${className}Config>): void {
    this.validateConfig({ ...this.config, ...updates });
    Object.assign(this.config, updates);
  }`;
  }
  generateCoreStateMethods(className) {
    return `  /**
   * Check if instance is initialized
   */
  isInitialized(): boolean {
    return this.initialized;
  }

  /**
   * Reset the instance
   */
  reset(): void {
    if (this.config.debug) {
      console.log('Resetting ${className}...');
    }
    this.initialized = false;
  }`;
  }
  generateCorePrivateMethods(className) {
    const validationMethod = this.generateCoreValidationMethod(className);
    const mergeMethod = this.generateCoreMergeMethod(className);
    return `${validationMethod}

${mergeMethod}`;
  }
  generateCoreValidationMethod(className) {
    return `  /**
   * Validate configuration
   */
  private validateConfig(config: Partial<${className}Config>): void {
    if (!config) {
      throw new ${className}Error('Configuration is required', ErrorCode.MissingConfig);
    }

    // Add specific validation logic here
  }`;
  }
  generateCoreMergeMethod(className) {
    return `  /**
   * Merge configuration with defaults
   */
  private mergeWithDefaults(config?: Partial<${className}Config>): ${className}Config {
    return deepMerge(DEFAULT_CONFIG, config || {}) as ${className}Config;
  }`;
  }
}
var init_typescript_core_module_generator = () => {};

// ../../packages/core/src/services/generators/typescript/typescript-main-export-generator.ts
class TypeScriptMainExportGenerator {
  generateMainExport(config) {
    const header = this.generateMainExportHeader(config);
    const typeExports = this.generateMainExportTypeSections(config);
    const enumExports = this.generateMainExportEnumSection();
    const errorExports = this.generateMainExportErrorSection(config);
    const utilityExports = this.generateMainExportUtilitySection();
    const classExport = this.generateMainExportClassSection(config);
    return `${header}

${typeExports}

${enumExports}

${errorExports}

${utilityExports}

${classExport}
`;
  }
  generateMainExportHeader(config) {
    return `/**
 * ${config.name}
 *
 * ${config.description || 'A modern TypeScript library'}
 */`;
  }
  generateMainExportTypeSections(config) {
    const className = toPascalCase(config.name);
    const typeExports = this.generateMainTypeExports(className);
    const interfaceExports = this.generateMainInterfaceExports();
    return `${typeExports}

${interfaceExports}`;
  }
  generateMainTypeExports(className) {
    return `// Export main types
export type {
  ${className}Config,
  OperationResult,
  AsyncFunction,
  EventHandler,
} from './lib/types/index.js';`;
  }
  generateExternalInterfaceExports() {
    return `// Export main interfaces
export type {
  Configurable,
  Service,
  Repository,
  Validator,
  ValidationResult,
  Adapter,
  Logger,
  EventEmitter,
  Cache,
} from './lib/interfaces/index.js';`;
  }
  generateInlineInterfaceDefinitions() {
    return `// Define key interfaces inline for direct access
export interface ProjectConfig {
  /** Project name */
  name: string;
  /** Project description */
  description?: string;
  /** Debug mode */
  debug?: boolean;
  /** Request timeout in milliseconds */
  timeout?: number;
  /** Maximum retry attempts */
  maxRetries?: number;
  /** Enable metrics collection */
  enableMetrics?: boolean;
}`;
  }
  generateOperationResultInterface() {
    return `export interface OperationResult<T = unknown> {
  /** Operation success status */
  success: boolean;
  /** Result data */
  data?: T;
  /** Error message if operation failed */
  error?: string;
  /** Additional metadata */
  metadata?: Record<string, unknown>;
}`;
  }
  generateMainInterfaceExports() {
    const externalExports = this.generateExternalInterfaceExports();
    const inlineDefinitions = this.generateInlineInterfaceDefinitions();
    const operationResult = this.generateOperationResultInterface();
    return `${externalExports}

${inlineDefinitions}

${operationResult}`;
  }
  generateMainExportEnumSection() {
    return `// Export enums
export {
  LogLevel,
  Environment,
  HttpStatus,
  ErrorCode,
  CacheStrategy,
  RetryStrategy,
  DataFormat,
  Compression,
  HashAlgorithm,
  SortDirection,
  ComparisonOperator,
  BooleanState,
  Priority,
} from './lib/enums/index.js';`;
  }
  generateMainExportErrorSection(config) {
    const className = toPascalCase(config.name);
    return `// Export errors
export {
  ${className}Error,
  ConfigError,
  ValidationError,
  TimeoutError,
  NotFoundError,
  PermissionError,
  NetworkError,
  DatabaseError,
  is${className}Error,
  getErrorCode,
} from './lib/errors/index.js';`;
  }
  generateMainExportUtilitySection() {
    return `// Export utilities
export {
  deepClone,
  deepMerge,
  debounce,
  throttle,
  retry,
  timeout,
  generateUUID,
  formatBytes,
  sleep,
  isEmpty,
  capitalize,
  camelCase,
  snakeCase,
  kebabCase,
  parseQueryString,
  toQueryString,
} from './lib/utils/index.js';`;
  }
  generateMainExportClassSection(config) {
    const className = toPascalCase(config.name);
    return `// Export main class
export { ${className} } from './lib/core/index.js';`;
  }
}
var init_typescript_main_export_generator = () => {};

// ../../packages/core/src/services/generators/typescript/exports/type-export-generator.ts
class TypeExportGenerator {
  generateTypeExports(config) {
    const header = this.generateTypeHeader(config);
    const configInterface = this.generateConfigInterface(config);
    const commonTypes = this.generateCommonTypes();
    const functionTypes = this.generateFunctionTypes();
    const utilityTypes = this.generateUtilityTypes();
    return `${header}

${configInterface}

${commonTypes}

${functionTypes}

${utilityTypes}
`;
  }
  generateTypeHeader(config) {
    return `// Type definitions for ${config.name}`;
  }
  generateConfigInterface(config) {
    const className = toPascalCase(config.name);
    return `/**
 * Configuration interface for ${className}
 */
export interface ${className}Config {
  /** Enable debug logging */
  debug?: boolean;
  /** Default timeout in milliseconds */
  timeout?: number;
  /** Maximum retry attempts */
  maxRetries?: number;
  /** Enable performance monitoring */
  enableMetrics?: boolean;
}`;
  }
  generateCommonTypes() {
    return `/**
 * Generic result type for operations
 */
export type OperationResult<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

/**
 * Event handler type
 */
export type EventHandler<T = unknown> = (data: T) => void | Promise<void>;`;
  }
  generateFunctionTypes() {
    return `/**
 * Async function type
 */
export type AsyncFunction<T = unknown> = (...args: unknown[]) => Promise<T>;

/**
 * Predicate function type
 */
export type Predicate<T = unknown> = (value: T) => boolean;

/**
 * Mapper function type
 */
export type Mapper<T, U> = (value: T, index: number) => U;

/**
 * Reducer function type
 */
export type Reducer<T, U> = (accumulator: U, current: T, index: number) => U;`;
  }
  generateUtilityTypes() {
    return `/**
 * Optional utility types
 */
export type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

/**
 * Required utility types
 */
export type RequiredKeys<T, K extends keyof T> = T & Required<Pick<T, K>>;

/**
 * Deep partial utility type
 */
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Deep required utility type
 */
export type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};`;
  }
}
var init_type_export_generator = () => {};

// ../../packages/core/src/services/generators/typescript/exports/interface-export-generator.ts
class InterfaceExportGenerator {
  generateInterfaceExports(config) {
    const header = this.generateInterfaceHeader(config);
    const coreInterfaces = this.generateCoreInterfaces();
    const dataInterfaces = this.generateDataInterfaces();
    const systemInterfaces = this.generateSystemInterfaces();
    return `${header}

${coreInterfaces}

${dataInterfaces}

${systemInterfaces}
`;
  }
  generateInterfaceHeader(config) {
    return `// Interface definitions for ${config.name}`;
  }
  generateCoreInterfaces() {
    const configurable = this.generateConfigurableInterface();
    const service = this.generateServiceInterface();
    const repository = this.generateRepositoryInterface();
    return `${configurable}

${service}

${repository}`;
  }
  generateConfigurableInterface() {
    return `/**
 * Base interface for all configurable entities
 */
export interface Configurable {
  /** Configuration object */
  readonly config: Record<string, unknown>;
  /** Update configuration */
  updateConfig(config: Partial<Record<string, unknown>>): void;
  /** Reset to default configuration */
  resetConfig(): void;
}`;
  }
  generateServiceInterface() {
    return `/**
 * Base interface for all services
 */
export interface Service extends Configurable {
  /** Service name */
  readonly name: string;
  /** Service version */
  readonly version: string;
  /** Initialize the service */
  initialize(): Promise<void>;
  /** Shutdown the service */
  shutdown(): Promise<void>;
  /** Check if service is healthy */
  healthCheck(): Promise<boolean>;
}`;
  }
  generateRepositoryInterface() {
    return `/**
 * Base interface for repositories
 */
export interface Repository<T, ID = string> {
  /** Find entity by ID */
  findById(id: ID): Promise<T | null>;
  /** Find all entities */
  findAll(): Promise<T[]>;
  /** Save entity */
  save(entity: T): Promise<T>;
  /** Update entity */
  update(id: ID, updates: Partial<T>): Promise<T>;
  /** Delete entity */
  delete(id: ID): Promise<boolean>;
  /** Count entities */
  count(): Promise<number>;
}`;
  }
  generateDataInterfaces() {
    const validator = this.generateValidatorInterface();
    const validationResult = this.generateValidationResultInterface();
    const adapter = this.generateAdapterInterface();
    return `${validator}

${validationResult}

${adapter}`;
  }
  generateValidatorInterface() {
    return `/**
 * Base interface for validators
 */
export interface Validator<T = unknown> {
  /** Validate value */
  validate(value: unknown): ValidationResult;
  /** Get error message if validation fails */
  readonly errorMessage?: string;
}`;
  }
  generateValidationResultInterface() {
    return `/**
 * Validation result interface
 */
export interface ValidationResult {
  /** Whether validation passed */
  readonly valid: boolean;
  /** Error messages if validation failed */
  readonly errors: string[];
  /** Warnings */
  readonly warnings: string[];
}`;
  }
  generateAdapterInterface() {
    return `/**
 * Base interface for adapters
 */
export interface Adapter<TInput, TOutput> {
  /** Adapter name */
  readonly name: string;
  /** Check if adapter can handle input */
  canHandle(input: unknown): boolean;
  /** Convert input to output */
  adapt(input: TInput): TOutput;
  /** Check if adapter supports reverse conversion */
  readonly reverse?: boolean;
  /** Convert output back to input */
  adaptReverse?(output: TOutput): TInput;
}`;
  }
  generateSystemInterfaces() {
    const logger2 = this.generateLoggerInterface();
    const eventEmitter = this.generateEventEmitterInterface();
    const cache = this.generateCacheInterface();
    return `${logger2}

${eventEmitter}

${cache}`;
  }
  generateLoggerInterface() {
    return `/**
 * Logger interface
 */
export interface Logger {
  /** Log debug message */
  debug(message: string, ...args: unknown[]): void;
  /** Log info message */
  info(message: string, ...args: unknown[]): void;
  /** Log warning message */
  warn(message: string, ...args: unknown[]): void;
  /** Log error message */
  error(message: string, error?: Error, ...args: unknown[]): void;
}`;
  }
  generateEventEmitterInterface() {
    return `/**
 * Event emitter interface
 */
export interface EventEmitter<TEvents extends Record<string, unknown> = Record<string, unknown>> {
  /** Add event listener */
  on<TEventName extends keyof TEvents>(
    event: TEventName,
    handler: (data: TEvents[TEventName]) => void
  ): () => void;
  /** Add one-time event listener */
  once<TEventName extends keyof TEvents>(
    event: TEventName,
    handler: (data: TEvents[TEventName]) => void
  ): () => void;
  /** Emit event */
  emit<TEventName extends keyof TEvents>(
    event: TEventName,
    data: TEvents[TEventName]
  ): void;
  /** Remove event listener */
  off<TEventName extends keyof TEvents>(
    event: TEventName,
    handler: (data: TEvents[TEventName]) => void
  ): void;
}`;
  }
  generateCacheInterface() {
    return `/**
 * Cache interface
 */
export interface Cache<T = unknown> {
  /** Get value from cache */
  get(key: string): Promise<T | undefined>;
  /** Set value in cache */
  set(key: string, value: T, ttl?: number): Promise<void>;
  /** Delete value from cache */
  delete(key: string): Promise<boolean>;
  /** Clear cache */
  clear(): Promise<void>;
  /** Check if key exists in cache */
  has(key: string): Promise<boolean>;
  /** Get cache size */
  size(): Promise<number>;
}`;
  }
}

// ../../packages/core/src/services/generators/typescript/exports/enum-export-generator.ts
class EnumExportGenerator {
  generateEnumExports(config) {
    const { name } = config;
    const header = this.getHeader(name);
    const coreEnums = this.getCoreEnums();
    const systemEnums = this.getSystemEnums();
    const dataEnums = this.getDataEnums();
    const utilityEnums = this.getUtilityEnums();
    return `${header}

${coreEnums}

${systemEnums}

${dataEnums}

${utilityEnums}
`;
  }
  getHeader(name) {
    return `// Enum definitions for ${name}`;
  }
  getCoreEnums() {
    const logLevel = this.getLogLevelEnum();
    const environment = this.getEnvironmentEnum();
    const priority = this.getPriorityEnum();
    return `${logLevel}

${environment}

${priority}`;
  }
  getLogLevelEnum() {
    return `/**
 * Log levels for structured logging
 */
export enum LogLevel {
  Trace = 'trace',
  Debug = 'debug',
  Info = 'info',
  Warn = 'warn',
  Error = 'error',
  Fatal = 'fatal',
}`;
  }
  getEnvironmentEnum() {
    return `/**
 * Environment types
 */
export enum Environment {
  Development = 'development',
  Testing = 'testing',
  Staging = 'staging',
  Production = 'production',
}`;
  }
  getPriorityEnum() {
    return `/**
 * Priority levels
 */
export enum Priority {
  Low = 'low',
  Medium = 'medium',
  High = 'high',
  Critical = 'critical',
}`;
  }
  getSystemEnums() {
    const httpStatus = this.getHttpStatusEnum();
    const errorCode = this.getErrorCodeEnum();
    const cacheStrategy = this.getCacheStrategyEnum();
    const retryStrategy = this.getRetryStrategyEnum();
    return `${httpStatus}

${errorCode}

${cacheStrategy}

${retryStrategy}`;
  }
  getHttpStatusEnum() {
    return `/**
 * HTTP status codes
 */
export enum HttpStatus {
  // Success
  Ok = 200,
  Created = 201,
  Accepted = 202,
  NoContent = 204,

  // Redirection
  MovedPermanently = 301,
  Found = 302,
  NotModified = 304,

  // Client errors
  BadRequest = 400,
  Unauthorized = 401,
  Forbidden = 403,
  NotFound = 404,
  MethodNotAllowed = 405,
  Conflict = 409,
  UnprocessableEntity = 422,
  TooManyRequests = 429,

  // Server errors
  InternalServerError = 500,
  BadGateway = 502,
  ServiceUnavailable = 503,
  GatewayTimeout = 504,
}`;
  }
  getErrorCodeEnum() {
    return `/**
 * Error codes for application errors
 */
export enum ErrorCode {
  // Configuration errors
  InvalidConfig = 'INVALID_CONFIG',
  MissingConfig = 'MISSING_CONFIG',
  ConfigValidationFailed = 'CONFIG_VALIDATION_FAILED',

  // Processing errors
  ProcessingError = 'PROCESSING_ERROR',
  ValidationError = 'VALIDATION_ERROR',
  TimeoutError = 'TIMEOUT_ERROR',
  ResourceNotFound = 'RESOURCE_NOT_FOUND',
  PermissionDenied = 'PERMISSION_DENIED',

  // System errors
  DatabaseError = 'DATABASE_ERROR',
  NetworkError = 'NETWORK_ERROR',
  FileSystemError = 'FILESYSTEM_ERROR',
  MemoryError = 'MEMORY_ERROR',
}`;
  }
  getCacheStrategyEnum() {
    return `/**
 * Cache strategies
 */
export enum CacheStrategy {
  None = 'none',
  Memory = 'memory',
  Redis = 'redis',
  File = 'file',
}`;
  }
  getRetryStrategyEnum() {
    return `/**
 * Retry strategies
 */
export enum RetryStrategy {
  None = 'none',
  Fixed = 'fixed',
  Exponential = 'exponential',
  Linear = 'linear',
}`;
  }
  getDataEnums() {
    const dataFormat = this.getDataFormatEnum();
    const compression = this.getCompressionEnum();
    const hashAlgorithm = this.getHashAlgorithmEnum();
    return `${dataFormat}

${compression}

${hashAlgorithm}`;
  }
  getDataFormatEnum() {
    return `/**
 * Data formats
 */
export enum DataFormat {
  Json = 'json',
  Xml = 'xml',
  Yaml = 'yaml',
  Csv = 'csv',
  Text = 'text',
  Binary = 'binary',
}`;
  }
  getCompressionEnum() {
    return `/**
 * Compression algorithms
 */
export enum Compression {
  None = 'none',
  Gzip = 'gzip',
  Deflate = 'deflate',
  Brotli = 'brotli',
}`;
  }
  getHashAlgorithmEnum() {
    return `/**
 * Hash algorithms
 */
export enum HashAlgorithm {
  Md5 = 'md5',
  Sha1 = 'sha1',
  Sha256 = 'sha256',
  Sha512 = 'sha512',
}`;
  }
  getUtilityEnums() {
    const sortDirection = this.getSortDirectionEnum();
    const comparisonOperator = this.getComparisonOperatorEnum();
    const booleanState = this.getBooleanStateEnum();
    return `${sortDirection}

${comparisonOperator}

${booleanState}`;
  }
  getSortDirectionEnum() {
    return `/**
 * Sorting directions
 */
export enum SortDirection {
  Ascending = 'asc',
  Descending = 'desc',
}`;
  }
  getComparisonOperatorEnum() {
    return `/**
 * Comparison operators
 */
export enum ComparisonOperator {
  Equals = 'eq',
  NotEquals = 'ne',
  GreaterThan = 'gt',
  GreaterThanOrEqual = 'gte',
  LessThan = 'lt',
  LessThanOrEqual = 'lte',
  In = 'in',
  NotIn = 'nin',
  Contains = 'contains',
  StartsWith = 'startsWith',
  EndsWith = 'endsWith',
}`;
  }
  getBooleanStateEnum() {
    return `/**
 * Boolean states
 */
export enum BooleanState {
  True = 'true',
  False = 'false',
}`;
  }
}

// ../../packages/core/src/services/generators/typescript/exports/error-export-generator.ts
class ErrorExportGenerator {
  generateErrorExports(config) {
    const { name } = config;
    const className = toPascalCase(name);
    const header = this.getHeader(name);
    const baseError = this.getBaseErrorClass(className);
    const configErrors = this.getConfigErrors(className);
    const resourceErrors = this.getResourceErrors(className);
    const systemErrors = this.getSystemErrors(className);
    const utilities = this.getErrorUtilities(className);
    return `${header}

${baseError}

${configErrors}

${resourceErrors}

${systemErrors}

${utilities}
`;
  }
  getHeader(name) {
    return `// Error class definitions for ${name}`;
  }
  getBaseErrorClass(className) {
    const constructorAndMethods = this.generateBaseErrorConstructorAndMethods(className);
    return `/**
 * Base error class for ${className} library
 */
export class ${className}Error extends Error {
  public readonly code: string;
  public readonly cause?: Error;

${constructorAndMethods}
}`;
  }
  generateBaseErrorConstructorAndMethods(className) {
    const constructor = this.generateBaseErrorConstructor(className);
    const toJSON = this.generateToJSONMethod();
    const toString = this.generateToStringMethod();
    return `${constructor}

${toJSON}

${toString}`;
  }
  generateBaseErrorConstructor(className) {
    return `  constructor(message: string, code: string, cause?: Error) {
    super(message);
    this.name = '${className}Error';
    this.code = code;
    this.cause = cause;

    // Maintains proper stack trace for where our error was thrown (only available on V8)
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ${className}Error);
    }
  }`;
  }
  generateToJSONMethod() {
    return `  /**
   * Convert error to JSON representation
   */
  toJSON(): Record<string, unknown> {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      cause: this.cause?.message,
      stack: this.stack,
    };
  }`;
  }
  generateToStringMethod() {
    return `  /**
   * Get string representation
   */
  toString(): string {
    return \`\${this.name} [\${this.code}]: \${this.message}\`;
  }`;
  }
  getConfigErrors(className) {
    return `/**
 * Configuration error thrown when configuration is invalid
 */
export class ConfigError extends ${className}Error {
  constructor(message: string, cause?: Error) {
    super(message, 'CONFIG_ERROR', cause);
    this.name = 'ConfigError';
  }
}

/**
 * Validation error thrown when input validation fails
 */
export class ValidationError extends ${className}Error {
  public readonly field?: string;

  constructor(message: string, field?: string, cause?: Error) {
    super(message, 'VALIDATION_ERROR', cause);
    this.name = 'ValidationError';
    this.field = field;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      field: this.field,
    };
  }
}`;
  }
  getResourceErrors(className) {
    const timeoutError = this.getTimeoutErrorClass(className);
    const notFoundError = this.getNotFoundErrorClass(className);
    const permissionError = this.getPermissionErrorClass(className);
    return `${timeoutError}

${notFoundError}

${permissionError}`;
  }
  getTimeoutErrorClass(className) {
    return `/**
 * Timeout error thrown when operations exceed time limits
 */
export class TimeoutError extends ${className}Error {
  public readonly timeout: number;

  constructor(message: string, timeout: number, cause?: Error) {
    super(message, 'TIMEOUT_ERROR', cause);
    this.name = 'TimeoutError';
    this.timeout = timeout;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      timeout: this.timeout,
    };
  }
}`;
  }
  getNotFoundErrorClass(className) {
    return `/**
 * Resource not found error
 */
export class NotFoundError extends ${className}Error {
  public readonly resource: string;
  public readonly id?: string;

  constructor(resource: string, id?: string, cause?: Error) {
    const message = id ? \`\${resource} with id '\${id}' not found\` : \`\${resource} not found\`;
    super(message, 'NOT_FOUND_ERROR', cause);
    this.name = 'NotFoundError';
    this.resource = resource;
    this.id = id;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      resource: this.resource,
      id: this.id,
    };
  }
}`;
  }
  getPermissionErrorClass(className) {
    return `/**
 * Permission denied error
 */
export class PermissionError extends ${className}Error {
  public readonly action: string;
  public readonly resource?: string;

  constructor(action: string, resource?: string, cause?: Error) {
    const message = resource
      ? \`Permission denied for action '\${action}' on resource '\${resource}'\`
      : \`Permission denied for action '\${action}'\`;
    super(message, 'PERMISSION_ERROR', cause);
    this.name = 'PermissionError';
    this.action = action;
    this.resource = resource;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      action: this.action,
      resource: this.resource,
    };
  }
}`;
  }
  getSystemErrors(className) {
    const networkError = this.getNetworkErrorClass(className);
    const databaseError = this.getDatabaseErrorClass(className);
    return `${networkError}

${databaseError}`;
  }
  getNetworkErrorClass(className) {
    return `/**
 * Network error for connection issues
 */
export class NetworkError extends ${className}Error {
  public readonly url?: string;
  public readonly status?: number;

  constructor(message: string, url?: string, status?: number, cause?: Error) {
    super(message, 'NETWORK_ERROR', cause);
    this.name = 'NetworkError';
    this.url = url;
    this.status = status;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      url: this.url,
      status: this.status,
    };
  }
}`;
  }
  getDatabaseErrorClass(className) {
    return `/**
 * Database error for data persistence issues
 */
export class DatabaseError extends ${className}Error {
  public readonly query?: string;
  public readonly table?: string;

  constructor(message: string, query?: string, table?: string, cause?: Error) {
    super(message, 'DATABASE_ERROR', cause);
    this.name = 'DatabaseError';
    this.query = query;
    this.table = table;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      query: this.query,
      table: this.table,
    };
  }
}`;
  }
  getErrorUtilities(className) {
    return `/**
 * Utility function to check if an error is a ${className}Error
 */
export function is${className}Error(error: unknown): error is ${className}Error {
  return error instanceof ${className}Error;
}

/**
 * Utility function to get error code from any error
 */
export function getErrorCode(error: unknown): string {
  if (is${className}Error(error)) {
    return error.code;
  }
  if (error instanceof Error) {
    return error.name;
  }
  return 'UNKNOWN_ERROR';
}`;
  }
}
var init_error_export_generator = () => {};

// ../../packages/core/src/services/generators/typescript/exports/utils-export-generator.ts
class UtilsExportGenerator {
  generateUtilsExports(config) {
    const { name } = config;
    const header = this.getHeader(name);
    const objectUtils = this.getObjectUtilities();
    const functionUtils = this.getFunctionUtilities();
    const promiseUtils = this.getPromiseUtilities();
    const dataUtils = this.getDataUtilities();
    const stringUtils = this.getStringUtilities();
    const urlUtils = this.getUrlUtilities();
    return `${header}

${objectUtils}

${functionUtils}

${promiseUtils}

${dataUtils}

${stringUtils}

${urlUtils}
`;
  }
  getHeader(name) {
    return `// Utility functions for ${name}`;
  }
  getObjectUtilities() {
    const deepClone = this.getDeepCloneFunction();
    const deepMerge3 = this.getDeepMergeFunction();
    const isObject = this.getIsObjectFunction();
    return `${deepClone}

${deepMerge3}

${isObject}`;
  }
  getDeepCloneFunction() {
    return `/**
 * Deep clone an object
 */
export function deepClone<T>(obj: T): T {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (obj instanceof Date) {
    return new Date(obj.getTime()) as unknown as T;
  }

  if (obj instanceof Array) {
    return obj.map(item => deepClone(item)) as unknown as T;
  }

  if (typeof obj === 'object') {
    const clonedObj = {} as { [key: string]: unknown };
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        clonedObj[key] = deepClone(obj[key]);
      }
    }
    return clonedObj as T;
  }

  return obj;
}`;
  }
  getDeepMergeFunction() {
    return `/**
 * Deep merge objects
 */
export function deepMerge<T extends Record<string, unknown>>(target: T, ...sources: Partial<T>[]): T {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        deepMerge(target[key] as Record<string, unknown>, source[key] as Record<string, unknown>);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return deepMerge(target, ...sources);
}`;
  }
  getIsObjectFunction() {
    return `/**
 * Check if value is an object
 */
function isObject(item: unknown): item is Record<string, unknown> {
  return item && typeof item === 'object' && !Array.isArray(item);
}`;
  }
  getFunctionUtilities() {
    const debounce = this.getDebounceFunction();
    const throttle = this.getThrottleFunction();
    return `${debounce}

${throttle}`;
  }
  getDebounceFunction() {
    return `/**
 * Debounce function calls
 */
export function debounce<T extends (...args: unknown[]) => unknown>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout;
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}`;
  }
  getThrottleFunction() {
    return `/**
 * Throttle function calls
 */
export function throttle<T extends (...args: unknown[]) => unknown>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle: boolean;
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}`;
  }
  getPromiseUtilities() {
    const retry = this.getRetryFunction();
    const timeout = this.getTimeoutFunction();
    const sleep = this.getSleepFunction();
    return `${retry}

${timeout}

${sleep}`;
  }
  getRetryFunction() {
    return `/**
 * Retry function with exponential backoff
 */
export async function retry<T>(
  fn: () => Promise<T>,
  maxAttempts: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      if (attempt === maxAttempts) {
        throw lastError;
      }

      const delay = baseDelay * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError!;
}`;
  }
  getTimeoutFunction() {
    return `/**
 * Timeout promise
 */
export function timeout<T>(
  promise: Promise<T>,
  timeoutMs: number
): Promise<T> {
  return Promise.race([
    promise,
    new Promise<never>((_, reject) =>
      setTimeout(() => reject(new Error(\`Operation timed out after \${timeoutMs}ms\`)), timeoutMs)
    )
  ]);
}`;
  }
  getSleepFunction() {
    return `/**
 * Sleep function
 */
export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}`;
  }
  getDataUtilities() {
    const generateUUID = this.getGenerateUUIDFunction();
    const formatBytes = this.getFormatBytesFunction();
    const isEmpty = this.getIsEmptyFunction();
    return `${generateUUID}

${formatBytes}

${isEmpty}`;
  }
  getGenerateUUIDFunction() {
    return `/**
 * Generate random UUID
 */
export function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}`;
  }
  getFormatBytesFunction() {
    return `/**
 * Format bytes to human readable string
 */
export function formatBytes(bytes: number, decimals: number = 2): string {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}`;
  }
  getIsEmptyFunction() {
    return `/**
 * Check if a value is empty
 */
export function isEmpty(value: unknown): boolean {
  if (value === null || value === undefined) return true;
  if (typeof value === 'string') return value.trim().length === 0;
  if (Array.isArray(value)) return value.length === 0;
  if (typeof value === 'object') return Object.keys(value).length === 0;
  return false;
}`;
  }
  getStringUtilities() {
    return `/**
 * Capitalize first letter of string
 */
export function capitalize(str: string): string {
  if (!str) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Camel case conversion
 */
export function camelCase(str: string): string {
  return str.replace(/[-_\\s]+(.)?/g, (_, char) => char ? char.toUpperCase() : '');
}

/**
 * Snake case conversion
 */
export function snakeCase(str: string): string {
  return str.replace(/[A-Z]/g, letter => \`_\${letter.toLowerCase()}\`).replace(/^_/, '');
}

/**
 * Kebab case conversion
 */
export function kebabCase(str: string): string {
  return str.replace(/[A-Z]/g, letter => \`-\${letter.toLowerCase()}\`).replace(/^-/, '');
}`;
  }
  getUrlUtilities() {
    return `/**
 * Parse query string to object
 */
export function parseQueryString(queryString: string): Record<string, string> {
  const params: Record<string, string> = {};
  const searchParams = new URLSearchParams(queryString);

  for (const [key, value] of searchParams) {
    params[key] = value;
  }

  return params;
}

/**
 * Convert object to query string
 */
export function toQueryString(params: Record<string, unknown>): string {
  const searchParams = new URLSearchParams();

  for (const [key, value] of Object.entries(params)) {
    if (value !== null && value !== undefined) {
      searchParams.set(key, String(value));
    }
  }

  return searchParams.toString();
}`;
  }
}

// ../../packages/core/src/services/generators/typescript/exports/index.ts
var init_exports = __esm(() => {
  init_type_export_generator();
  init_error_export_generator();
});

// ../../packages/core/src/services/generators/typescript/typescript-type-export-generator.ts
class TypeScriptTypeExportGenerator {
  typeExportGenerator;
  interfaceExportGenerator;
  enumExportGenerator;
  errorExportGenerator;
  utilsExportGenerator;
  constructor() {
    this.typeExportGenerator = new TypeExportGenerator();
    this.interfaceExportGenerator = new InterfaceExportGenerator();
    this.enumExportGenerator = new EnumExportGenerator();
    this.errorExportGenerator = new ErrorExportGenerator();
    this.utilsExportGenerator = new UtilsExportGenerator();
  }
  generateTypeExports(config) {
    return this.typeExportGenerator.generateTypeExports(config);
  }
  generateInterfaceExports(config) {
    return this.interfaceExportGenerator.generateInterfaceExports(config);
  }
  generateEnumExports(config) {
    return this.enumExportGenerator.generateEnumExports(config);
  }
  generateErrorExports(config) {
    return this.errorExportGenerator.generateErrorExports(config);
  }
  generateUtilsExports(config) {
    return this.utilsExportGenerator.generateUtilsExports(config);
  }
}
var init_typescript_type_export_generator = __esm(() => {
  init_exports();
});

// ../../packages/core/src/services/generators/typescript/typescript-file-generator.ts
class TypeScriptFileGenerator {
  mainExportGenerator;
  coreModuleGenerator;
  typeExportGenerator;
  configGenerator;
  constructor() {
    this.mainExportGenerator = new TypeScriptMainExportGenerator();
    this.coreModuleGenerator = new TypeScriptCoreModuleGenerator();
    this.typeExportGenerator = new TypeScriptTypeExportGenerator();
    this.configGenerator = new TypeScriptConfigGenerator3();
  }
  generateTypeScriptFiles(config) {
    return [
      ...this.getMainFiles(config),
      ...this.getLibraryFiles(config),
      ...this.getConfigFiles(config),
    ];
  }
  getMainFiles(config) {
    return [
      {
        path: 'src/index.ts',
        type: 'file',
        content: this.mainExportGenerator.generateMainExport(config),
      },
    ];
  }
  getLibraryFiles(config) {
    const coreFiles = this.getCoreLibraryFiles(config);
    const typeFiles = this.getTypeLibraryFiles(config);
    const utilityFiles = this.getUtilityLibraryFiles(config);
    return [...coreFiles, ...typeFiles, ...utilityFiles];
  }
  getCoreLibraryFiles(config) {
    return [
      {
        path: 'src/lib/core/index.ts',
        type: 'file',
        content: this.coreModuleGenerator.generateCoreModule(config),
      },
    ];
  }
  getTypeLibraryFiles(config) {
    return [
      {
        path: 'src/lib/types/index.ts',
        type: 'file',
        content: this.typeExportGenerator.generateTypeExports(config),
      },
      {
        path: 'src/lib/interfaces/index.ts',
        type: 'file',
        content: this.typeExportGenerator.generateInterfaceExports(config),
      },
      {
        path: 'src/lib/enums/index.ts',
        type: 'file',
        content: this.typeExportGenerator.generateEnumExports(config),
      },
      {
        path: 'src/lib/errors/index.ts',
        type: 'file',
        content: this.typeExportGenerator.generateErrorExports(config),
      },
    ];
  }
  getUtilityLibraryFiles(config) {
    return [
      {
        path: 'src/lib/utils/index.ts',
        type: 'file',
        content: this.typeExportGenerator.generateUtilsExports(config),
      },
    ];
  }
  getConfigFiles(config) {
    return [
      {
        path: 'tsconfig.json',
        type: 'file',
        content: this.configGenerator.generateTypeScriptConfig(config),
      },
    ];
  }
}
var init_typescript_file_generator = __esm(() => {
  init_typescript_config_generator2();
  init_typescript_core_module_generator();
  init_typescript_main_export_generator();
  init_typescript_type_export_generator();
});

// ../../packages/core/src/services/generators/typescript/typescript-structure-generator.ts
class TypeScriptStructureGenerator {
  directoryGenerator;
  fileGenerator;
  constructor() {
    this.directoryGenerator = new TypeScriptDirectoryGenerator();
    this.fileGenerator = new TypeScriptFileGenerator();
  }
  generate(config) {
    const directories = this.directoryGenerator.generateTypeScriptDirectories();
    const files = this.fileGenerator.generateTypeScriptFiles(config);
    return [...directories, ...files];
  }
}
var init_typescript_structure_generator = __esm(() => {
  init_typescript_file_generator();
});

// ../../packages/core/src/services/generators/vue/vue-constants.ts
var INIT_DELAY = 100,
  JSON_INDENTATION8 = 2,
  CSS_VALUES,
  FILE_PATHS,
  INTERFACES,
  VUE_IMPORTS,
  THEMES;
var init_vue_constants = __esm(() => {
  CSS_VALUES = {
    ERROR_COLOR: '#ff6b6b',
    TEXT_COLOR: '#333',
    BACKGROUND_LIGHT: '#f8f9fa',
    BACKGROUND_DARK: '#f5f5f5',
    BORDER_COLOR: '#ddd',
    BORDER_RADIUS: '8px',
  };
  FILE_PATHS = {
    COMPONENTS: 'src/components',
    COMPOSABLES: 'src/composables',
    UTILS: 'src/utils',
    PUBLIC: 'public',
    APP_VUE: 'src/App.vue',
    INDEX_CSS: 'src/index.css',
    INDEX_HTML: 'public/index.html',
    VITE_CONFIG: 'vite.config.ts',
    USE_APP_STATE: 'src/composables/useAppState.ts',
  };
  INTERFACES = {
    COMPONENT_STATE: 'ComponentState',
    APP_STATE: 'AppState',
    USER_DATA: 'userData',
  };
  VUE_IMPORTS = ['ref', 'reactive', 'computed', 'watch', 'onMounted'];
  THEMES = {
    LIGHT: 'light',
    DARK: 'dark',
  };
});

// ../../packages/core/src/services/generators/vue/vue-component-generators.ts
class VueComponentGenerators {
  static generateVueAppComponent(config) {
    const template = this.getAppTemplate(config);
    const script = this.getAppScript(config);
    const style = this.getAppStyle();
    return `${template}

${script}

${style}`;
  }
  static generateVueMainComponent(config) {
    const componentName = toPascalCase(config.name);
    const template = this.getMainComponentTemplate(componentName);
    const script = this.getMainComponentScript(config, componentName);
    const style = this.getMainComponentStyle(componentName);
    return `${template}

${script}

${style}`;
  }
  static getAppTemplate(config) {
    const componentName = toPascalCase(config.name);
    return `<template>
  <div class="app">
    <header class="app-header">
      <h1>{{ config.name }}</h1>
      <p>{{ config.description || 'A modern Vue application' }}</p>
    </header>

    <main class="app-main">
      <${componentName}
        :debug="state.debug"
        @state-change="handleStateChange"
      />
    </main>

    <footer class="app-footer">
      <p>Built with Bun, Vue, and TypeScript</p>
    </footer>
  </div>
</template>`;
  }
  static getAppScript(config) {
    const componentName = toPascalCase(config.name);
    return `<script setup lang="ts">
import { reactive } from 'vue'
import ${componentName} from './components/${componentName}.vue'
import { useAppState } from './composables/useAppState.js'

// App configuration
const config = reactive({
  name: '${config.name}',
  description: '${config.description || ''}'
})

// Application state
const { state, setState } = useAppState()

// Handle component state changes
const handleStateChange = (newState: ${INTERFACES.COMPONENT_STATE}) => {
  setState(newState)
}
</script>`;
  }
  static getAppStyle() {
    return `<style>
@import './index.css';
</style>`;
  }
  static getMainComponentTemplate(componentName) {
    return `<template>
  <div class="${componentName.toLowerCase()}">
    <h2>{{ componentName }}</h2>

    <div v-if="state.error" class="component-error">
      <h3>Error</h3>
      <p>{{ state.error }}</p>
    </div>

    <div v-else-if="!state.initialized" class="component-loading">
      <p>Loading {{ componentName }}...</p>
    </div>

    <div v-else>
      <div v-if="state.userData" class="user-data">
        <p>Name: {{ state.userData.name }}</p>
        <p>Initialized: {{ formattedTimestamp }}</p>
      </div>

      <div v-if="debug" class="debug-info">
        <h4>Debug Information</h4>
        <pre>{{ debugInfo }}</pre>
      </div>
    </div>
  </div>
</template>`;
  }
  static getMainComponentScript(config, componentName) {
    const imports = this.getMainComponentImports();
    const interfaces = this.getMainComponentInterfaces();
    const propsDefinition = this.getPropsDefinition();
    const stateDefinition = this.getStateDefinition(componentName);
    const computedProperties = this.getComputedProperties();
    const methods = this.getMethods(config, componentName);
    const watchers = this.getWatchers(componentName);
    const lifecycle = this.getLifecycle();
    return `<script setup lang="ts">
${imports}

${interfaces}

${propsDefinition}

${stateDefinition}

${computedProperties}

${methods}

${watchers}

${lifecycle}
</script>`;
  }
  static getMainComponentImports() {
    return `import { ${VUE_IMPORTS.join(', ')} } from 'vue'`;
  }
  static getMainComponentInterfaces() {
    return `interface ${INTERFACES.COMPONENT_STATE} {
  initialized: boolean
  ${INTERFACES.USER_DATA}: {
    name: string
    timestamp: Date
  } | null
  error: string | null
}

interface Props {
  debug?: boolean
}

interface Emits {
  (e: 'stateChange', state: ${INTERFACES.COMPONENT_STATE}): void
}`;
  }
  static getPropsDefinition() {
    return `const props = withDefaults(defineProps<Props>(), {
  debug: false
})

const emit = defineEmits<Emits>()`;
  }
  static getStateDefinition(componentName) {
    return `const componentName = ref('${componentName}')
const state = ref<${INTERFACES.COMPONENT_STATE}>({
  initialized: false,
  ${INTERFACES.USER_DATA}: null,
  error: null
})`;
  }
  static getComputedProperties() {
    return `// Computed properties
const formattedTimestamp = computed(() => {
  return state.value.${INTERFACES.USER_DATA}?.timestamp.toLocaleString() || ''
})

const debugInfo = computed(() => {
  return JSON.stringify(state.value, null, ${JSON_INDENTATION8})
})`;
  }
  static getMethods(config, _componentName) {
    return `// Methods
const initializeComponent = async () => {
  try {
    if (props.debug) {
      console.log(\`\${componentName.value}: Initializing component\`)
    }

    // Simulate async initialization
    await new Promise(resolve => setTimeout(resolve, ${INIT_DELAY}))

    const newState = {
      initialized: true,
      ${INTERFACES.USER_DATA}: {
        name: '${config.name}',
        timestamp: new Date()
      },
      error: null
    }

    state.value = newState
    emit('stateChange', newState)

  } catch (error) {
    const errorState = {
      initialized: false,
      ${INTERFACES.USER_DATA}: null,
      error: error instanceof Error ? error.message : 'Unknown error'
    }

    state.value = errorState
    emit('stateChange', errorState)
  }
}`;
  }
  static getWatchers(_componentName) {
    return `// Watchers
watch(() => props.debug, (newDebug) => {
  if (newDebug) {
    console.log(\`\${componentName.value}: Debug mode enabled\`)
  }
})`;
  }
  static getLifecycle() {
    return `// Lifecycle
onMounted(() => {
  initializeComponent()
})`;
  }
  static getMainComponentStyle(componentName) {
    return `<style scoped>
.${componentName.toLowerCase()} {
  padding: 1rem;
}

.component-error {
  color: var(--error-color, ${CSS_VALUES.ERROR_COLOR});
}

.component-loading {
  color: var(--text-color, ${CSS_VALUES.TEXT_COLOR});
}

.user-data {
  margin: 1rem 0;
  padding: 1rem;
  background-color: var(--background-light, ${CSS_VALUES.BACKGROUND_LIGHT});
  border-radius: var(--border-radius, ${CSS_VALUES.BORDER_RADIUS});
}

.debug-info {
  margin-top: 1rem;
  padding: 1rem;
  background-color: var(--background-dark, ${CSS_VALUES.BACKGROUND_DARK});
  border-radius: var(--border-radius, ${CSS_VALUES.BORDER_RADIUS});
  border: 1px solid var(--border-color, ${CSS_VALUES.BORDER_COLOR});
}

.debug-info pre {
  font-size: 0.9rem;
  white-space: pre-wrap;
}
</style>`;
  }
}
var init_vue_component_generators = __esm(() => {
  init_vue_constants();
});

// ../../packages/core/src/services/generators/vue/vue-composable-generators.ts
class VueComposableGenerators {
  static generateVueComposable(_config) {
    const imports = this.getComposableImports();
    const interfaces = this.getComposableInterfaces();
    const state = this.getComposableState();
    const computedProperties = this.getComputedProperties();
    const methods = this.getMethods();
    const watchers = this.getWatchers();
    return `${imports}

${interfaces}

${state}

${computedProperties}

${methods}

${watchers}

export function useAppState() {
  return {
    state: readonly(state),
    setState,
    toggleTheme,
    resetState
  }
}`;
  }
  static getComposableImports() {
    return `import { ref, reactive, computed, watch, readonly } from 'vue'`;
  }
  static getComposableInterfaces() {
    return `interface ${INTERFACES.APP_STATE} {
  debug: boolean
  theme: '${THEMES.LIGHT}' | '${THEMES.DARK}'
  user: {
    id?: string
    name?: string
    email?: string
  }
  notifications: Array<{
    id: string
    message: string
    type: 'info' | 'success' | 'warning' | 'error'
    timestamp: Date
  }>
}

interface UserPreferences {
  theme: '${THEMES.LIGHT}' | '${THEMES.DARK}'
  notifications: boolean
  autoSave: boolean
}`;
  }
  static getComposableState() {
    return `// Application state
const state = reactive<${INTERFACES.APP_STATE}>({
  debug: false,
  theme: '${THEMES.LIGHT}',
  user: {},
  notifications: []
})

// User preferences (persisted)
const preferences = reactive<UserPreferences>({
  theme: '${THEMES.LIGHT}',
  notifications: true,
  autoSave: true
})`;
  }
  static getComputedProperties() {
    return `// Computed properties
const isDarkTheme = computed(() => state.theme === '${THEMES.DARK}')

const unreadNotifications = computed(() =>
  state.notifications.filter(n => !n.read).length
)

const hasUser = computed(() => !!state.user.id)

const primaryThemeColor = computed(() =>
  isDarkTheme.value ? '#1a1a1a' : '#ffffff'
)

const textColor = computed(() =>
  isDarkTheme.value ? '#ffffff' : '#000000'
)`;
  }
  static getMethods() {
    const stateMethods = this.getStateMethods();
    const notificationMethods = this.getNotificationMethods();
    const userMethods = this.getUserMethods();
    const initializationMethods = this.getInitializationMethods();
    return `// Methods
${stateMethods}

${notificationMethods}

${userMethods}

${initializationMethods}`;
  }
  static getStateMethods() {
    return `const setState = (newState: Partial<${INTERFACES.APP_STATE}>) => {
  Object.assign(state, newState)

  // Save preferences to localStorage
  if (newState.theme) {
    preferences.theme = newState.theme
    localStorage.setItem('user-preferences', JSON.stringify(preferences))
  }
}

const toggleTheme = () => {
  const newTheme = state.theme === '${THEMES.LIGHT}' ? '${THEMES.DARK}' : '${THEMES.LIGHT}'
  setState({ theme: newTheme })
}

const resetState = () => {
  setState({
    debug: false,
    theme: preferences.theme,
    user: {},
    notifications: []
  })
}`;
  }
  static getNotificationMethods() {
    return `const addNotification = (message: string, type: 'info' | 'success' | 'warning' | 'error' = 'info') => {
  const notification = {
    id: Date.now().toString(),
    message,
    type,
    timestamp: new Date(),
    read: false
  }

  state.notifications.unshift(notification)

  // Keep only last 50 notifications
  if (state.notifications.length > 50) {
    state.notifications = state.notifications.slice(0, 50)
  }
}

const markNotificationRead = (id: string) => {
  const notification = state.notifications.find(n => n.id === id)
  if (notification) {
    notification.read = true
  }
}

const clearNotifications = () => {
  state.notifications = []
}`;
  }
  static getUserMethods() {
    return `const setUser = (user: ${INTERFACES.APP_STATE}['user']) => {
  setState({ user })
}

const clearUser = () => {
  setState({ user: {} })
}`;
  }
  static getInitializationMethods() {
    return `// Initialize from localStorage
const initializeFromStorage = () => {
  try {
    const stored = localStorage.getItem('user-preferences')
    if (stored) {
      const parsedPreferences = JSON.parse(stored)
      Object.assign(preferences, parsedPreferences)
      setState({ theme: parsedPreferences.theme || '${THEMES.LIGHT}' })
    }
  } catch (error) {
    console.warn('Failed to load preferences from localStorage:', error)
  }
}`;
  }
  static getWatchers() {
    return `// Watchers
watch(() => state.debug, (newDebug) => {
  if (newDebug) {
    console.log('Debug mode enabled')
    console.log('Current state:', state)
  }
})

watch(() => state.theme, (newTheme) => {
  // Update document root class for theme
  document.documentElement.classList.remove('theme-light', 'theme-dark')
  document.documentElement.classList.add(\`theme-\${newTheme}\`)

  // Update meta theme-color
  const metaThemeColor = document.querySelector('meta[name="theme-color"]')
  if (metaThemeColor) {
    metaThemeColor.setAttribute('content', primaryThemeColor.value)
  }
})

watch(() => state.notifications, (notifications) => {
  // Log notifications in debug mode
  if (state.debug && notifications.length > 0) {
    console.log('Notifications updated:', notifications)
  }
}, { deep: true })

// Initialize
initializeFromStorage()`;
  }
}
var init_vue_composable_generators = __esm(() => {
  init_vue_constants();
});

// ../../packages/core/src/services/generators/vue/css-layout-generator.ts
class CSSLayoutGenerator {
  static getBaseStyles() {
    const reset = this.getResetStyles();
    const html = this.getHtmlStyles();
    const body = this.getBodyStyles();
    const typography = this.getTypographyStyles();
    const forms = this.getFormStyles();
    const focus = this.getFocusStyles();
    return `/* Reset and base styles */
${reset}

${html}

${body}

${typography}

${forms}

${focus}`;
  }
  static getComponentStyles() {
    const appLayout = this.getAppLayoutStyles();
    const componentSpecific = this.getComponentSpecificStyles();
    return `/* App layout */
${appLayout}

${componentSpecific}`;
  }
  static getResetStyles() {
    return `*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}`;
  }
  static getHtmlStyles() {
    return `html {
  font-family: var(--font-family-sans);
  line-height: var(--line-height-normal);
  color: var(--color-text);
  background-color: var(--color-background);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}`;
  }
  static getBodyStyles() {
    return `body {
  min-height: 100vh;
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-normal);
}

#app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}`;
  }
  static getTypographyStyles() {
    return `/* Typography */
h1, h2, h3, h4, h5, h6 {
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-bottom: var(--spacing-4);
}

h1 { font-size: var(--font-size-3xl); }
h2 { font-size: var(--font-size-2xl); }
h3 { font-size: var(--font-size-xl); }
h4 { font-size: var(--font-size-lg); }
h5 { font-size: var(--font-size-base); }
h6 { font-size: var(--font-size-sm); }

p {
  margin-bottom: var(--spacing-4);
  color: var(--color-text-secondary);
}

a {
  color: var(--color-primary);
  text-decoration: none;
  transition: var(--transition-colors);
}

a:hover {
  text-decoration: underline;
}`;
  }
  static getFormStyles() {
    return `/* Form elements */
button,
input,
textarea,
select {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
  margin: 0;
}

button {
  background: none;
  border: none;
  cursor: pointer;
}`;
  }
  static getFocusStyles() {
    return `/* Focus styles */
:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}`;
  }
  static getAppLayoutStyles() {
    const appStyles = this.getAppStyles();
    const headerStyles = this.getHeaderStyles();
    const mainStyles = this.getMainStyles();
    const footerStyles = this.getFooterStyles();
    return `${appStyles}

${headerStyles}

${mainStyles}

${footerStyles}`;
  }
  static getAppStyles() {
    return `.app {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}`;
  }
  static getHeaderStyles() {
    return `.app-header {
  background-color: var(--color-surface);
  border-bottom: 1px solid var(--color-border);
  padding: var(--spacing-6);
  text-align: center;
}

.app-header h1 {
  color: var(--color-text);
  margin-bottom: var(--spacing-2);
}

.app-header p {
  color: var(--color-text-secondary);
  margin-bottom: 0;
}`;
  }
  static getMainStyles() {
    return `.app-main {
  flex: 1;
  padding: var(--spacing-6);
  display: flex;
  justify-content: center;
  align-items: flex-start;
}`;
  }
  static getFooterStyles() {
    return `.app-footer {
  background-color: var(--color-surface);
  border-top: 1px solid var(--color-border);
  padding: var(--spacing-4);
  text-align: center;
  color: var(--color-text-secondary);
}`;
  }
  static getComponentSpecificStyles() {
    const errorStyles = this.getErrorStyles();
    const loadingStyles = this.getLoadingStyles();
    const userDataStyles = this.getUserDataStyles();
    const debugStyles = this.getDebugStyles();
    return `${errorStyles}

${loadingStyles}

${userDataStyles}

${debugStyles}`;
  }
  static getErrorStyles() {
    return `.component-error {
  color: var(--color-error);
  background-color: rgba(231, 76, 60, 0.1);
  border: 1px solid var(--color-error);
  border-radius: var(--radius-base);
  padding: var(--spacing-4);
  margin-bottom: var(--spacing-4);
}`;
  }
  static getLoadingStyles() {
    return `.component-loading {
  color: var(--color-text-secondary);
  text-align: center;
  padding: var(--spacing-6);
}`;
  }
  static getUserDataStyles() {
    return `.user-data {
  background-color: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-base);
  padding: var(--spacing-5);
  margin-bottom: var(--spacing-4);
}`;
  }
  static getDebugStyles() {
    return `.debug-info {
  background-color: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-base);
  padding: var(--spacing-4);
  margin-top: var(--spacing-4);
}

.debug-info pre {
  background-color: var(--color-background);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-sm);
  padding: var(--spacing-3);
  font-family: var(--font-family-mono);
  font-size: var(--font-size-sm);
  overflow-x: auto;
  white-space: pre-wrap;
}`;
  }
}

// ../../packages/core/src/services/generators/vue/css-utilities-generator.ts
class CSSUtilitiesGenerator {
  static getUtilityClasses() {
    const accessibility = this.getAccessibilityUtilities();
    const text = this.getTextUtilities();
    const colors5 = this.getColorUtilities();
    const backgrounds = this.getBackgroundUtilities();
    const borders = this.getBorderUtilities();
    const borderRadius = this.getBorderRadiusUtilities();
    const shadows = this.getShadowUtilities();
    const spacing = this.getSpacingUtilities();
    const display = this.getDisplayUtilities();
    const flexbox = this.getFlexboxUtilities();
    const visibility = this.getVisibilityUtilities();
    return `/* Utility classes */
${accessibility}

${text}

${colors5}

${backgrounds}

${borders}

${borderRadius}

${shadows}

${spacing}

${display}

${flexbox}

${visibility}`;
  }
  static getAccessibilityUtilities() {
    return `.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}`;
  }
  static getTextUtilities() {
    return `.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

.font-medium { font-weight: var(--font-weight-medium); }
.font-semibold { font-weight: var(--font-weight-semibold); }
.font-bold { font-weight: var(--font-weight-bold); }

.text-sm { font-size: var(--font-size-sm); }
.text-lg { font-size: var(--font-size-lg); }
.text-xl { font-size: var(--font-size-xl); }`;
  }
  static getColorUtilities() {
    return `.text-primary { color: var(--color-primary); }
.text-secondary { color: var(--color-text-secondary); }
.text-error { color: var(--color-error); }
.text-success { color: var(--color-success); }`;
  }
  static getBackgroundUtilities() {
    return `.bg-primary { background-color: var(--color-primary); }
.bg-surface { background-color: var(--color-surface); }
.bg-error { background-color: var(--color-error); }
.bg-success { background-color: var(--color-success); }`;
  }
  static getBorderUtilities() {
    return `.border { border: 1px solid var(--color-border); }
.border-primary { border-color: var(--color-primary); }
.border-error { border-color: var(--color-error); }`;
  }
  static getBorderRadiusUtilities() {
    return `.rounded { border-radius: var(--radius-base); }
.rounded-lg { border-radius: var(--radius-lg); }
.rounded-full { border-radius: var(--radius-full); }`;
  }
  static getShadowUtilities() {
    return `.shadow { box-shadow: var(--shadow-base); }
.shadow-md { box-shadow: var(--shadow-md); }
.shadow-lg { box-shadow: var(--shadow-lg); }`;
  }
  static getSpacingUtilities() {
    return `.p-1 { padding: var(--spacing-1); }
.p-2 { padding: var(--spacing-2); }
.p-3 { padding: var(--spacing-3); }
.p-4 { padding: var(--spacing-4); }
.p-5 { padding: var(--spacing-5); }
.p-6 { padding: var(--spacing-6); }

.m-1 { margin: var(--spacing-1); }
.m-2 { margin: var(--spacing-2); }
.m-3 { margin: var(--spacing-3); }
.m-4 { margin: var(--spacing-4); }
.m-5 { margin: var(--spacing-5); }
.m-6 { margin: var(--spacing-6); }

.mb-1 { margin-bottom: var(--spacing-1); }
.mb-2 { margin-bottom: var(--spacing-2); }
.mb-3 { margin-bottom: var(--spacing-3); }
.mb-4 { margin-bottom: var(--spacing-4); }
.mb-5 { margin-bottom: var(--spacing-5); }
.mb-6 { margin-bottom: var(--spacing-6); }`;
  }
  static getDisplayUtilities() {
    return `.flex { display: flex; }
.flex-col { flex-direction: column; }
.hidden { display: none; }
.block { display: block; }
.inline { display: inline; }
.inline-block { display: inline-block; }`;
  }
  static getFlexboxUtilities() {
    return `.items-center { align-items: center; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }`;
  }
  static getVisibilityUtilities() {
    return ``;
  }
}

// ../../packages/core/src/services/generators/vue/css-styles-generator.ts
class CSSStylesGenerator {
  static getBaseStyles() {
    return CSSLayoutGenerator.getBaseStyles();
  }
  static getComponentStyles() {
    return CSSLayoutGenerator.getComponentStyles();
  }
  static getUtilityClasses() {
    return CSSUtilitiesGenerator.getUtilityClasses();
  }
}
var init_css_styles_generator = () => {};

// ../../packages/core/src/services/generators/vue/css-variables-generator.ts
class CSSVariablesGenerator {
  static getCSSVariables() {
    const lightTheme = this.getLightThemeVariables();
    const darkTheme = this.getDarkThemeVariables();
    const typography = this.getTypographyVariables();
    const spacing = this.getSpacingVariables();
    const borderRadius = this.getBorderRadiusVariables();
    const shadows = this.getShadowVariables();
    const transitions = this.getTransitionVariables();
    return `:root {
  /* Colors */
  ${lightTheme}

  /* Typography */
  ${typography}

  /* Spacing */
  ${spacing}

  /* Border radius */
  ${borderRadius}

  /* Shadows */
  ${shadows}

  /* Transitions */
  ${transitions}
}

/* Dark theme */
.theme-dark {
  ${darkTheme}
}`;
  }
  static getLightThemeVariables() {
    return `--color-primary: #3498db;
  --color-secondary: #2ecc71;
  --color-accent: #e74c3c;
  --color-background: ${CSS_VALUES.BACKGROUND_LIGHT};
  --color-surface: #ffffff;
  --color-text: ${CSS_VALUES.TEXT_COLOR};
  --color-text-secondary: #666666;
  --color-border: #dddddd;
  --color-error: ${CSS_VALUES.ERROR_COLOR};
  --color-warning: #f39c12;
  --color-success: #27ae60;
  --color-info: #3498db;`;
  }
  static getDarkThemeVariables() {
    return `--color-background: #1a1a1a;
  --color-surface: #2d2d2d;
  --color-text: #ffffff;
  --color-text-secondary: #cccccc;
  --color-border: #404040;`;
  }
  static getTypographyVariables() {
    return `--font-family-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-family-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
  --font-size-2xl: 1.5rem;
  --font-size-3xl: 1.875rem;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  --line-height-tight: 1.25;
  --line-height-normal: 1.5;
  --line-height-relaxed: 1.75;`;
  }
  static getSpacingVariables() {
    return `--spacing-1: 0.25rem;
  --spacing-2: 0.5rem;
  --spacing-3: 0.75rem;
  --spacing-4: 1rem;
  --spacing-5: 1.25rem;
  --spacing-6: 1.5rem;
  --spacing-8: 2rem;
  --spacing-10: 2.5rem;
  --spacing-12: 3rem;
  --spacing-16: 4rem;
  --spacing-20: 5rem;`;
  }
  static getBorderRadiusVariables() {
    return `--radius-sm: 0.25rem;
  --radius-base: ${CSS_VALUES.BORDER_RADIUS};
  --radius-lg: 0.5rem;
  --radius-xl: 0.75rem;
  --radius-full: 9999px;`;
  }
  static getShadowVariables() {
    return `--shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-base: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);`;
  }
  static getTransitionVariables() {
    return `--transition-colors: background-color 150ms ease-in-out, border-color 150ms ease-in-out, color 150ms ease-in-out;
  --transition-transform: transform 150ms ease-in-out;
  --transition-opacity: opacity 150ms ease-in-out;`;
  }
}
var init_css_variables_generator = __esm(() => {
  init_vue_constants();
});

// ../../packages/core/src/services/generators/vue/css-generator.ts
class CSSGenerator {
  static generateMainCSS(_config) {
    const cssVariables = CSSVariablesGenerator.getCSSVariables();
    const baseStyles = CSSStylesGenerator.getBaseStyles();
    const componentStyles = CSSStylesGenerator.getComponentStyles();
    const utilityClasses = CSSStylesGenerator.getUtilityClasses();
    return `${cssVariables}

${baseStyles}

${componentStyles}

${utilityClasses}`;
  }
}
var init_css_generator = __esm(() => {
  init_css_styles_generator();
  init_css_variables_generator();
});

// ../../packages/core/src/services/generators/vue/html-generator.ts
class HTMLGenerator {
  static generateHtmlTemplate(config) {
    const head = this.getHtmlHead(config);
    const body = this.getHtmlBody(config);
    return `<!DOCTYPE html>
<html lang="en">
${head}

${body}
</html>`;
  }
  static getHtmlHead(config) {
    const metaTags = this.getMetaTags(config);
    const title = this.getTitle(config);
    return `  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    ${metaTags}
    ${title}
  </head>`;
  }
  static getMetaTags(config) {
    const viewport = this.getViewportMeta();
    const description = this.getDescriptionMeta(config);
    const themeColor = this.getThemeColorMeta();
    return `${viewport}
    ${description}
    ${themeColor}`;
  }
  static getViewportMeta() {
    return `<meta name="viewport" content="width=device-width, initial-scale=1.0" />`;
  }
  static getDescriptionMeta(config) {
    return `<meta name="description" content="${config.description || 'A modern Vue application'}" />`;
  }
  static getThemeColorMeta() {
    return `<meta name="theme-color" content="${CSS_VALUES.BACKGROUND_LIGHT}" />`;
  }
  static getTitle(config) {
    return `<title>${config.name}</title>`;
  }
  static getHtmlBody(_config) {
    return `  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>`;
  }
}
var init_html_generator = __esm(() => {
  init_vue_constants();
});

// ../../packages/core/src/services/generators/vue/vite-config-generator.ts
class ViteConfigGenerator {
  static generateViteConfig(_config) {
    const imports = this.getViteImports();
    const plugins = this.getPluginsConfig();
    const resolveConfig = this.getResolveConfig();
    const serverConfig = this.getServerConfig();
    const buildConfig = this.getBuildConfig();
    const testConfig = this.getTestConfig();
    return `${imports}

export default defineConfig({
  ${plugins},
  ${resolveConfig},
  ${serverConfig},
  ${buildConfig},
  ${testConfig},
})`;
  }
  static getViteImports() {
    return `import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'`;
  }
  static getPluginsConfig() {
    return `plugins: [vue()]`;
  }
  static getResolveConfig() {
    return `resolve: {
  alias: {
    '@': resolve(__dirname, 'src'),
  },
}`;
  }
  static getServerConfig() {
    return `server: {
  port: 3000,
  open: true,
}`;
  }
  static getBuildConfig() {
    return `build: {
  outDir: 'dist',
  sourcemap: true,
  rollupOptions: {
    output: {
      manualChunks: {
        vendor: ['vue'],
      },
    },
  },
}`;
  }
  static getTestConfig() {
    return `test: {
  globals: true,
  environment: 'jsdom',
}`;
  }
}

// ../../packages/core/src/services/generators/vue/vue-config-generators.ts
class VueConfigGenerators {
  static generateHtmlTemplate(config) {
    return HTMLGenerator.generateHtmlTemplate(config);
  }
  static generateViteConfig(config) {
    return ViteConfigGenerator.generateViteConfig(config);
  }
  static generateMainCSS(config) {
    return CSSGenerator.generateMainCSS(config);
  }
}
var init_vue_config_generators = __esm(() => {
  init_css_generator();
  init_html_generator();
});

// ../../packages/core/src/services/generators/vue/vue-structure-generator.ts
class VueStructureGenerator {
  generate(config) {
    const directories = this.createDirectories();
    const components = this.createComponentFiles(config);
    const configs = this.createConfigFiles(config);
    return [...directories, ...components, ...configs];
  }
  createDirectories() {
    return [
      { path: FILE_PATHS.COMPONENTS, type: 'directory' },
      { path: FILE_PATHS.COMPOSABLES, type: 'directory' },
      { path: FILE_PATHS.UTILS, type: 'directory' },
      { path: FILE_PATHS.PUBLIC, type: 'directory' },
    ];
  }
  createComponentFiles(config) {
    const componentName = toPascalCase(config.name);
    return [
      {
        path: FILE_PATHS.APP_VUE,
        type: 'file',
        content: VueComponentGenerators.generateVueAppComponent(config),
      },
      {
        path: `${FILE_PATHS.COMPONENTS}/${componentName}.vue`,
        type: 'file',
        content: VueComponentGenerators.generateVueMainComponent(config),
      },
      {
        path: FILE_PATHS.USE_APP_STATE,
        type: 'file',
        content: VueComposableGenerators.generateVueComposable(config),
      },
    ];
  }
  createConfigFiles(config) {
    return [
      {
        path: FILE_PATHS.INDEX_HTML,
        type: 'file',
        content: VueConfigGenerators.generateHtmlTemplate(config),
      },
      {
        path: FILE_PATHS.VITE_CONFIG,
        type: 'file',
        content: VueConfigGenerators.generateViteConfig(config),
      },
      {
        path: FILE_PATHS.INDEX_CSS,
        type: 'file',
        content: VueConfigGenerators.generateMainCSS(config),
      },
    ];
  }
}
var init_vue_structure_generator = __esm(() => {
  init_vue_component_generators();
  init_vue_composable_generators();
  init_vue_config_generators();
  init_vue_constants();
});

// ../../packages/core/src/services/generators/web/web-config-generators.ts
class WebConfigGenerators {
  generateHTMLTemplate(config) {
    const { name } = config;
    const head = this.generateHTMLHead(name);
    const body = this.generateHTMLBody();
    return `<!DOCTYPE html>
<html lang="en">
  ${head}
  ${body}
</html>
`;
  }
  generateHTMLHead(name) {
    return `<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="${name} - A modern web application" />
    <meta name="keywords" content="${name}, web, react, typescript" />
    <meta name="author" content="${name} Team" />
    <title>${name}</title>

    <!-- Preconnect to improve performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <!-- Add any additional meta tags or external resources here -->
  </head>`;
  }
  generateHTMLBody() {
    return `<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>

    <!-- Add any additional scripts here -->

    <!-- Error tracking script (uncomment when you have a tracking service) -->
    <!--
    <script>
      window.addEventListener('error', function(e) {
        // Track errors here
        console.error('Application error:', e.error);
      });
    </script>
    -->
  </body>`;
  }
  generateFavicon() {
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <text y=".9em" font-size="90">\u269B\uFE0F</text>
</svg>`;
  }
  generateViteConfig(config) {
    const { name } = config;
    return `import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],

  // Development server configuration
  server: ${this.generateServerConfig()},

  // Build configuration
  build: ${this.generateBuildConfig()},

  // Path resolution
  resolve: ${this.generateResolveConfig()},

  // Environment variables configuration
  define: ${this.generateDefineConfig(name)},

  // CSS configuration
  css: ${this.generateCssConfig()},

  // Optimization
  optimizeDeps: ${this.generateOptimizeDepsConfig()},
});
`;
  }
  generateServerConfig() {
    return `{
    port: ${DEFAULT_DEV_PORT},
    open: true,
    cors: true,

    // Proxy configuration for API calls
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
        secure: false,
      },
    },
  }`;
  }
  generateBuildConfig() {
    return `{
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          router: ['react-router-dom'],
        },
      },
    },
  }`;
  }
  generateResolveConfig() {
    return `{
    alias: {
      '@': resolve(__dirname, './src'),
      '@components': resolve(__dirname, './src/components'),
      '@pages': resolve(__dirname, './src/pages'),
      '@hooks': resolve(__dirname, './src/hooks'),
      '@utils': resolve(__dirname, './src/utils'),
      '@styles': resolve(__dirname, './src/styles'),
      '@assets': resolve(__dirname, './src/assets'),
    },
  }`;
  }
  generateDefineConfig(appName) {
    return `{
    __APP_VERSION__: JSON.stringify(process.env.npm_package_version),
    __APP_NAME__: JSON.stringify('${appName}'),
  }`;
  }
  generateCssConfig() {
    return `{
    modules: {
      localsConvention: 'camelCase',
    },
  }`;
  }
  generateOptimizeDepsConfig() {
    return `{
    include: ['react', 'react-dom', 'react-router-dom'],
  }`;
  }
}
var init_web_config_generators = __esm(() => {
  init_validation_constants();
});

// ../../packages/core/src/services/generators/web/modules/app-types-generator.ts
function generateAppTypes(_config) {
  const header = getAppTypesHeader();
  const stateTypes = getStateTypes();
  const navigationTypes = getNavigationTypes();
  const apiTypes = getApiTypes();
  const formTypes = getFormTypes();
  const themeTypes = getThemeTypes();
  const componentTypes = getComponentTypes();
  const environmentTypes = getEnvironmentTypes();
  return `${header}

${stateTypes}

${navigationTypes}

${apiTypes}

${formTypes}

${themeTypes}

${componentTypes}

${environmentTypes}`;
}
function getAppTypesHeader() {
  return `/**
 * Application-wide type definitions
 */`;
}
function getStateTypes() {
  return `// Global app state types
export interface AppState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

export interface User {
  id: string;
  name: string;
  email: string;
  avatar?: string;
}`;
}
function getNavigationTypes() {
  return `// Navigation types
export interface NavigationItem {
  id: string;
  label: string;
  path: string;
  icon?: string;
  children?: NavigationItem[];
}`;
}
function getApiTypes() {
  return `// API response types
export interface ApiResponse<T = any> {
  data: T;
  message: string;
  status: 'success' | 'error';
}

export interface PaginatedResponse<T> extends ApiResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}`;
}
function getFormTypes() {
  return `// Form types
export interface FormField {
  name: string;
  label: string;
  type: 'text' | 'email' | 'password' | 'textarea' | 'select';
  required?: boolean;
  placeholder?: string;
  options?: Array<{ value: string; label: string }>;
}

export interface FormState {
  values: Record<string, any>;
  errors: Record<string, string>;
  touched: Record<string, boolean>;
  isSubmitting: boolean;
}`;
}
function getThemeTypes() {
  return `// Theme types
export interface Theme {
  colors: {
    primary: string;
    secondary: string;
    background: string;
    surface: string;
    text: string;
    error: string;
    warning: string;
    success: string;
  };
  spacing: {
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
  };
  breakpoints: {
    mobile: string;
    tablet: string;
    desktop: string;
  };
}`;
}
function getComponentTypes() {
  return `// Component prop types
export interface BaseComponentProps {
  className?: string;
  children?: React.ReactNode;
  testId?: string;
}

export interface ButtonProps extends BaseComponentProps {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  onClick?: () => void;
}`;
}
function getEnvironmentTypes() {
  return `// Environment types
export interface Environment {
  API_BASE_URL: string;
  APP_VERSION: string;
  NODE_ENV: 'development' | 'production' | 'test';
}`;
}

// ../../packages/core/src/services/generators/web/modules/dom-utils-generator.ts
function generateDOMUtils(_config) {
  return `${generateDOMUtilityFunctions()}${generateViewportFunctions()}${generateStyleFunctions()}${generateEventFunctions()}${generateClipboardFunctions()}${generateScrollbarFunctions()}${generatePerformanceFunctions()}`;
}
function generateDOMUtilityFunctions() {
  return `/**
 * DOM utility functions
 */

/**
 * Wait for DOM to be ready
  * @param {string} callback - Function to execute when DOM is ready
 */
export const domReady = (callback: () => void): void => {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', callback);
  } else {
    callback();
  }
};

`;
}
function generateViewportFunctions() {
  return `/**
 * Check if element is in viewport
  * @param {string} element - Element to check
  * @returns {boolean} if element is in viewport
 */
export const isInViewport = (element: Element): boolean => {
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
};

/**
 * Smooth scroll to element
  * @param {string} element - Element to scroll to
  * @param {string} offset - Offset from top (default: 0)
 */
export const scrollToElement = (element: Element, offset: number = 0): void => {
  const elementPosition = element.getBoundingClientRect().top;
  const offsetPosition = elementPosition + window.pageYOffset - offset;

  window.scrollTo({
    top: offsetPosition,
    behavior: 'smooth'
  });
};

`;
}
function generateStyleFunctions() {
  return `/**
 * Get element's computed style
  * @param {string} element - Element to get style from
  * @param {string} property - CSS property to get
  * @returns {string} CSS property value
 */
export const getComputedStyle = (
  element: Element,
  property: string
): string => {
  return window.getComputedStyle(element).getPropertyValue(property);
};

`;
}
function generateEventFunctions() {
  return `${generateEventListenerFunction()}${generatePortalContainerFunction()}`;
}
function generateEventListenerFunction() {
  return `/**
 * Add event listener with automatic cleanup
  * @param {string} element - Element to add listener to
  * @param {string} event - Event type
  * @param {string} handler - Event handler
  * @param {string} options - Event listener options
  * @returns {string} Cleanup function
 */
export const addEventListenerWithCleanup = <T extends EventTarget>(
  element: T,
  event: string,
  handler: EventListener,
  options?: boolean | AddEventListenerOptions
): (() => void) => {
  element.addEventListener(event, handler, options);

  return () => {
    element.removeEventListener(event, handler, options);
  };
};

`;
}
function generatePortalContainerFunction() {
  return `/**
 * Create portal container
  * @param {string} id - Container ID
  * @returns {string} Container element
 */
export const createPortalContainer = (id: string): HTMLElement => {
  let container = document.getElementById(id);

  if (!container) {
    container = document.createElement('div');
    container.id = id;
    document.body.appendChild(container);
  }

  return container;
};

`;
}
function generateClipboardFunctions() {
  return `/**
 * Copy text to clipboard
  * @param {string} text - Text to copy
  * @returns {Promise<void>} that resolves when text is copied
 */
export const copyToClipboard = async (text: string): Promise<void> => {
  try {
    await navigator.clipboard.writeText(text);
  } catch (err) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
  }
};

`;
}
function generateScrollbarFunctions() {
  return `/**
 * Check if element has scrollbar
 * @param {string} element - Element to check
 * @returns {boolean} if element has scrollbar
 */
export const hasScrollbar = (element: Element): boolean => {
  return element.scrollHeight > element.clientHeight;
};

/**
 * Get scrollbar width
 * @returns {string} Scrollbar width in pixels
 */
export const getScrollbarWidth = (): number => {
  const outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll';
  document.body.appendChild(outer);

  const inner = document.createElement('div');
  outer.appendChild(inner);

  const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
  outer.parentNode?.removeChild(outer);

  return scrollbarWidth;
};

`;
}
function generatePerformanceFunctions() {
  return `${generateDebounceFunction()}${generateThrottleFunction()}`;
}
function generateDebounceFunction() {
  return `/**
 * Debounce function
  * @param {string} func - Function to debounce
  * @param {string} delay - Delay in milliseconds
  * @returns {string} Debounced function
 */
export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  delay: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;

  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), delay);
  };
};

`;
}
function generateThrottleFunction() {
  return `/**
 * Throttle function
  * @param {string} func - Function to throttle
  * @param {string} limit - Time limit in milliseconds
  * @returns {string} Throttled function
 */
export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;

  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
};
`;
}

// ../../packages/core/src/services/generators/web/modules/main-entry-generator.ts
function generateMainEntry(_config) {
  const imports = getImports();
  const rootElementCode = getRootElementCode();
  const renderCode = getRenderCode();
  const productionCode = getProductionFeatures();
  const devCode = getDevelopmentFeatures();
  const errorHandling = getErrorHandling();
  return `${imports}

${rootElementCode}

${renderCode}

${productionCode}

${devCode}

${errorHandling}
`;
}
function getImports() {
  return `import React from 'react';
import { createRoot } from 'react-dom/client';
import { App } from './app';
import { registerServiceWorker } from './utils/service-worker';
import { reportWebVitals } from './utils/web-vitals';
import './styles/main.css';`;
}
function getRootElementCode() {
  return `// Find the root element
const rootElement = document.getElementById('root');

if (!rootElement) {
  throw new Error('Root element not found');
}

// Create React root
const root = createRoot(rootElement);`;
}
function getRenderCode() {
  return `// Render the app
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);`;
}
function getProductionFeatures() {
  return `// Register service worker for production
if (import.meta.env.PROD) {
  registerServiceWorker();
}

// Report web vitals
reportWebVitals(console.log);`;
}
function getDevelopmentFeatures() {
  return `// Hot module replacement
if (import.meta.env.DEV) {
  import.meta.hot?.accept();
}`;
}
function getErrorHandling() {
  return `// Error boundary setup
window.addEventListener('error', (event) => {
  console.error('Application error:', event.error);
  // You can send this to an error tracking service
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  // You can send this to an error tracking service
});`;
}

// ../../packages/core/src/services/generators/web/web-entry-generators.ts
class WebEntryGenerators {
  generateMainEntry(config) {
    return generateMainEntry(config);
  }
  generateAppTypes(config) {
    return generateAppTypes(config);
  }
  generateDOMUtils(config) {
    return generateDOMUtils(config);
  }
}
var init_web_entry_generators = () => {};

// ../../packages/core/src/services/generators/web/modules/about-page-generator.ts
function generateAboutPage(config) {
  const { name } = config;
  const imports = getAboutPageImports();
  const component = getAboutPageComponent(name);
  const defaultExport = getAboutPageDefaultExport();
  return `${imports}

${component}

${defaultExport}`;
}
function getAboutPageImports() {
  return `import React from 'react';
import { Layout } from '../components/layout';
import styles from './about-page.module.css';`;
}
function getAboutPageComponent(name) {
  const header = getAboutPageHeader(name);
  const main = getAboutPageMain(name);
  return `export const AboutPage: React.FC = () => {
  return (
    <Layout>
      <div className={styles.aboutPage}>
        ${header}

        ${main}
      </div>
    </Layout>
  );
};`;
}
function getAboutPageHeader(name) {
  return `<header className={styles.header}>
          <h1>About ${name}</h1>
          <p>Learn more about our project and team</p>
        </header>`;
}
function getAboutPageMain(name) {
  const missionSection = getMissionSection(name);
  const technologiesSection = getTechnologiesSection();
  const contactSection = getContactSection();
  return `<main className={styles.main}>
          ${missionSection}

          ${technologiesSection}

          ${contactSection}
        </main>`;
}
function getMissionSection(name) {
  return `<section className={styles.section}>
            <h2>Our Mission</h2>
            <p>
              ${name} is dedicated to providing exceptional web experiences
              through modern technologies and best practices.
            </p>
          </section>`;
}
function getTechnologiesSection() {
  return `<section className={styles.section}>
            <h2>Technologies</h2>
            <ul>
              <li>React 18 with TypeScript</li>
              <li>Modern CSS with modules</li>
              <li>Build tools with Vite</li>
              <li>Testing with Jest and React Testing Library</li>
            </ul>
          </section>`;
}
function getContactSection() {
  return `<section className={styles.section}>
            <h2>Get in Touch</h2>
            <p>
              Have questions or feedback? We'd love to hear from you.
              Visit our contact page or reach out through our channels.
            </p>
          </section>`;
}
function getAboutPageDefaultExport() {
  return `export default AboutPage;`;
}

// ../../packages/core/src/services/generators/web/modules/contact-page-generators.ts
function generateContactPageImports() {
  return `import React, { useState, useRef, useEffect } from 'react';
import { Layout } from '../components/layout';
import styles from './contact-page.module.css';`;
}
function generateContactPageInterfaces() {
  return `interface ContactFormData {
  name: string;
  email: string;
  subject: string;
  message: string;
}

interface FormStatus {
  type: 'success' | 'error' | null;
  message: string;
}`;
}
function generateContactPageComponent(projectName) {
  return `${generateContactPageComponentStart(projectName)}${generateContactPageStateManagement()}${generateContactPageEventHandlers()}${generateContactPageJSX(projectName)}${generateContactPageComponentEnd()}`;
}
function generateContactPageComponentStart(_projectName) {
  return `export const ContactPage: React.FC = () => {
  const [formData, setFormData] = useState<ContactFormData>({
    name: '',
    email: '',
    subject: '',
    message: ''
  });

  const [formStatus, setFormStatus] = useState<FormStatus>({ type: null, message: '' });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const formRef = useRef<HTMLFormElement>(null);

`;
}
function generateContactPageEventHandlers() {
  return `${generateInputChangeHandler()}${generateFormValidationHandler()}${generateFormSubmitHandler()}

`;
}
function generateContactPageStateManagement() {
  return `  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

`;
}
function generateInputChangeHandler() {
  return ``;
}
function generateFormValidationHandler() {
  return `  const validateForm = (): boolean => {
    if (!formData.name.trim() || !formData.email.trim() || !formData.message.trim()) {
      setFormStatus({ type: 'error', message: 'Please fill in all required fields.' });
      return false;
    }

    if (!formData.email.includes('@')) {
      setFormStatus({ type: 'error', message: 'Please enter a valid email address.' });
      return false;
    }

    return true;
  };

`;
}
function generateFormSubmitHandler() {
  return `  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validateForm()) return;

    setIsSubmitting(true);
    setFormStatus({ type: null, message: '' });

    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));

      setFormStatus({
        type: 'success',
        message: 'Thank you for your message! We\\'ll get back to you soon.'
      });
      setFormData({ name: '', email: '', subject: '', message: '' });

      if (formRef.current) {
        formRef.current.reset();
      }
    } catch (error) {
      setFormStatus({
        type: 'error',
        message: 'An error occurred. Please try again later.'
      });
    } finally {
      setIsSubmitting(false);
    }
  };`;
}
function generateContactPageJSX(projectName) {
  return `  return (
    <Layout title=\`Contact ${projectName}\`>
      ${generateContactPageHeader()}${generateContactPageContent(projectName)}${generateContactPageForm()}
    </Layout>
  );`;
}
function generateContactPageHeader() {
  return `<div className={styles.contactContainer}>
        <div className={styles.contactHeader}>
          <h1>Contact Us</h1>
          <p>We'd love to hear from you. Send us a message and we'll respond as soon as possible.</p>
        </div>
`;
}
function generateContactPageContent(projectName) {
  return `<div className={styles.contactContent}>
          <div className={styles.contactInfo}>
            <h2>Get in Touch</h2>
            ${generateContactInfoItems(projectName)}
          </div>
`;
}
function generateContactInfoItems(projectName) {
  return `<div className={styles.contactItem}>
              <h3>Email</h3>
              <p>hello@${projectName.toLowerCase().replace(/\\s+/g, '')}.com</p>
            </div>
            <div className={styles.contactItem}>
              <h3>Address</h3>
              <p>123 Business Street<br />Suite 100<br />City, State 12345</p>
            </div>
            <div className={styles.contactItem}>
              <h3>Phone</h3>
              <p>(555) 123-4567</p>
            </div>`;
}
function generateContactPageForm() {
  return `<form ref={formRef} onSubmit={handleSubmit} className={styles.contactForm}>
            ${generateFormFields()}${generateFormStatus()}${generateSubmitButton()}
          </form>
        </div>
      </div>`;
}
function generateFormFields() {
  return `${generateFormField('name', 'text', 'Name *', true)}${generateFormField('email', 'email', 'Email *', true)}${generateFormField('subject', 'text', 'Subject', false)}${generateTextAreaField('message', 'Message *', true)}`;
}
function generateFormField(name, type, label, required) {
  return `<div className={styles.formGroup}>
              <label htmlFor="${name}">${label}</label>
              <input
                type="${type}"
                id="${name}"
                name="${name}"
                value={formData.${name}}
                onChange={handleInputChange}
                ${required ? 'required' : ''}
              />
            </div>
`;
}
function generateTextAreaField(name, label, required) {
  return `<div className={styles.formGroup}>
              <label htmlFor="${name}">${label}</label>
              <textarea
                id="${name}"
                name="${name}"
                value={formData.${name}}
                onChange={handleInputChange}
                ${required ? 'required' : ''}
                rows={6}
              />
            </div>
`;
}
function generateFormStatus() {
  return `{formStatus.type && (
              <div className={\`\${styles.formStatus} \${styles[\`formStatus--\${formStatus.type}\`]}\`}>
                {formStatus.message}
              </div>
            )}`;
}
function generateSubmitButton() {
  return `<button
              type="submit"
              disabled={isSubmitting}
              className={styles.submitButton}
            >
              {isSubmitting ? 'Sending...' : 'Send Message'}
            </button>`;
}
function generateContactPageComponentEnd() {
  return `
  };
`;
}
function generateContactPageExports() {
  return `export default ContactPage;`;
}

// ../../packages/core/src/services/generators/web/web-page-generators.ts
class WebPageGenerators {
  generateAboutPage(config) {
    return generateAboutPage(config);
  }
  generateContactPage(config) {
    const { name } = config;
    const imports = generateContactPageImports();
    const interfaces = generateContactPageInterfaces();
    const component = generateContactPageComponent(name);
    const exports = generateContactPageExports();
    return [imports, interfaces, component, exports].join(`

`);
  }
}
var init_web_page_generators = () => {};

// ../../packages/core/src/services/generators/web/components/app-component-generator.ts
class AppComponentGenerator {
  generate(config) {
    const imports = this.getImports();
    const interfaces = this.getInterfaces();
    const component = this.getComponent(config);
    const defaultExport = this.getDefaultExport();
    return `${imports}

${interfaces}

${component}

${defaultExport}`;
  }
  getImports() {
    return `import { useState, useEffect } from 'react';
import { Router } from './router.js';
import { Layout } from './layout.js';
import { useAppState } from '../hooks/use-app-state.js';
import '../styles/main.css';`;
  }
  getInterfaces() {
    return `interface AppConfig {
  debug?: boolean;
  routes?: Record<string, () => Promise<React.ComponentType>>;
}`;
  }
  getComponent(config) {
    const { name } = config;
    const componentLogic = this.getComponentLogic(name);
    const loadingState = this.getLoadingState(name);
    const mainContent = this.getMainContent();
    return `/**
 * Main application component
 */
export function App() {
${componentLogic}

${loadingState}

${mainContent}
}`;
  }
  getComponentLogic(_name) {
    return `  const { state, loading, notifications, setTheme } = useAppState();
  const [router] = useState(() => new Router({
    debug: import.meta.env.DEV,
  }));

  useEffect(() => {
    // Initialize router
    router.setupRouting();
    router.setupErrorHandling();

    // Apply theme
    if (state.theme) {
      setTheme(state.theme);
    }
  }, [router, state.theme, setTheme]);`;
  }
  getLoadingState(name) {
    return `  if (loading) {
    return (
      <div className="app-loading">
        <div className="loading-spinner" />
        <p>Loading ${name}...</p>
      </div>
    );
  }`;
  }
  getMainContent() {
    return `  return (
    <div className="app" data-theme={state.theme}>
      <Layout>
        <Router />

        {/* Notifications */}
        {notifications.length > 0 && (
          <div className="notifications">
            {notifications.map((notification) => (
              <div
                key={notification.id}
                className={\`notification notification--\${notification.type}\`}
              >
                {notification.message}
                <button
                  onClick={() => {/* Handle notification removal */}}
                  className="notification__close"
                >
                  \xD7
                </button>
              </div>
            ))}
          </div>
        )}
      </Layout>
    </div>
  );`;
  }
  getDefaultExport() {
    return `export default App;`;
  }
}

// ../../packages/core/src/services/generators/web/components/home-page-generator.ts
class HomePageGenerator {
  generate(config) {
    const { name, description } = config;
    const imports = this.getImports();
    const homePageComponent = this.getComponent(name, description);
    const homePageHook = this.getHook();
    const defaultExport = this.getDefaultExport();
    return `${imports}

${homePageComponent}

${homePageHook}

${defaultExport}`;
  }
  getImports() {
    return `import { useState, useEffect } from 'react';`;
  }
  getComponent(name, description) {
    const componentLogic = this.getLogic(name, description);
    const heroSection = this.getHeroSection();
    const featuresSection = this.getFeaturesSection();
    return `/**
 * Home page component
 */
export function HomePage() {
${componentLogic}

  return (
    <div className="home-page">
      ${heroSection}

      ${featuresSection}
    </div>
  );
}`;
  }
  getLogic(name, description) {
    return `  const [message, setMessage] = useState('Welcome to ${name}!');

  useEffect(() => {
    // Simulate API call or data fetching
    const timer = setTimeout(() => {
      setMessage('${description || 'A modern web application built with best practices'}');
    }, 1000);

    return () => clearTimeout(timer);
  }, []);`;
  }
  getHeroSection() {
    return `<section className="hero">
        <div className="hero__content">
          <h1 className="hero__title">{message}</h1>
          <p className="hero__description">
            Get started with your new project in seconds.
          </p>
          <div className="hero__actions">
            <button className="btn btn--primary">
              Get Started
            </button>
            <button className="btn btn--secondary">
              Learn More
            </button>
          </div>
        </div>
      </section>`;
  }
  getFeaturesSection() {
    return `<section className="features">
        <h2>Features</h2>
        <div className="features__grid">
          <div className="feature-card">
            <h3>\u26A1 Fast Performance</h3>
            <p>Optimized for speed and efficiency.</p>
          </div>
          <div className="feature-card">
            <h3>\uD83C\uDFA8 Modern Design</h3>
            <p>Clean, responsive, and accessible UI.</p>
          </div>
          <div className="feature-card">
            <h3>\uD83D\uDEE0\uFE0F Developer Friendly</h3>
            <p>Built with modern tools and best practices.</p>
          </div>
        </div>
      </section>`;
  }
  getHook() {
    return `/**
 * Home page lifecycle hooks
 */
export function useHomePage() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
    console.log('Home page mounted');

    return () => {
      console.log('Home page unmounted');
    };
  }, []);

  return { mounted };
}`;
  }
  getDefaultExport() {
    return `export default HomePage;`;
  }
}

// ../../packages/core/src/services/generators/web/components/layout-component-generator.ts
class LayoutComponentGenerator {
  generate(config) {
    const { name } = config;
    const imports = this.getImports();
    const interfaces = this.getInterfaces();
    const layoutComponent = this.getComponent(name);
    const serverLayout = this.getServerLayout(name);
    return `${imports}

${interfaces}

${layoutComponent}

${serverLayout}`;
  }
  getImports() {
    return `import type { ReactNode } from 'react';`;
  }
  getInterfaces() {
    return `interface LayoutProps {
  children: ReactNode;
}

/**
 * Simple layout interface for server-side rendering
 */
export interface LayoutInterface {
  render(pageContent: string): string;
}`;
  }
  getComponent(name) {
    return `/**
 * Layout component wrapper
 */
export function Layout({ children }: LayoutProps) {
  return (
    <div className="layout">
      <header className="layout__header">
        ${this.getNavbar(name)}
      </header>

      <main className="layout__main">
        {children}
      </main>

      ${this.getFooter(name)}
    </div>
  );
}`;
  }
  getNavbar(name) {
    return `<nav className="navbar">
          <div className="navbar__brand">
            <h1>${name}</h1>
          </div>
          <div className="navbar__nav">
            <a href="/" className="nav-link">Home</a>
            <a href="/about" className="nav-link">About</a>
            <a href="/contact" className="nav-link">Contact</a>
          </div>
        </nav>`;
  }
  getFooter(name) {
    return `<footer className="layout__footer">
        <p>&copy; 2024 ${name}. All rights reserved.</p>
      </footer>`;
  }
  getServerLayout(name) {
    const constructor = this.getServerLayoutConstructor();
    const renderMethod = this.getServerLayoutRenderMethod(name);
    return `/**
 * Server-side layout renderer
 */
export class ServerLayout implements LayoutInterface {
${constructor}

${renderMethod}
}`;
  }
  getServerLayoutConstructor() {
    return `  constructor(private config: { title?: string }) {}`;
  }
  getServerLayoutRenderMethod(name) {
    return [
      this.getRenderMethodSignature(),
      this.getHtmlHeadSection(name),
      this.getHtmlBodySection(name),
      this.getRenderMethodEnd(),
    ].join(`
`);
  }
  getRenderMethodSignature() {
    return `  render(pageContent: string): string {`;
  }
  getHtmlHeadSection(name) {
    return `    return \`
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>\${this.config.title || '${name}'}</title>
  <link rel="stylesheet" href="/styles/main.css">
</head>`;
  }
  getHtmlBodySection(name) {
    return `<body>
  <div class="layout">
    ${this.getServerLayoutHeader(name)}
    ${this.getServerLayoutMain()}
    ${this.getServerLayoutFooter(name)}
  </div>
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>`;
  }
  getServerLayoutHeader(name) {
    return `<header class="layout__header">
      <nav class="navbar">
        <div class="navbar__brand">
          <h1>${name}</h1>
        </div>
      </nav>
    </header>`;
  }
  getServerLayoutMain() {
    return `<main class="layout__main">
      \${pageContent}
    </main>`;
  }
  getServerLayoutFooter(name) {
    return `<footer class="layout__footer">
      <p>&copy; 2024 ${name}. All rights reserved.</p>
    </footer>`;
  }
  getRenderMethodEnd() {
    return `    \`.trim();
  }`;
  }
}

// ../../packages/core/src/services/generators/web/components/component-generator.ts
class ComponentGenerator {
  appGenerator;
  layoutGenerator;
  homePageGenerator;
  constructor() {
    this.appGenerator = new AppComponentGenerator();
    this.layoutGenerator = new LayoutComponentGenerator();
    this.homePageGenerator = new HomePageGenerator();
  }
  generateAppComponent(config) {
    return this.appGenerator.generate(config);
  }
  generateLayoutComponent(config) {
    return this.layoutGenerator.generate(config);
  }
  generateHomePage(config) {
    return this.homePageGenerator.generate(config);
  }
}
var init_component_generator = () => {};

// ../../packages/core/src/services/generators/web/hooks/api-hooks-generator.ts
class ApiHooksGenerator {
  generateApiHooks(_config) {
    const imports = this.generateApiImports();
    const interfaces = this.generateApiInterfaces();
    const apiHook = this.generateApiHook();
    return `${imports}

${interfaces}

${apiHook}`;
  }
  generateApiImports() {
    return `import { useState, useEffect, useCallback, useRef } from 'react';`;
  }
  generateApiInterfaces() {
    return `interface ApiState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  lastFetched: Date | null;
}

interface ApiOptions {
  immediate?: boolean;
  retryCount?: number;
  retryDelay?: number;
}`;
  }
  generateApiHook() {
    const hookDeclaration = this.generateApiHookDeclaration();
    const coreLogic = this.generateApiCoreLogic();
    const executeFunction = this.generateApiExecuteFunction();
    const resetFunction = this.generateApiResetFunction();
    const returnValue = this.generateApiReturnValue();
    return `/**
 * Generic API hook for data fetching
 */
export function useApi<T>(
  apiCall: () => Promise<T>,
  options: ApiOptions = {}
) {
${hookDeclaration}

${coreLogic}

${executeFunction}

${resetFunction}

${returnValue}
}`;
  }
  generateApiHookDeclaration() {
    return `  const [state, setState] = useState<ApiState<T>>({
    data: null,
    loading: false,
    error: null,
    lastFetched: null,
  });

  const { immediate = false, retryCount = 0, retryDelay = 1000 } = options;
  const retryCountRef = useRef(0);
  const mountedRef = useRef(true);`;
  }
  generateApiCoreLogic() {
    return [
      this.getExecuteFunctionStart(),
      this.getApiSuccessHandling(),
      this.getApiErrorHandling(),
      this.getExecuteFunctionEnd(),
    ].join(`
`);
  }
  getExecuteFunctionStart() {
    return `  const execute = useCallback(async () => {
    if (!mountedRef.current) return;

    setState(prev => ({ ...prev, loading: true, error: null }));`;
  }
  getApiSuccessHandling() {
    return `    try {
      const data = await apiCall();

      if (mountedRef.current) {
        setState({
          data,
          loading: false,
          error: null,
          lastFetched: new Date(),
        });
        retryCountRef.current = 0;
      }`;
  }
  getApiErrorHandling() {
    return `    } catch (error) {
      if (mountedRef.current) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';

        if (retryCountRef.current < retryCount) {
          retryCountRef.current++;
          setTimeout(execute, retryDelay * retryCountRef.current);
        } else {
          setState(prev => ({
            ...prev,
            loading: false,
            error: errorMessage,
          }));
        }
      }
    }`;
  }
  getExecuteFunctionEnd() {
    return `  }, [apiCall, retryCount, retryDelay]);`;
  }
  generateApiExecuteFunction() {
    return `  const executeWithRetry = useCallback(() => {
    retryCountRef.current = 0;
    execute();
  }, [execute]);`;
  }
  generateApiResetFunction() {
    return `  const reset = useCallback(() => {
    if (mountedRef.current) {
      setState({
        data: null,
        loading: false,
        error: null,
        lastFetched: null,
      });
      retryCountRef.current = 0;
    }
  }, []);`;
  }
  generateApiReturnValue() {
    return `  useEffect(() => {
    if (immediate) {
      execute();
    }

    return () => {
      mountedRef.current = false;
    };
  }, [immediate, execute]);

  return {
    ...state,
    execute: executeWithRetry,
    reset,
    refetch: executeWithRetry,
  };`;
  }
}

// ../../packages/core/src/services/generators/web/hooks/router-hooks-generator.ts
class RouterHooksGenerator {
  generateRouterHooks(_config) {
    const imports = this.generateRouterImports();
    const interfaces = this.generateRouterInterfaces();
    const routerHook = this.generateRouterHook();
    return `${imports}

${interfaces}

${routerHook}`;
  }
  generateRouterImports() {
    return `import { useState, useEffect, useCallback } from 'react';`;
  }
  generateRouterInterfaces() {
    return `interface Route {
  path: string;
  component: React.ComponentType;
  exact?: boolean;
}

interface RouterState {
  currentPath: string;
  params: Record<string, string>;
  query: Record<string, string>;
  isNavigating: boolean;
}`;
  }
  generateRouterHook() {
    const hookDeclaration = this.generateRouterHookDeclaration();
    const navigationLogic = this.generateNavigationLogic();
    const eventHandlers = this.generateRouterEventHandlers();
    const effects = this.generateRouterEffects();
    return `/**
 * Simple router hook for client-side routing
 */
export function useRouter(routes: Route[] = []) {
${hookDeclaration}

${navigationLogic}

${eventHandlers}

${effects}

  return {
    currentPath: state.currentPath,
    params: state.params,
    query: state.query,
    isNavigating: state.isNavigating,
    navigate,
    goBack,
    goForward,
  };
}`;
  }
  generateRouterHookDeclaration() {
    return `  const [state, setState] = useState<RouterState>(() => ({
    currentPath: typeof window !== 'undefined' ? window.location.pathname : '/',
    params: {},
    query: {},
    isNavigating: false,
  }));`;
  }
  generateNavigationLogic() {
    return [this.getNavigateFunction(), this.getGoBackFunction(), this.getGoForwardFunction()]
      .join(`

`);
  }
  getNavigateFunction() {
    return [
      this.getNavigateFunctionStart(),
      this.getNavigateHistoryHandling(),
      this.getUrlParsing(),
      this.getRouteMatching(),
      this.getNavigateFunctionEnd(),
    ].join(`
`);
  }
  getNavigateFunctionStart() {
    return `  const navigate = useCallback((path: string, replace = false) => {
    setState(prev => ({ ...prev, isNavigating: true }));`;
  }
  getNavigateHistoryHandling() {
    return `    if (typeof window !== 'undefined') {
      if (replace) {
        window.history.replaceState(null, '', path);
      } else {
        window.history.pushState(null, '', path);
      }
    }`;
  }
  getUrlParsing() {
    return `    // Parse URL
    const url = new URL(path, typeof window !== 'undefined' ? window.location.origin : 'http://localhost');
    const params: Record<string, string> = {};
    const query: Record<string, string> = {};

    // Extract query parameters
    url.searchParams.forEach((value, key) => {
      query[key] = value;
    });`;
  }
  getRouteMatching() {
    return `    // Find matching route and extract params
    const matchedRoute = routes.find(route => {
      const routePattern = route.path
        .replace(/:[^/]+/g, '([^/]+)')
        .replace(/*/g, '.*');
      const regex = new RegExp(\`^\${routePattern}$\`);
      const match = path.match(regex);

      if (match) {
        const paramKeys = (route.path.match(/:[^/]+/g) || [])
          .map(key => key.substring(1));
        paramKeys.forEach((key, index) => {
          params[key] = match[index + 1];
        });
        return true;
      }
      return false;
    });`;
  }
  getNavigateFunctionEnd() {
    return `    setState(prev => ({
      ...prev,
      currentPath: path,
      params,
      query,
      isNavigating: false,
    }));
  }, [routes]);`;
  }
  getGoBackFunction() {
    return `  const goBack = useCallback(() => {
    if (typeof window !== 'undefined') {
      window.history.back();
    }
  }, []);`;
  }
  getGoForwardFunction() {
    return `  const goForward = useCallback(() => {
    if (typeof window !== 'undefined') {
      window.history.forward();
    }
  }, []);`;
  }
  generateRouterEventHandlers() {
    return `  const handlePopState = useCallback(() => {
    if (typeof window !== 'undefined') {
      navigate(window.location.pathname, true);
    }
  }, [navigate]);`;
  }
  generateRouterEffects() {
    return `  useEffect(() => {
    if (typeof window !== 'undefined') {
      window.addEventListener('popstate', handlePopState);
      return () => window.removeEventListener('popstate', handlePopState);
    }
  }, [handlePopState]);`;
  }
}

// ../../packages/core/src/services/generators/web/hooks/utility-hooks-generator.ts
class UtilityHooksGenerator {
  generateUtilityHooks(_config) {
    const imports = this.generateUtilityImports();
    const localStorageHook = this.generateLocalStorageHook();
    const debounceHook = this.generateDebounceHook();
    const windowSizeHook = this.generateWindowSizeHook();
    return `${imports}

${localStorageHook}

${debounceHook}

${windowSizeHook}`;
  }
  generateUtilityImports() {
    return `import { useState, useEffect, useCallback, useRef } from 'react';`;
  }
  generateLocalStorageHook() {
    const hookDeclaration = this.generateLocalStorageHookDeclaration();
    const coreLogic = this.generateLocalStorageLogic();
    const returnValue = this.generateLocalStorageReturnValue();
    return `/**
 * localStorage hook with SSR safety
 */
export function useLocalStorage<T>(key: string, initialValue: T) {
${hookDeclaration}

${coreLogic}

${returnValue}
}`;
  }
  generateLocalStorageHookDeclaration() {
    return `  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(\`Error reading localStorage key "\${key}":\`, error);
      return initialValue;
    }
  });`;
  }
  generateLocalStorageLogic() {
    return `  const setValue = useCallback((value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(\`Error setting localStorage key "\${key}":\`, error);
    }
  }, [key, storedValue]);

  const removeValue = useCallback(() => {
    try {
      window.localStorage.removeItem(key);
      setStoredValue(initialValue);
    } catch (error) {
      console.error(\`Error removing localStorage key "\${key}":\`, error);
    }
  }, [key, initialValue]);`;
  }
  generateLocalStorageReturnValue() {
    return `  return [storedValue, setValue, removeValue] as const;`;
  }
  generateDebounceHook() {
    const hookDeclaration = this.generateDebounceHookDeclaration();
    const effect = this.generateDebounceEffect();
    return `/**
 * Debounce hook for values and callbacks
 */
export function useDebounce<T>(value: T, delay: number): T {
${hookDeclaration}

${effect}

  return debouncedValue;
}`;
  }
  generateDebounceHookDeclaration() {
    return `  const [debouncedValue, setDebouncedValue] = useState<T>(value);`;
  }
  generateDebounceEffect() {
    return `  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);`;
  }
  generateWindowSizeHook() {
    const hookDeclaration = this.generateWindowSizeHookDeclaration();
    const effect = this.generateWindowSizeEffect();
    return `/**
 * Window size hook with debounced updates
 */
export function useWindowSize() {
${hookDeclaration}

${effect}

  return windowSize;
}`;
  }
  generateWindowSizeHookDeclaration() {
    return `  const [windowSize, setWindowSize] = useState({
    width: typeof window !== 'undefined' ? window.innerWidth : 0,
    height: typeof window !== 'undefined' ? window.innerHeight : 0,
  });`;
  }
  generateWindowSizeEffect() {
    return `  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // Call initially

    return () => window.removeEventListener('resize', handleResize);
  }, []);`;
  }
}

// ../../packages/core/src/services/generators/web/hooks/hook-generator.ts
class HookGenerator {
  utilityHooksGenerator = new UtilityHooksGenerator();
  apiHooksGenerator = new ApiHooksGenerator();
  routerHooksGenerator = new RouterHooksGenerator();
  generateAppStateHook(_config) {
    const imports = this.generateHookImports();
    const interfaces = this.generateAppStateInterfaces();
    const appStateHook = this.generateMainAppStateHook();
    return `${imports}

${interfaces}

${appStateHook}`;
  }
  generateHookImports() {
    return `import { useState, useEffect, useCallback, useRef } from 'react';`;
  }
  generateAppStateInterfaces() {
    return `interface AppState {
  user: User | null;
  theme: 'light' | 'dark';
  loading: boolean;
  error: string | null;
  notifications: Notification[];
}

interface User {
  id: string;
  name: string;
  email: string;
}

interface Notification {
  id: string;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  timestamp: Date;
  read: boolean;
}`;
  }
  generateMainAppStateHook() {
    const hookDeclaration = this.generateAppStateHookDeclaration();
    const coreLogic = this.generateAppStateCoreLogic();
    const notificationLogic = this.generateNotificationLogic();
    const themeLogic = this.generateThemeLogic();
    const lifecycleEffects = this.generateAppStateLifecycleEffects();
    const returnValue = this.generateAppStateReturnValue();
    return `/**
 * Application state management hook
 */
export function useAppState() {
${hookDeclaration}

${coreLogic}

${notificationLogic}

${themeLogic}

${lifecycleEffects}

${returnValue}
}`;
  }
  generateAppStateHookDeclaration() {
    return `  const [state, setState] = useState<AppState>(() => ({
    user: null,
    theme: 'light',
    loading: false,
    error: null,
    notifications: [],
  }));`;
  }
  generateAppStateCoreLogic() {
    return `  const updateUser = useCallback((user: User | null) => {
    setState(prev => ({ ...prev, user }));
  }, []);

  const setLoading = useCallback((loading: boolean) => {
    setState(prev => ({ ...prev, loading }));
  }, []);

  const setError = useCallback((error: string | null) => {
    setState(prev => ({ ...prev, error }));
  }, []);`;
  }
  generateNotificationLogic() {
    return `  const addNotification = useCallback((notification: Omit<Notification, 'id' | 'timestamp'>) => {
    const newNotification: Notification = {
      ...notification,
      id: Date.now().toString(),
      timestamp: new Date(),
    };

    setState(prev => ({
      ...prev,
      notifications: [...prev.notifications, newNotification],
    }));
  }, []);

  const removeNotification = useCallback((id: string) => {
    setState(prev => ({
      ...prev,
      notifications: prev.notifications.filter(n => n.id !== id),
    }));
  }, []);

  const clearNotifications = useCallback(() => {
    setState(prev => ({ ...prev, notifications: [] }));
  }, []);`;
  }
  generateThemeLogic() {
    return `  const setTheme = useCallback((theme: 'light' | 'dark') => {
    setState(prev => ({ ...prev, theme }));

    if (typeof document !== 'undefined') {
      document.documentElement.setAttribute('data-theme', theme);
    }
  }, []);`;
  }
  generateAppStateLifecycleEffects() {
    return `  useEffect(() => {
    // Initialize theme from localStorage or system preference
    if (typeof window !== 'undefined') {
      const savedTheme = localStorage.getItem('theme') as 'light' | 'dark' | null;
      const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      const initialTheme = savedTheme || systemTheme;

      setTheme(initialTheme);
    }
  }, [setTheme]);

  useEffect(() => {
    // Auto-remove notifications after 5 seconds
    const timer = setInterval(() => {
      setState(prev => ({
        ...prev,
        notifications: prev.notifications.filter(n =>
          Date.now() - n.timestamp.getTime() < 5000
        ),
      }));
    }, 1000);

    return () => clearInterval(timer);
  }, []);`;
  }
  generateAppStateReturnValue() {
    return `  return {
    ...state,
    updateUser,
    setLoading,
    setError,
    addNotification,
    removeNotification,
    clearNotifications,
    setTheme,
  };`;
  }
  generateUtilityHooks(config) {
    return this.utilityHooksGenerator.generateUtilityHooks(config);
  }
  generateApiHooks(config) {
    return this.apiHooksGenerator.generateApiHooks(config);
  }
  generateRouterHooks(config) {
    return this.routerHooksGenerator.generateRouterHooks(config);
  }
}
var init_hook_generator = () => {};

// ../../packages/core/src/services/generators/web/styles/components/basic-component-styles.ts
class BasicComponentStyles {
  generateButtonStyles() {
    const baseButton = this.getBaseButtonStyles();
    const primaryButton = this.getPrimaryButtonStyles();
    const secondaryButton = this.getSecondaryButtonStyles();
    return `${baseButton}

${primaryButton}

${secondaryButton}`;
  }
  getBaseButtonStyles() {
    return `.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  font-weight: 500;
  text-decoration: none;
  border: 2px solid transparent;
  border-radius: 0.5rem;
  cursor: pointer;
  transition: all 0.2s ease;
}`;
  }
  getPrimaryButtonStyles() {
    return `.btn-primary {
  background-color: var(--color-primary);
  color: var(--color-white);
}

.btn-primary:hover {
  background-color: var(--color-primary-dark);
  transform: translateY(-1px);
}`;
  }
  getSecondaryButtonStyles() {
    return `.btn-secondary {
  background-color: transparent;
  color: var(--color-primary);
  border-color: var(--color-primary);
}

.btn-secondary:hover {
  background-color: var(--color-primary);
  color: var(--color-white);
}`;
  }
  generateCardStyles() {
    return `.card {
  background: var(--color-white);
  border: 1px solid var(--color-gray-200);
  border-radius: 0.75rem;
  padding: 1.5rem;
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
}

.card:hover {
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
}`;
  }
  generateFormInputStyles() {
    return `.form-input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--color-gray-300);
  border-radius: 0.375rem;
  font-size: 1rem;
  transition: border-color 0.15s ease;
}

.form-input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
}`;
  }
  generateBasicComponentStyles() {
    const buttonStyles = this.generateButtonStyles();
    const cardStyles = this.generateCardStyles();
    const formInputStyles = this.generateFormInputStyles();
    return `/* Component Styles */
${buttonStyles}

${cardStyles}

${formInputStyles}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/components/layout-styles.ts
class LayoutStyles {
  generateContainerStyles() {
    return `.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}`;
  }
  generateGridStyles() {
    return `.grid {
  display: grid;
  gap: 1.5rem;
}

.grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
.grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
.grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
.grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }`;
  }
  generateFlexStyles() {
    return `.flex {
  display: flex;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}`;
  }
  generateGapStyles() {
    return `.gap-4 { gap: 1rem; }
.gap-6 { gap: 1.5rem; }
.gap-8 { gap: 2rem; }`;
  }
  generateLayoutStyles() {
    const containerStyles = this.generateContainerStyles();
    const gridStyles = this.generateGridStyles();
    const flexStyles = this.generateFlexStyles();
    const gapStyles = this.generateGapStyles();
    return `/* Layout Styles */
${containerStyles}

${gridStyles}

${flexStyles}

${gapStyles}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/components/utility-styles.ts
class UtilityStyles {
  generateAccessibilityUtilities() {
    return `.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}`;
  }
  generateTextAlignmentUtilities() {
    return `.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }`;
  }
  generateTextSizeUtilities() {
    return `.text-sm { font-size: 0.875rem; }
.text-base { font-size: 1rem; }
.text-lg { font-size: 1.125rem; }
.text-xl { font-size: 1.25rem; }
.text-2xl { font-size: 1.5rem; }`;
  }
  generateFontWeightUtilities() {
    return `.font-normal { font-weight: 400; }
.font-medium { font-weight: 500; }
.font-semibold { font-weight: 600; }
.font-bold { font-weight: 700; }`;
  }
  generateTextColorUtilities() {
    return `.text-gray-500 { color: var(--color-gray-500); }
.text-gray-600 { color: var(--color-gray-600); }
.text-gray-700 { color: var(--color-gray-700); }
.text-gray-900 { color: var(--color-gray-900); }`;
  }
  generateBackgroundColorUtilities() {
    return `.bg-white { background-color: var(--color-white); }
.bg-gray-50 { background-color: var(--color-gray-50); }`;
  }
  generateBorderRadiusUtilities() {
    return `.rounded { border-radius: 0.25rem; }
.rounded-md { border-radius: 0.375rem; }
.rounded-lg { border-radius: 0.5rem; }`;
  }
  generateShadowUtilities() {
    return `.shadow { box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1); }
.shadow-lg { box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1); }`;
  }
  generateUtilityStyles() {
    const accessibilityUtilities = this.generateAccessibilityUtilities();
    const textAlignmentUtilities = this.generateTextAlignmentUtilities();
    const textSizeUtilities = this.generateTextSizeUtilities();
    const fontWeightUtilities = this.generateFontWeightUtilities();
    const textColorUtilities = this.generateTextColorUtilities();
    const backgroundColorUtilities = this.generateBackgroundColorUtilities();
    const borderRadiusUtilities = this.generateBorderRadiusUtilities();
    const shadowUtilities = this.generateShadowUtilities();
    return `/* Utility Styles */
${accessibilityUtilities}

${textAlignmentUtilities}

${textSizeUtilities}

${fontWeightUtilities}

${textColorUtilities}

${backgroundColorUtilities}

${borderRadiusUtilities}

${shadowUtilities}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/modules/color-utilities.ts
class ColorUtilities {
  getPrimaryColor(config) {
    return config.theme?.primaryColor || '#3b82f6';
  }
  lightenColor(color, percent) {
    const num = Number.parseInt(color.replace('#', ''), HEX_BASE);
    const amt = Math.round(COLOR_CONVERSION_FACTOR * percent);
    const R = (num >> COLOR_SHIFT_RED) + amt;
    const G = ((num >> COLOR_SHIFT_GREEN) & COLOR_MASK_GREEN) + amt;
    const B = (num & COLOR_MASK_BLUE) + amt;
    const clampedR = clampToByte(R);
    const clampedG = clampToByte(G);
    const clampedB = clampToByte(B);
    return `#${(COLOR_MULTIPLIER_RED + clampedR * COLOR_MULTIPLIER_GREEN + clampedG * COLOR_MULTIPLIER_BLUE + clampedB).toString(HEX_BASE).slice(1)}`;
  }
  darkenColor(color, percent) {
    return this.lightenColor(color, -percent);
  }
  generateColorPalette(config) {
    const primaryColor = this.getPrimaryColor(config);
    const adjustmentAmount = 20;
    return {
      primary: primaryColor,
      primaryLight: this.lightenColor(primaryColor, adjustmentAmount),
      primaryDark: this.darkenColor(primaryColor, adjustmentAmount),
      secondary: '#64748b',
      accent: '#f59e0b',
      success: '#10b981',
      warning: '#f59e0b',
      error: '#ef4444',
      info: '#3b82f6',
    };
  }
}
var RGB_MAX_VALUE = 255,
  HEX_BASE = 16,
  COLOR_MULTIPLIER_RED = 16777216,
  COLOR_MULTIPLIER_GREEN = 65536,
  COLOR_MULTIPLIER_BLUE = 256,
  COLOR_MASK_BLUE = 255,
  COLOR_MASK_GREEN = 255,
  COLOR_SHIFT_RED = 16,
  COLOR_SHIFT_GREEN = 8,
  COLOR_CONVERSION_FACTOR = 2.55,
  clampToByte = (value) => {
    if (value < 1) return 0;
    if (value > RGB_MAX_VALUE) return RGB_MAX_VALUE;
    return value;
  };

// ../../packages/core/src/services/generators/web/styles/modules/base-styles.ts
class BaseStyles {
  colorUtilities;
  constructor() {
    this.colorUtilities = new ColorUtilities();
  }
  generateStylesHeader(config) {
    return `/*
 * ${config.name} - Main Styles
 * Modern, responsive, and accessible CSS
 */`;
  }
  generateCSSReset() {
    return `/* CSS Reset and Base Styles */
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}`;
  }
  generateCSSVariables(config) {
    const primaryColor = this.colorUtilities.getPrimaryColor(config);
    return `:root {
  /* Color Palette */
  --color-primary: ${primaryColor};
  --color-primary-light: ${this.colorUtilities.lightenColor(primaryColor, COLOR_ADJUSTMENT_AMOUNT)};
  --color-primary-dark: ${this.colorUtilities.darkenColor(primaryColor, COLOR_ADJUSTMENT_AMOUNT)};

  --color-secondary: #64748b;
  --color-accent: #f59e0b;

  --color-success: #10b981;
  --color-warning: #f59e0b;
  --color-error: #ef4444;
  --color-info: #3b82f6;

  /* Neutral Colors */
  --color-white: #ffffff;
  --color-gray-50: #f8fafc;
  --color-gray-100: #f1f5f9;
  --color-gray-200: #e2e8f0;
  --color-gray-300: #cbd5e1;
  --color-gray-400: #94a3b8;
  --color-gray-500: #64748b;
  --color-gray-600: #475569;
  --color-gray-700: #334155;
  --color-gray-800: #1e293b;
  --color-gray-900: #0f172a;

  /* Typography */
  --font-family-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-family-mono: 'Fira Code', 'SF Mono', Monaco, monospace;`;
  }
  generateBaseStyles() {
    return `/* Base Styles */
html {
  font-size: 16px;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
}

body {
  font-family: var(--font-family-sans);
  line-height: 1.6;
  color: var(--color-gray-900);
  background-color: var(--color-white);
}

img, picture, video, canvas, svg {
  display: block;
  max-width: 100%;
}

input, button, textarea, select {
  font: inherit;
}`;
  }
  generateBaseStylesSection(config) {
    const header = this.generateStylesHeader(config);
    const reset = this.generateCSSReset();
    const variables = this.generateCSSVariables(config);
    const baseStyles = this.generateBaseStyles();
    return [header, reset, variables, baseStyles].join(`

`);
  }
}
var COLOR_ADJUSTMENT_AMOUNT = 20;
var init_base_styles = () => {};

// ../../packages/core/src/services/generators/web/styles/modules/button-styles.ts
class ButtonStyles {
  generate() {
    return [
      this.getButtonStylesHeader(),
      this.getBaseButtonStyles(),
      this.getButtonDisabledStyles(),
      this.getButtonVariantStyles(),
      this.getButtonSizeStyles(),
    ].join(`

`);
  }
  getButtonStylesHeader() {
    return `/* Buttons */`;
  }
  getBaseButtonStyles() {
    return `.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-3) var(--space-6);
  font-weight: var(--font-weight-medium);
  text-decoration: none;
  border: none;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.2s ease;
}`;
  }
  getButtonDisabledStyles() {
    return `.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}`;
  }
  getButtonVariantStyles() {
    return [this.getPrimaryButtonStyles(), this.getSecondaryButtonStyles()].join(`

`);
  }
  getPrimaryButtonStyles() {
    return `.btn--primary {
  background: var(--color-primary);
  color: var(--color-white);
}

.btn--primary:hover:not(:disabled) {
  background: var(--color-primary-dark);
}`;
  }
  getSecondaryButtonStyles() {
    return `.btn--secondary {
  background: transparent;
  color: var(--color-primary);
  border: 2px solid var(--color-primary);
}

.btn--secondary:hover:not(:disabled) {
  background: var(--color-primary);
  color: var(--color-white);
}`;
  }
  getButtonSizeStyles() {
    return [this.getSmallButtonStyles(), this.getLargeButtonStyles()].join(`

`);
  }
  getSmallButtonStyles() {
    return `.btn--sm {
  padding: var(--space-2) var(--space-4);
  font-size: var(--font-size-sm);
}`;
  }
  getLargeButtonStyles() {
    return `.btn--lg {
  padding: var(--space-4) var(--space-8);
  font-size: var(--font-size-lg);
}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/modules/card-styles.ts
class CardStyles {
  generate() {
    const baseCard = this.getBaseCardStyles();
    const cardHover = this.getCardHoverStyles();
    const cardParts = this.getCardPartsStyles();
    return `/* Cards */
${baseCard}

${cardHover}

${cardParts}`;
  }
  getBaseCardStyles() {
    return `.card {
  background: var(--color-white);
  border: 1px solid var(--color-gray-200);
  border-radius: var(--radius-lg);
  padding: var(--space-6);
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
  transition: all 0.2s ease;
}`;
  }
  getCardHoverStyles() {
    return `.card:hover {
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
  transform: translateY(-1px);
}`;
  }
  getCardPartsStyles() {
    return `.card__header {
  margin-bottom: var(--space-4);
}

.card__title {
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-semibold);
  color: var(--color-gray-900);
}

.card__content {
  color: var(--color-gray-600);
  line-height: var(--line-height-relaxed);
}

.card__footer {
  margin-top: var(--space-4);
  padding-top: var(--space-4);
  border-top: 1px solid var(--color-gray-200);
}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/modules/form-styles.ts
class FormStyles {
  generate() {
    const formGroup = this.getFormGroupStyles();
    const formLabel = this.getFormLabelStyles();
    const formInput = this.getFormInputStyles();
    const formError = this.getFormErrorStyles();
    return `/* Forms */
${formGroup}

${formLabel}

${formInput}

${formError}`;
  }
  getFormGroupStyles() {
    return `.form-group {
  margin-bottom: var(--space-4);
}`;
  }
  getFormLabelStyles() {
    return `.form-label {
  display: block;
  font-weight: var(--font-weight-medium);
  color: var(--color-gray-700);
  margin-bottom: var(--space-2);
}`;
  }
  getFormInputStyles() {
    return `.form-input,
.form-textarea,
.form-select {
  width: 100%;
  padding: var(--space-3);
  border: 1px solid var(--color-gray-300);
  border-radius: var(--radius-md);
  font-size: var(--font-size-base);
  transition: border-color 0.15s ease, box-shadow 0.15s ease;
}

.form-input:focus,
.form-textarea:focus,
.form-select:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
}

.form-textarea {
  resize: vertical;
  min-height: 100px;
}`;
  }
  getFormErrorStyles() {
    return `.form-error {
  color: var(--color-error);
  font-size: var(--font-size-sm);
  margin-top: var(--space-1);
}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/modules/hero-styles.ts
class HeroStyles {
  generate() {
    return `/* Hero Section */
.hero {
  background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
  color: var(--color-white);
  padding: var(--space-20) 0;
  text-align: center;
}

.hero__content {
  max-width: 800px;
  margin: 0 auto;
  padding: 0 var(--space-4);
}

.hero__title {
  font-size: var(--font-size-5xl);
  font-weight: var(--font-weight-bold);
  margin-bottom: var(--space-6);
  line-height: var(--line-height-tight);
}

.hero__subtitle {
  font-size: var(--font-size-xl);
  margin-bottom: var(--space-8);
  opacity: 0.9;
}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/modules/navigation-styles.ts
class NavigationStyles {
  generate() {
    const navBase = this.getNavBaseStyles();
    const navContainer = this.getNavContainerStyles();
    const navLogo = this.getNavLogoStyles();
    const navLinks = this.getNavLinksStyles();
    return `/* Navigation */
${navBase}

${navContainer}

${navLogo}

${navLinks}`;
  }
  getNavBaseStyles() {
    return `.nav {
  background: var(--color-white);
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
  position: sticky;
  top: 0;
  z-index: 100;
}`;
  }
  getNavContainerStyles() {
    return `.nav__container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-4);
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 4rem;
}`;
  }
  getNavLogoStyles() {
    return `.nav__logo {
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-bold);
  color: var(--color-primary);
  text-decoration: none;
}`;
  }
  getNavLinksStyles() {
    return `.nav__links {
  display: flex;
  gap: var(--space-6);
}

.nav__link {
  color: var(--color-gray-600);
  text-decoration: none;
  font-weight: var(--font-weight-medium);
  transition: color 0.2s ease;
}

.nav__link:hover {
  color: var(--color-primary);
}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/modules/utility-styles.ts
class UtilityStyles2 {
  generateAlertStyles() {
    return `/* Alerts */
.alert {
  padding: var(--space-4);
  border-radius: var(--radius-md);
  margin-bottom: var(--space-4);
}

.alert--success {
  background: rgb(34 197 94 / 0.1);
  border: 1px solid rgb(34 197 94 / 0.2);
  color: rgb(21 128 61);
}

.alert--warning {
  background: rgb(245 158 11 / 0.1);
  border: 1px solid rgb(245 158 11 / 0.2);
  color: rgb(180 83 9);
}

.alert--error {
  background: rgb(239 68 68 / 0.1);
  border: 1px solid rgb(239 68 68 / 0.2);
  color: rgb(185 28 28);
}

.alert--info {
  background: rgb(59 130 246 / 0.1);
  border: 1px solid rgb(59 130 246 / 0.2);
  color: rgb(29 78 216);
}`;
  }
  generateLoadingStyles() {
    return `/* Loading States */
.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid var(--color-gray-200);
  border-top: 3px solid var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.app-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  gap: var(--space-4);
}`;
  }
  generate() {
    return `${this.generateAlertStyles()}

${this.generateLoadingStyles()}`;
  }
}

// ../../packages/core/src/services/generators/web/styles/modules/component-styles.ts
class ComponentStyles {
  heroStyles;
  navigationStyles;
  cardStyles;
  buttonStyles;
  formStyles;
  utilityStyles;
  constructor() {
    this.heroStyles = new HeroStyles();
    this.navigationStyles = new NavigationStyles();
    this.cardStyles = new CardStyles();
    this.buttonStyles = new ButtonStyles();
    this.formStyles = new FormStyles();
    this.utilityStyles = new UtilityStyles2();
  }
  generateComponentStylesHeader() {
    return `/*
 * Component-specific Styles
 * Styles for individual components and features
 */`;
  }
  generateComponentStylesSection() {
    const header = this.generateComponentStylesHeader();
    const hero = this.heroStyles.generate();
    const navigation = this.navigationStyles.generate();
    const cards = this.cardStyles.generate();
    const buttons = this.buttonStyles.generate();
    const forms = this.formStyles.generate();
    const utilities = this.utilityStyles.generate();
    return [header, hero, navigation, cards, buttons, forms, utilities].join(`

`);
  }
}
var init_component_styles = () => {};

// ../../packages/core/src/services/generators/web/styles/modules/responsive-styles.ts
class ResponsiveStyles {
  generateResponsiveStyles() {
    const tabletStyles = this.getTabletStyles();
    const mobileStyles = this.getMobileStyles();
    return `/* Responsive Styles */
${tabletStyles}

${mobileStyles}`;
  }
  getTabletStyles() {
    return `@media (max-width: 768px) {
  .container {
    padding: 0 0.75rem;
  }

  .grid-cols-2 {
    grid-template-columns: 1fr;
  }

  .grid-cols-3 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .grid-cols-4 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }

  .gap-4 { gap: 0.75rem; }
  .gap-6 { gap: 1rem; }
  .gap-8 { gap: 1.5rem; }
}`;
  }
  getMobileStyles() {
    return `@media (max-width: 480px) {
  .grid-cols-3,
  .grid-cols-4 {
    grid-template-columns: 1fr;
  }

  .btn {
    padding: 0.625rem 1.25rem;
    font-size: 0.875rem;
  }

  .card {
    padding: 1rem;
  }
}`;
  }
  generateDarkModeStyles() {
    return `/* Dark mode support */
@media (prefers-color-scheme: dark) {
  :root {
    --color-white: #0f172a;
    --color-gray-50: #1e293b;
    --color-gray-100: #334155;
    --color-gray-200: #475569;
    --color-gray-300: #64748b;
    --color-gray-700: #cbd5e1;
    --color-gray-800: #e2e8f0;
    --color-gray-900: #f8fafc;
  }

  body {
    color: var(--color-gray-900);
    background-color: var(--color-white);
  }

  .card {
    background: var(--color-gray-50);
    border-color: var(--color-gray-200);
  }

  .form-input {
    background-color: var(--color-gray-50);
    border-color: var(--color-gray-200);
    color: var(--color-gray-900);
  }
}`;
  }
  generateAccessibilityStyles() {
    return `/* Accessibility */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Focus styles for better accessibility */
.btn:focus,
.form-input:focus {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  .btn {
    border-width: 3px;
  }

  .card {
    border-width: 2px;
  }
}`;
  }
  generatePrintStyles() {
    return `/* Print Styles */
@media print {
  .navbar,
  .layout__footer,
  .btn,
  .notifications {
    display: none;
  }

  .layout__main {
    padding: 0;
  }

  body {
    font-size: 12pt;
    line-height: 1.4;
  }

  h1 {
    font-size: 18pt;
  }

  h2 {
    font-size: 16pt;
  }

  h3 {
    font-size: 14pt;
  }
}`;
  }
  generateResponsiveSection() {
    const responsive = this.generateResponsiveStyles();
    const darkMode = this.generateDarkModeStyles();
    const accessibility = this.generateAccessibilityStyles();
    const print = this.generatePrintStyles();
    return [responsive, darkMode, accessibility, print].join(`

`);
  }
}

// ../../packages/core/src/services/generators/web/styles/style-generator.ts
class StyleGenerator {
  baseStyles;
  basicComponentStyles;
  utilityStyles;
  layoutStyles;
  componentStyles;
  responsiveStyles;
  colorUtilities;
  constructor() {
    this.baseStyles = new BaseStyles();
    this.basicComponentStyles = new BasicComponentStyles();
    this.utilityStyles = new UtilityStyles();
    this.layoutStyles = new LayoutStyles();
    this.componentStyles = new ComponentStyles();
    this.responsiveStyles = new ResponsiveStyles();
    this.colorUtilities = new ColorUtilities();
  }
  generateMainStyles(config) {
    const baseSection = this.baseStyles.generateBaseStylesSection(config);
    const layout = this.layoutStyles.generateLayoutStyles();
    const components = this.basicComponentStyles.generateBasicComponentStyles();
    const utilities = this.utilityStyles.generateUtilityStyles();
    const responsive = this.responsiveStyles.generateResponsiveSection();
    return [baseSection, layout, components, utilities, responsive].join(`

`);
  }
  generateComponentStyles(_config) {
    return this.componentStyles.generateComponentStylesSection();
  }
  getPrimaryColor(config) {
    return this.colorUtilities.getPrimaryColor(config);
  }
  lightenColor(color, percent) {
    return this.colorUtilities.lightenColor(color, percent);
  }
  darkenColor(color, percent) {
    return this.colorUtilities.darkenColor(color, percent);
  }
}
var init_style_generator = __esm(() => {
  init_base_styles();
  init_component_styles();
});

// ../../packages/core/src/services/generators/web/index.ts
var init_web = __esm(() => {
  init_component_generator();
  init_hook_generator();
  init_style_generator();
});

// ../../packages/core/src/services/generators/web/web-structure-generator.ts
class WebStructureGenerator {
  componentGenerator;
  hookGenerator;
  styleGenerator;
  pageGenerators;
  configGenerators;
  entryGenerators;
  constructor() {
    this.componentGenerator = new ComponentGenerator();
    this.hookGenerator = new HookGenerator();
    this.styleGenerator = new StyleGenerator();
    this.pageGenerators = new WebPageGenerators();
    this.configGenerators = new WebConfigGenerators();
    this.entryGenerators = new WebEntryGenerators();
  }
  generate(config) {
    const directories = this.getWebDirectories();
    const files = this.getWebFiles(config);
    return [...directories, ...files];
  }
  getWebDirectories() {
    return [
      { path: 'src/components', type: 'directory' },
      { path: 'src/components/common', type: 'directory' },
      { path: 'src/components/forms', type: 'directory' },
      { path: 'src/pages', type: 'directory' },
      { path: 'src/hooks', type: 'directory' },
      { path: 'src/utils', type: 'directory' },
      { path: 'src/types', type: 'directory' },
      { path: 'src/styles', type: 'directory' },
      { path: 'src/styles/components', type: 'directory' },
      { path: 'src/assets', type: 'directory' },
      { path: 'src/assets/images', type: 'directory' },
      { path: 'src/assets/fonts', type: 'directory' },
      { path: 'src/assets/icons', type: 'directory' },
      { path: 'public', type: 'directory' },
      { path: 'public/icons', type: 'directory' },
      { path: 'public/images', type: 'directory' },
      { path: 'tests', type: 'directory' },
      { path: 'tests/unit', type: 'directory' },
      { path: 'tests/integration', type: 'directory' },
      { path: 'tests/e2e', type: 'directory' },
    ];
  }
  getWebFiles(config) {
    const entryFiles = this.getEntryFiles(config);
    const componentFiles = this.getComponentFiles(config);
    const pageFiles = this.getPageFiles(config);
    const hookFiles = this.getHookFiles(config);
    const utilityFiles = this.getUtilityFiles(config);
    const styleFiles = this.getStyleFiles(config);
    const configFiles = this.getConfigFiles(config);
    return [
      ...entryFiles,
      ...componentFiles,
      ...pageFiles,
      ...hookFiles,
      ...utilityFiles,
      ...styleFiles,
      ...configFiles,
    ];
  }
  getEntryFiles(config) {
    return [
      {
        path: 'src/main.tsx',
        type: 'file',
        content: this.entryGenerators.generateMainEntry(config),
      },
    ];
  }
  getComponentFiles(config) {
    return [
      {
        path: 'src/components/app.tsx',
        type: 'file',
        content: this.componentGenerator.generateAppComponent(config),
      },
      {
        path: 'src/components/layout.tsx',
        type: 'file',
        content: this.componentGenerator.generateLayoutComponent(config),
      },
    ];
  }
  getPageFiles(config) {
    return [
      {
        path: 'src/pages/home-page.tsx',
        type: 'file',
        content: this.componentGenerator.generateHomePage(config),
      },
      {
        path: 'src/pages/about-page.tsx',
        type: 'file',
        content: this.pageGenerators.generateAboutPage(config),
      },
      {
        path: 'src/pages/contact-page.tsx',
        type: 'file',
        content: this.pageGenerators.generateContactPage(config),
      },
    ];
  }
  getHookFiles(config) {
    return [
      {
        path: 'src/hooks/use-app-state.ts',
        type: 'file',
        content: this.hookGenerator.generateAppStateHook(config),
      },
      {
        path: 'src/hooks/use-router.ts',
        type: 'file',
        content: this.hookGenerator.generateRouterHooks(config),
      },
    ];
  }
  getUtilityFiles(config) {
    return [
      {
        path: 'src/types/index.ts',
        type: 'file',
        content: this.entryGenerators.generateAppTypes(config),
      },
      {
        path: 'src/utils/dom.ts',
        type: 'file',
        content: this.entryGenerators.generateDOMUtils(config),
      },
    ];
  }
  getStyleFiles(config) {
    return [
      {
        path: 'src/styles/main.css',
        type: 'file',
        content: this.styleGenerator.generateMainStyles(config),
      },
      {
        path: 'src/styles/components.css',
        type: 'file',
        content: this.styleGenerator.generateComponentStyles(config),
      },
    ];
  }
  getConfigFiles(config) {
    return [
      {
        path: 'index.html',
        type: 'file',
        content: this.configGenerators.generateHTMLTemplate(config),
      },
      {
        path: 'public/favicon.ico',
        type: 'file',
        content: this.configGenerators.generateFavicon(),
      },
      {
        path: 'vite.config.ts',
        type: 'file',
        content: this.configGenerators.generateViteConfig(config),
      },
    ];
  }
}
var init_web_structure_generator = __esm(() => {
  init_web_config_generators();
  init_web_entry_generators();
  init_web_page_generators();
  init_web();
});

// ../../packages/core/src/services/generators/template-generator.ts
class TemplateGenerator {
  reactGenerator;
  vueGenerator;
  expressGenerator;
  basicGenerator;
  cliGenerator;
  webGenerator;
  libraryGenerator;
  typescriptGenerator;
  constructor() {
    this.reactGenerator = new ReactStructureGenerator();
    this.vueGenerator = new VueStructureGenerator();
    this.expressGenerator = new ExpressStructureGenerator();
    this.basicGenerator = new BasicStructureGenerator();
    this.cliGenerator = new CLIStructureGenerator();
    this.webGenerator = new WebStructureGenerator();
    this.libraryGenerator = new LibraryStructureGenerator();
    this.typescriptGenerator = new TypeScriptStructureGenerator();
  }
  generate(config) {
    switch (config.projectType) {
      case 'bun-react':
        return this.reactGenerator.generate(config);
      case 'bun-vue':
        return this.vueGenerator.generate(config);
      case 'bun-express':
        return this.expressGenerator.generate(config);
      case 'cli':
        return this.cliGenerator.generate(config);
      case 'web':
        return this.webGenerator.generate(config);
      case 'library':
        return this.libraryGenerator.generate(config);
      case 'bun-typescript':
        return this.typescriptGenerator.generate(config);
      case 'basic':
      default:
        return this.basicGenerator.generate(config);
    }
  }
}
var init_template_generator = __esm(() => {
  init_cli_structure_generator();
  init_express_structure_generator();
  init_library_structure_generator();
  init_react_structure_generator();
  init_typescript_structure_generator();
  init_vue_structure_generator();
  init_web_structure_generator();
});

// ../../packages/core/src/services/generators/test-helpers/config-test-builder.ts
class ConfigTestBuilder {
  generateNoDebugInitializeTest() {
    return `
    it('should initialize without debug mode', () => {
      // Given: Configuration without debug
      const noDebugConfig = {
        debug: false,
        options: {}
      };

      // When: Initializing
      const result = instance.initialize(noDebugConfig);

      // Then: Should initialize successfully
      expect(result).toBeDefined();
    });`;
  }
  generateDebugInitializeTest() {
    return `
    it('should initialize with debug mode', () => {
      // Given: Configuration with debug
      const debugConfig = {
        debug: true,
        options: {}
      };

      // When: Initializing
      const result = instance.initialize(debugConfig);

      // Then: Should initialize successfully with debug enabled
      expect(result).toBeDefined();
    });`;
  }
  generateErrorInitializeTest() {
    return `
    it('should handle initialization errors gracefully', () => {
      // Given: Invalid configuration
      const invalidConfig = null as any;

      // When: Initializing
      // Then: Should not throw
      expect(() => instance.initialize(invalidConfig)).not.toThrow();
    });`;
  }
  getInitializeTests(_className, _config) {
    const noDebugTest = this.generateNoDebugInitializeTest();
    const debugTest = this.generateDebugInitializeTest();
    const errorTest = this.generateErrorInitializeTest();
    return `
  describe('initialize', () => {
${noDebugTest}

${debugTest}

${errorTest}
  });`;
  }
  getConfigTests(_className) {
    return `
  describe('configuration', () => {
    it('should return current configuration', () => {
      // When: Getting configuration
      const currentConfig = instance.getConfig();

      // Then: Should return the test configuration
      expect(currentConfig).toBeDefined();
      expect(currentConfig.debug).toBe(false);
    });

    it('should validate configuration structure', () => {
      // Given: Test configuration
      const validConfig = {
        debug: true,
        options: { test: true }
      };

      // When: Setting configuration
      instance.setConfig(validConfig);

      // Then: Should have correct structure
      expect(instance.getConfig()).toEqual(validConfig);
    });
  });`;
  }
  getUpdateConfigTests(_className) {
    return `
  describe('updateConfig', () => {
    it('should update configuration partially', () => {
      // Given: Initial configuration and update
      const update = { debug: true };

      // When: Updating configuration
      instance.updateConfig(update);

      // Then: Should update only specified properties
      expect(instance.getConfig().debug).toBe(true);
    });

    it('should preserve existing configuration when updating', () => {
      // Given: Initial configuration
      const initialConfig = instance.getConfig();

      // When: Updating with empty object
      instance.updateConfig({});

      // Then: Should preserve existing configuration
      expect(instance.getConfig()).toEqual(initialConfig);
    });

    it('should handle empty update gracefully', () => {
      // Given: Initial configuration
      const beforeConfig = instance.getConfig();

      // When: Updating with null/undefined
      instance.updateConfig(null as any);
      instance.updateConfig(undefined as any);

      // Then: Should not change configuration
      expect(instance.getConfig()).toEqual(beforeConfig);
    });
  });`;
  }
}

// ../../packages/core/src/services/generators/test-helpers/error-test-builder.ts
class ErrorTestBuilder {
  generateConfigurationErrorTests(className) {
    return `
    it('should handle invalid configuration gracefully', () => {
      // Given: Invalid configuration
      const invalidConfig = {
        debug: 'invalid' as any,
        options: null as any
      };

      // When: Creating instance
      // Then: Should not throw
      expect(() => new ${className}(invalidConfig)).not.toThrow();
    });

    it('should handle null/undefined configuration', () => {
      // When: Creating instance with null/undefined
      // Then: Should not throw
      expect(() => new ${className}(null as any)).not.toThrow();
      expect(() => new ${className}(undefined as any)).not.toThrow();
    });`;
  }
  generateMethodErrorTests() {
    return `
    it('should handle invalid method arguments', () => {
      // Given: Valid instance
      // When: Calling methods with invalid arguments
      // Then: Should handle gracefully
      expect(() => instance.initialize(null as any)).not.toThrow();
      expect(() => instance.updateConfig(null as any)).not.toThrow();
    });`;
  }
  generateErrorMessageTests() {
    return `
    it('should provide meaningful error messages', () => {
      // Given: Test scenario that should produce an error
      // When: Error occurs
      // Then: Error should be meaningful
      // Note: Add specific error handling tests based on your implementation
    });`;
  }
  getErrorHandlingTests(className) {
    const configTests = this.generateConfigurationErrorTests(className);
    const methodTests = this.generateMethodErrorTests();
    const messageTests = this.generateErrorMessageTests();
    return `
  describe('error handling', () => {
${configTests}

${methodTests}

${messageTests}
  });`;
  }
}

// ../../packages/core/src/services/generators/test-helpers/test-setup-builder.ts
class TestSetupBuilder {
  getTestSetupHeader(config) {
    return `/**
 * Test Setup Configuration for ${config.name}
 *
 * This file provides common setup for all test files
 * Configure global test environment, mocks, and utilities here
 */`;
  }
  getTestSetupImports() {
    return `import { beforeAll, afterAll, beforeEach, afterEach, vi } from 'vitest';
import { config } from 'dotenv';`;
  }
  getConsoleSetup(_config) {
    return `// Configure console output for tests
const originalConsole = global.console;

beforeAll(() => {
  // Disable console logs in tests unless debug mode is enabled
  if (!process.env.DEBUG) {
    global.console = {
      ...originalConsole,
      log: vi.fn(),
      debug: vi.fn(),
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
    };
  }
});

afterAll(() => {
  // Restore original console
  global.console = originalConsole;
});

// Clear all mocks after each test
afterEach(() => {
  vi.clearAllMocks();
});`;
  }
  getEnvironmentSetup() {
    return `// Load environment variables
beforeAll(() => {
  config({ path: '.env.test' });
});

// Set test environment variables
process.env.NODE_ENV = 'test';
process.env.TZ = 'UTC';

// Global setup for all tests
beforeAll(() => {
  // Global test setup can go here
  console.log('global setup');
});`;
  }
  generateTestUtilsObject() {
    return `export const testUtils = {
  /**
   * Create a mock configuration
   * @param {Partial<ProjectConfig>} overrides - Configuration overrides
   * @returns {ProjectConfig} Mock configuration
   */
  createMockConfig: (overrides = {}) => ({
    name: 'test-project',
    version: '1.0.0',
    description: 'Test project',
    debug: false,
    ...overrides,
  }),

  /**
   * Wait for async operations
   * @param {number} ms - Milliseconds to wait
   * @returns {Promise<void>} Promise that resolves after delay
   */
  wait: (ms = 0) => new Promise(resolve => setTimeout(resolve, ms)),

  /**
   * Create a mock error
   * @param {string} message - Error message
   * @returns {Error} Mock error
   */
  createError: (message = 'Test error') => new Error(message),
};`;
  }
  generateGlobalDeclarations() {
    return `// Make utils available globally for convenience
declare global {
  const testUtils: typeof testUtils;
}`;
  }
  generateDefaultExport() {
    return `// Export default setup
export default testUtils;`;
  }
  getTestUtilities() {
    const utilsObject = this.generateTestUtilsObject();
    const globalDeclarations = this.generateGlobalDeclarations();
    const defaultExport = this.generateDefaultExport();
    return `// Global test utilities
${utilsObject}

${globalDeclarations}

${defaultExport}`;
  }
}

// ../../packages/core/src/services/generators/test-helpers/unit-test-builder.ts
class UnitTestBuilder {
  getTestFileHeader(config, className) {
    return `/**
 * Test suite for ${config.name}
 *
 * This file was auto-generated and should be reviewed and customized
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ${className} } from '../src/index.js';

describe('${config.name}', () => {`;
  }
  getTestSetup(className, interfaceName) {
    return `  let instance: ${className};
  let testConfig: ${interfaceName};

  beforeEach(() => {
    testConfig = {
      debug: false,
      options: {}
    };
    instance = new ${className}(testConfig);
  });

  afterEach(() => {
    // Cleanup if needed
    instance = null as any;
    testConfig = null as any;
  });`;
  }
  getConstructorTests(className) {
    return `
  describe('constructor', () => {
    it('should create instance with default configuration', () => {
      // Given: Default configuration
      const defaultConfig = {
        debug: false,
        options: {}
      };

      // When: Creating instance
      const testInstance = new ${className}(defaultConfig);

      // Then: Should create instance successfully
      expect(testInstance).toBeDefined();
      expect(testInstance).toBeInstanceOf(${className});
    });

    it('should create instance with debug enabled', () => {
      // Given: Debug configuration
      const debugConfig = {
        debug: true,
        options: {}
      };

      // When: Creating instance
      const testInstance = new ${className}(debugConfig);

      // Then: Should create instance successfully
      expect(testInstance).toBeDefined();
      expect(testInstance).toBeInstanceOf(${className});
    });
  });`;
  }
}

// ../../packages/core/src/services/generators/tests/express-test-generator.ts
class ExpressTestGenerator {
  generateExpressTests(_config) {
    return `

  describe('Express-specific functionality', () => {
    it('should handle Express middleware integration', () => {
      // Given: Express middleware function
      const middleware = (req: any, res: any, next: any) => {
        req.customData = 'added by middleware';
        next();
      };

      // When: Applying middleware
      const mockReq = {};
      const mockRes = {};
      const mockNext = vi.fn();

      middleware(mockReq, mockRes, mockNext);

      // Then: Should modify request and call next
      expect((mockReq as any).customData).toBe('added by middleware');
      expect(mockNext).toHaveBeenCalled();
    });

    it('should handle Express route handlers', () => {
      // Given: Route handler
      const routeHandler = (req: any, res: any) => {
        res.json({ message: 'Hello Express' });
      };

      // When: Calling route handler
      const mockReq = {};
      const mockRes = {
        json: vi.fn()
      };

      routeHandler(mockReq, mockRes);

      // Then: Should send JSON response
      expect(mockRes.json).toHaveBeenCalledWith({ message: 'Hello Express' });
    });

    it('should handle Express error middleware', () => {
      // Given: Error middleware
      const errorMiddleware = (err: Error, req: any, res: any, next: any) => {
        res.status(500).json({ error: err.message });
      };

      // When: Handling error
      const error = new Error('Test error');
      const mockReq = {};
      const mockRes = {
        status: vi.fn().mockReturnThis(),
        json: vi.fn()
      };
      const mockNext = vi.fn();

      errorMiddleware(error, mockReq, mockRes, mockNext);

      // Then: Should handle error correctly
      expect(mockRes.status).toHaveBeenCalledWith(500);
      expect(mockRes.json).toHaveBeenCalledWith({ error: 'Test error' });
    });
  });`;
  }
}

// ../../packages/core/src/services/generators/tests/react-test-generator.ts
class ReactTestGenerator {
  generateReactTests(_config) {
    return `

  describe('React-specific functionality', () => {
    it('should handle React component integration', () => {
      // Given: React-specific props
      const reactProps = {
        children: React.createElement('div', {}, 'Test content')
      };

      // When: Using with React components
      // Then: Should work without TypeScript errors
      expect(reactProps.children).toBeDefined();
    });

    it('should support JSX rendering', () => {
      // Given: Component data
      const testData = { message: 'Hello World' };

      // When: Creating React element
      const element = React.createElement('div', {}, testData.message);

      // Then: Should create valid React element
      expect(element.type).toBe('div');
      expect(element.props.children).toBe('Hello World');
    });
  });`;
  }
}

// ../../packages/core/src/services/generators/tests/vue-test-generator.ts
class VueTestGenerator {
  generateVueTests(_config) {
    return `

  describe('Vue-specific functionality', () => {
    it('should handle Vue component integration', () => {
      // Given: Vue-specific configuration
      const vueConfig = {
        template: '<div>{{ message }}</div>',
        data: () => ({ message: 'Hello Vue' })
      };

      // When: Creating Vue component
      // Then: Should work without TypeScript errors
      expect(vueConfig.data).toBeDefined();
      expect(typeof vueConfig.data).toBe('function');
    });

    it('should support Vue reactive data', () => {
      // Given: Reactive data
      const reactiveData = { count: 0 };

      // When: Modifying data
      reactiveData.count = 5;

      // Then: Should update correctly
      expect(reactiveData.count).toBe(5);
    });
  });`;
  }
}

// ../../packages/core/src/services/generators/test-file-generator.ts
class TestFileGenerator {
  reactTestGenerator;
  vueTestGenerator;
  expressTestGenerator;
  testSetupBuilder;
  unitTestBuilder;
  configTestBuilder;
  errorTestBuilder;
  constructor() {
    this.reactTestGenerator = new ReactTestGenerator();
    this.vueTestGenerator = new VueTestGenerator();
    this.expressTestGenerator = new ExpressTestGenerator();
    this.testSetupBuilder = new TestSetupBuilder();
    this.unitTestBuilder = new UnitTestBuilder();
    this.configTestBuilder = new ConfigTestBuilder();
    this.errorTestBuilder = new ErrorTestBuilder();
  }
  generateTestSetup(config) {
    const header = this.testSetupBuilder.getTestSetupHeader(config);
    const imports = this.testSetupBuilder.getTestSetupImports();
    const consoleSetup = this.testSetupBuilder.getConsoleSetup(config);
    const environmentSetup = this.testSetupBuilder.getEnvironmentSetup();
    const utilities = this.testSetupBuilder.getTestUtilities();
    return `${header}

${imports}

${consoleSetup}

${environmentSetup}

${utilities}
`;
  }
  generate(config) {
    const className = `${toPascalCase(config.name)}Core`;
    const interfaceName = `${toPascalCase(config.name)}Config`;
    const header = this.unitTestBuilder.getTestFileHeader(config, className);
    const setup = this.unitTestBuilder.getTestSetup(className, interfaceName);
    const constructorTests = this.unitTestBuilder.getConstructorTests(className);
    const initializeTests = this.configTestBuilder.getInitializeTests(className, config);
    const configTests = this.configTestBuilder.getConfigTests(className);
    const updateConfigTests = this.configTestBuilder.getUpdateConfigTests(className);
    const errorTests = this.errorTestBuilder.getErrorHandlingTests(className);
    const typeSpecificTests = this.generateTypeSpecificTests(config);
    return `${header}

${setup}

${constructorTests}

${initializeTests}

${configTests}

${updateConfigTests}

${errorTests}${typeSpecificTests}
});`;
  }
  generateTypeSpecificTests(config) {
    switch (config.projectType) {
      case 'bun-react':
        return this.reactTestGenerator.generateReactTests(config);
      case 'bun-vue':
        return this.vueTestGenerator.generateVueTests(config);
      case 'bun-express':
        return this.expressTestGenerator.generateExpressTests(config);
      default:
        return '';
    }
  }
}
var init_test_file_generator = () => {};

// ../../packages/core/src/services/generators/test-structure-generator.ts
class TestStructureGenerator {
  testFileGenerator;
  COVERAGE_THRESHOLDS = {
    STRICT: 90,
    STANDARD: 80,
    LIGHT: 70,
  };
  constructor() {
    this.testFileGenerator = new TestFileGenerator();
  }
  generate(config) {
    const items = [];
    items.push(...this.generateBaseTestDirectories());
    items.push(...this.generateQualitySpecificDirectories(config.qualityLevel));
    items.push(...this.generateProjectSpecificDirectories(config.projectType));
    items.push(...this.generateTestFiles(config));
    items.push(...this.generateFixtureGitkeepFiles());
    items.push(this.generateVitestConfigFile(config));
    return items;
  }
  generateBaseTestDirectories() {
    return [
      { type: 'directory', path: 'tests', mode: 493 },
      { type: 'directory', path: 'tests/unit', mode: 493 },
      { type: 'directory', path: 'tests/integration', mode: 493 },
      { type: 'directory', path: 'tests/e2e', mode: 493 },
      { type: 'directory', path: 'tests/fixtures', mode: 493 },
      { type: 'directory', path: 'tests/fixtures/data', mode: 493 },
      { type: 'directory', path: 'tests/fixtures/mock-responses', mode: 493 },
      { type: 'directory', path: 'tests/helpers', mode: 493 },
    ];
  }
  generateQualitySpecificDirectories(qualityLevel) {
    const directories = [];
    if (qualityLevel === 'high' || qualityLevel === 'strict') {
      directories.push({ type: 'directory', path: 'tests/performance', mode: 493 });
      directories.push({ type: 'directory', path: 'tests/mutation', mode: 493 });
    }
    if (qualityLevel === 'standard' || qualityLevel === 'high' || qualityLevel === 'strict') {
      directories.push({ type: 'directory', path: 'tests/factories', mode: 493 });
    }
    return directories;
  }
  generateProjectSpecificDirectories(projectType) {
    if (projectType === 'web') {
      return [
        { type: 'directory', path: 'tests/unit/components', mode: 493 },
        { type: 'directory', path: 'tests/unit/utils', mode: 493 },
        { type: 'directory', path: 'tests/unit/services', mode: 493 },
        { type: 'directory', path: 'tests/unit/types', mode: 493 },
        { type: 'directory', path: 'tests/integration/components', mode: 493 },
        { type: 'directory', path: 'tests/integration/api', mode: 493 },
      ];
    }
    return [];
  }
  generateTestFiles(config) {
    return [
      {
        type: 'file',
        path: 'tests/setup.ts',
        content: this.testFileGenerator.generateTestSetup(config),
      },
      {
        type: 'file',
        path: 'tests/unit/index.test.ts',
        content: this.generateBasicUnitTest(config),
      },
      {
        type: 'file',
        path: 'tests/integration/api.test.ts',
        content: this.generateBasicIntegrationTest(config),
      },
      {
        type: 'file',
        path: 'tests/e2e/basic-workflow.e2e.test.ts',
        content: this.generateBasicE2ETest(config),
      },
    ];
  }
  generateFixtureGitkeepFiles() {
    return [
      { type: 'file', path: 'tests/fixtures/.gitkeep', content: '' },
      { type: 'file', path: 'tests/fixtures/data/.gitkeep', content: '' },
      { type: 'file', path: 'tests/fixtures/mock-responses/.gitkeep', content: '' },
      { type: 'file', path: 'tests/performance/.gitkeep', content: '' },
      { type: 'file', path: 'tests/mutation/.gitkeep', content: '' },
      { type: 'file', path: 'tests/factories/.gitkeep', content: '' },
    ];
  }
  generateVitestConfigFile(config) {
    return {
      type: 'file',
      path: 'vitest.config.ts',
      content: this.generateVitestConfig(config),
    };
  }
  generateBasicUnitTest(config) {
    return `/**
 * Unit Tests for ${config.name}
 *
 * Basic unit test example
 */
import { describe, it, expect } from 'bun:test';

describe('${config.name}', () => {
  describe('basic functionality', () => {
    it('should pass this example test', () => {
      // Given: A simple test case
      const input = 'test';

      // When: Processing the input
      const result = input.toUpperCase();

      // Then: Should produce expected output
      expect(result).toBe('TEST');
    });

    it('should handle edge cases', () => {
      // Given: Edge case input
      const input = '';

      // When: Processing empty input
      const result = input || 'default';

      // Then: Should handle gracefully
      expect(result).toBe('default');
    });
  });
});`;
  }
  generateBasicIntegrationTest(config) {
    return [this.getIntegrationTestHeader(config), this.getIntegrationTestSuite()].join(`
`);
  }
  getIntegrationTestHeader(config) {
    return `/**
 * Integration Tests for ${config.name}
 *
 * Integration test example
 */
import { describe, it, expect, beforeAll, afterAll } from 'bun:test';

describe('${config.name} Integration', () => {`;
  }
  getIntegrationTestSuite() {
    return `  describe('API integration', () => {
    ${this.getApiSuccessTest()}
    ${this.getApiErrorTest()}
  });
});`;
  }
  getApiSuccessTest() {
    return `it('should handle API requests correctly', async () => {
      // Given: API endpoint configuration
      const apiUrl = 'https://api.example.com/test';

      // When: Making API request
      // Note: This is a mock example - replace with actual API testing
      const mockResponse = { status: 200, data: { success: true } };

      // Then: Should receive expected response
      expect(mockResponse.status).toBe(200);
      expect(mockResponse.data.success).toBe(true);
    });`;
  }
  getApiErrorTest() {
    return `it('should handle API errors gracefully', async () => {
      // Given: Error scenario
      const errorScenario = {
        status: 404,
        message: 'Not found'
      };

      // When: Handling API error
      const errorHandler = (error: typeof errorScenario) => {
        return \`Error \${error.status}: \${error.message}\`;
      };

      // Then: Should handle error appropriately
      expect(errorHandler(errorScenario)).toBe('Error 404: Not found');
    });`;
  }
  generateBasicE2ETest(config) {
    return `${this.generateE2ETestHeader(config)}${this.generateE2ETestWorkflows()}`;
  }
  generateE2ETestHeader(config) {
    return `/**
 * E2E Tests for ${config.name}
 *
 * End-to-end test example
 */
import { describe, it, expect, beforeAll, afterAll } from 'bun:test';

describe('${config.name} E2E', () => {`;
  }
  generateE2ETestWorkflows() {
    return `  describe('user workflows', () => {
    ${this.generateBasicWorkflowTest()}
    ${this.generateAuthenticationTest()}
  });
});`;
  }
  generateBasicWorkflowTest() {
    return `it('should complete basic user workflow', async () => {
      // Given: User starting point
      const user = {
        name: 'Test User',
        email: 'test@example.com'
      };

      // When: Simulating user workflow
      // Note: This is a mock example - replace with actual E2E testing
      const workflow = {
        step1: 'Navigate to application',
        step2: 'Perform action',
        step3: 'Verify result'
      };

      // Then: Workflow should complete successfully
      expect(user.name).toBe('Test User');
      expect(workflow.step1).toBeDefined();
      expect(workflow.step2).toBeDefined();
      expect(workflow.step3).toBeDefined();
    });`;
  }
  generateAuthenticationTest() {
    return `it('should handle user authentication flow', async () => {
      // Given: Authentication credentials
      const credentials = {
        username: 'testuser',
        password: 'testpass'
      };

      // When: Simulating authentication
      const authResult = {
        success: true,
        token: 'mock-jwt-token',
        user: { id: 1, name: 'Test User' }
      };

      // Then: Authentication should succeed
      expect(authResult.success).toBe(true);
      expect(authResult.token).toBeDefined();
      expect(authResult.user.name).toBe('Test User');
    });`;
  }
  generateVitestConfig(config) {
    const coverageThreshold = this.getCoverageThreshold(config.qualityLevel);
    return `${this.getVitestConfigImports()}${this.getVitestConfigTestSection(coverageThreshold)}${this.getVitestConfigResolveSection()}`;
  }
  getVitestConfigImports() {
    return `import { defineConfig } from 'vitest/config';
import { resolve } from 'path';

`;
  }
  getVitestConfigTestSection(coverageThreshold) {
    return `export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      thresholds: {
        global: {
          branches: ${coverageThreshold},
          functions: ${coverageThreshold},
          lines: ${coverageThreshold},
          statements: ${coverageThreshold}
        }
      },
      include: ['src/**/*'],
      exclude: ${this.getVitestConfigExcludePatterns()}
    }
  },
`;
  }
  getVitestConfigExcludePatterns() {
    return `[
        '**/node_modules/**',
        '**/tests/**',
        '**/*.d.ts',
        '**/*.config.*'
      ]`;
  }
  getVitestConfigResolveSection() {
    return `  resolve: {
    alias: {
      '@': resolve(__dirname, './src')
    }
  }
});`;
  }
  getCoverageThreshold(qualityLevel) {
    switch (qualityLevel) {
      case 'strict':
        return this.COVERAGE_THRESHOLDS.STRICT;
      case 'standard':
        return this.COVERAGE_THRESHOLDS.STANDARD;
      case 'light':
        return this.COVERAGE_THRESHOLDS.LIGHT;
      default:
        return this.COVERAGE_THRESHOLDS.STANDARD;
    }
  }
}
var init_test_structure_generator = __esm(() => {
  init_test_file_generator();
});

// ../../packages/core/src/services/generators/directory-structure-generator.ts
class DirectoryStructureGenerator {
  testFileGenerator;
  templateGenerator;
  indexGenerator;
  cliEntryPointGenerator;
  configFileGenerators;
  constructor() {
    this.testFileGenerator = new TestFileGenerator();
    this.templateGenerator = new TemplateGenerator();
    this.indexGenerator = new IndexGenerator();
    this.cliEntryPointGenerator = new CliEntryPointGenerator();
    this.configFileGenerators = new ConfigFileGenerators();
  }
  async createDirectories(basePath, directories) {
    await CoreFileOperations.createDirectories(basePath, directories);
  }
  async createNestedDirectories(basePath, nestedStructure) {
    await CoreFileOperations.createNestedDirectories(basePath, nestedStructure);
  }
  async createDirectoriesWithGitkeep(basePath, directories) {
    await CoreFileOperations.createDirectoriesWithGitkeep(basePath, directories);
  }
  async generateStructureForType(projectType) {
    const mockConfig = {
      name: 'test-project',
      description: 'Test project',
      author: 'Test Author',
      license: 'MIT',
      qualityLevel: 'medium',
      projectType,
      aiAssistants: [],
      template: 'basic',
    };
    return this.generate(mockConfig);
  }
  async generateAndCreateStructureForType(basePath, projectType) {
    const structure = await this.generateStructureForType(projectType);
    await this.createStructureFromDirectoryItems(basePath, structure);
  }
  async createStructureFromDirectoryItems(basePath, structure) {
    await CoreFileOperations.createStructureFromDirectoryItems(basePath, structure);
  }
  async createDirectoryWithPermissions(dirPath, mode) {
    await CoreFileOperations.createDirectoryWithPermissions(dirPath, mode);
  }
  async createCliExecutable(filePath, content) {
    await CoreFileOperations.createCliExecutable(filePath, content);
  }
  async generateMainEntryPoint(basePath, projectName) {
    await EntryPointsGenerator.generateMainEntryPoint(basePath, projectName);
  }
  async generateCliEntryPoint(basePath, cliName, config) {
    await EntryPointsGenerator.generateCliEntryPoint(basePath, cliName, config);
  }
  async generateGitignore(basePath, config) {
    await ConfigurationGenerators.generateGitignore(basePath, config);
  }
  async generatePackageJson(basePath, metadata) {
    await ConfigurationGenerators.generatePackageJson(basePath, metadata);
  }
  async generateTsConfig(basePath, config) {
    await ConfigurationGenerators.generateTsConfig(basePath, config);
  }
  validatePath(basePath, targetPath) {
    CoreFileOperations.validatePath(basePath, targetPath);
  }
  generate(config) {
    const structure = [
      ...ProjectTypeGenerators.generateBaseStructure(),
      ...ProjectTypeGenerators.generateProjectTypeStructure(config.projectType),
      ...this.generateCoreFiles(config),
      ...EntryPointsGenerator.generateEntryPoints(config),
      ...this.generateTestFiles(config),
      ...this.generateDocumentationFiles(config),
      ...ConfigurationGenerators.generateConfigurationFiles(config),
      ...QualityConfigGenerators.generateQualityConfigs(config),
      ...AIConfigGenerators2.generateAIAssistantConfigs(config),
      ...ProjectTypeGenerators.generateGitkeepFiles(config),
      ...this.templateGenerator.generate(config),
    ];
    return CoreFileOperations.normalizeDirectoryItems(structure);
  }
  generateCoreFiles(config) {
    const coreFiles = [
      {
        path: 'src/index.ts',
        type: 'file',
        content: this.indexGenerator.generateIndexFile(config),
      },
    ];
    if (config.projectType === 'web') {
      coreFiles.push(...ProjectTypeGenerators.generateWebCoreFiles(config));
    }
    if (config.projectType === 'library') {
      coreFiles.push(...ProjectTypeGenerators.generateLibraryCoreFiles(config));
    }
    return coreFiles;
  }
  generateTestFiles(config) {
    const testStructureGenerator = new TestStructureGenerator();
    const testStructure = testStructureGenerator.generate(config);
    const testDirectories = testStructure.filter((item) => item.type === 'directory');
    const vitestConfig = testStructure.find((item) => item.path === 'vitest.config.ts');
    return [
      ...testDirectories,
      {
        path: 'tests/setup.ts',
        type: 'file',
        content: this.testFileGenerator.generateTestSetup(config),
      },
      {
        path: 'tests/index.test.ts',
        type: 'file',
        content: this.testFileGenerator.generate(config),
      },
      ...(vitestConfig ? [vitestConfig] : []),
    ];
  }
  generateDocumentationFiles(config) {
    return [
      {
        path: 'README.md',
        type: 'file',
        content: ContentGenerators.generateReadme(config),
      },
      {
        path: 'docs/api.md',
        type: 'file',
        content: ContentGenerators.generateAPIDocumentation(config),
      },
    ];
  }
}
var init_directory_structure_generator = __esm(() => {
  init_cli_entry_point_generator();
  init_config_file_generators();
  init_content_generators();
  init_ai_config_generators();
  init_configuration_generators();
  init_core_file_operations();
  init_entry_points_generator();
  init_index_generator();
  init_quality_config_generators();
  init_template_generator();
  init_test_file_generator();
  init_test_structure_generator();
});

// ../../packages/core/src/services/generators/package-json-generator.ts
var PackageJsonGenerator2;
var init_package_json_generator2 = __esm(() => {
  PackageJsonGenerator2 = class PackageJsonGenerator2 {
    static SCRIPTS = {
      BUN_TEST: 'bun test',
      BUN_TEST_WATCH: 'bun test --watch',
      BUN_TEST_COVERAGE: 'bun test --coverage',
      BUN_TYPECHECK: 'bun run typecheck',
      BUN_BUILD: 'bun run build',
      BUN_LINT: 'bun run lint',
      BUN_LINT_FIX: 'bun run lint:fix',
      BUN_FORMAT: 'bun run format',
      START: 'bun run start',
      DEV: 'bun run dev',
    };
    static EXPORT_PATHS = {
      MAIN_INDEX: './dist/index.js',
      MAIN_TYPES: './dist/index.d.ts',
      STYLES: './dist/styles.css',
    };
    static PROJECT_TYPES = {
      BASIC: 'basic',
      BUN_TYPESCRIPT: 'bun-typescript',
      BUN_REACT: 'bun-react',
      BUN_VUE: 'bun-vue',
      BUN_EXPRESS: 'bun-express',
    };
    static TEMPLATES = {
      basic: 'bun-typescript-eslint-prettier-vitest',
      'bun-typescript': 'bun-typescript-eslint-prettier-vitest',
      'bun-react': 'bun-react-typescript-eslint-prettier-vitest',
      'bun-vue': 'bun-vue-typescript-eslint-prettier-vitest',
      'bun-express': 'bun-express-typescript-eslint-prettier-vitest',
    };
    generate(config) {
      return {
        name: config.name,
        version: '1.0.0',
        description: config.description || '',
        main: 'dist/index.js',
        types: 'dist/index.d.ts',
        scripts: this.generateScripts(config),
        keywords: this.generateKeywords(config),
        author: config.author || '',
        license: config.license || 'MIT',
        devDependencies: this.generateDevDependenciesSync(config),
        engines: {
          bun: '>=1.0.0',
        },
        ...this.generateTypeSpecificFields(config),
      };
    }
    generateScripts(config) {
      const scripts = {
        test: PackageJsonGenerator2.SCRIPTS.BUN_TEST,
        'test:watch': PackageJsonGenerator2.SCRIPTS.BUN_TEST_WATCH,
        'test:coverage': PackageJsonGenerator2.SCRIPTS.BUN_TEST_COVERAGE,
        typecheck: PackageJsonGenerator2.SCRIPTS.BUN_TYPECHECK,
        build: PackageJsonGenerator2.SCRIPTS.BUN_BUILD,
        lint: PackageJsonGenerator2.SCRIPTS.BUN_LINT,
        'lint:fix': PackageJsonGenerator2.SCRIPTS.BUN_LINT_FIX,
        format: PackageJsonGenerator2.SCRIPTS.BUN_FORMAT,
      };
      return { ...scripts, ...this.getTypeSpecificScripts(config) };
    }
    generateKeywords(config) {
      const keywords = ['bun', 'typescript'];
      if (config.projectType !== 'basic') {
        keywords.push(config.projectType);
      }
      if (config.template) {
        keywords.push(PackageJsonGenerator2.TEMPLATES[config.template]);
      }
      if (config.qualityLevel === 'high') {
        keywords.push('quality-assured', 'production-ready');
      }
      return keywords;
    }
    generateDevDependenciesSync(config) {
      const deps = {
        '@types/node': '^20.0.0',
        typescript: '^5.0.0',
        eslint: '^8.0.0',
        '@typescript-eslint/eslint-plugin': '^6.0.0',
        '@typescript-eslint/parser': '^6.0.0',
        prettier: '^3.0.0',
        vitest: '^1.0.0',
        '@vitest/coverage-v8': '^1.0.0',
        turbo: '^2.0.0',
      };
      if (config.qualityLevel === 'high') {
        deps['@stryker-mutator/core'] = '^8.0.0';
        deps['@stryker-mutator/vitest-runner'] = '^8.0.0';
      }
      return { ...deps, ...this.getTypeSpecificDevDependencies(config) };
    }
    generateTypeSpecificFields(config) {
      switch (config.projectType) {
        case 'bun-react':
        case 'web':
          return this.getReactSpecificFields();
        case 'bun-vue':
          return this.getVueSpecificFields();
        case PackageJsonGenerator2.PROJECT_TYPES.BUN_EXPRESS:
          return this.getExpressSpecificFields();
        default:
          return this.getDefaultFields();
      }
    }
    getReactSpecificFields() {
      return {
        dependencies: {
          react: '^18.2.0',
          'react-dom': '^18.2.0',
          '@types/react': '^18.2.0',
          '@types/react-dom': '^18.2.0',
        },
        exports: {
          '.': {
            import: PackageJsonGenerator2.EXPORT_PATHS.MAIN_INDEX,
            types: PackageJsonGenerator2.EXPORT_PATHS.MAIN_TYPES,
          },
          './styles': PackageJsonGenerator2.EXPORT_PATHS.STYLES,
        },
      };
    }
    getVueSpecificFields() {
      return {
        dependencies: {
          vue: '^3.3.0',
          '@vitejs/plugin-vue': '^4.4.0',
        },
        exports: {
          '.': {
            import: PackageJsonGenerator2.EXPORT_PATHS.MAIN_INDEX,
            types: PackageJsonGenerator2.EXPORT_PATHS.MAIN_TYPES,
          },
          './styles': PackageJsonGenerator2.EXPORT_PATHS.STYLES,
        },
      };
    }
    getExpressSpecificFields() {
      return {
        dependencies: {
          express: '^4.18.0',
          '@types/express': '^4.17.0',
          cors: '^2.8.0',
          '@types/cors': '^2.8.0',
          helmet: '^7.0.0',
          morgan: '^1.10.0',
          '@types/morgan': '^1.9.0',
        },
        exports: {
          '.': {
            import: PackageJsonGenerator2.EXPORT_PATHS.MAIN_INDEX,
            types: PackageJsonGenerator2.EXPORT_PATHS.MAIN_TYPES,
          },
        },
      };
    }
    getDefaultFields() {
      return {
        exports: {
          '.': {
            import: PackageJsonGenerator2.EXPORT_PATHS.MAIN_INDEX,
            types: PackageJsonGenerator2.EXPORT_PATHS.MAIN_TYPES,
          },
        },
      };
    }
    getTypeSpecificScripts(config) {
      switch (config.projectType) {
        case 'bun-react':
        case 'bun-vue':
        case PackageJsonGenerator2.PROJECT_TYPES.BUN_EXPRESS:
          return {
            start: PackageJsonGenerator2.SCRIPTS.START,
            dev: PackageJsonGenerator2.SCRIPTS.DEV,
          };
        default:
          return {};
      }
    }
    getTypeSpecificDevDependencies(config) {
      switch (config.projectType) {
        case 'bun-react':
        case 'web':
          return {
            vite: '^5.0.0',
            '@vitejs/plugin-react': '^4.0.0',
            '@types/react': '^18.2.0',
            '@types/react-dom': '^18.2.0',
          };
        case 'bun-vue':
          return {
            vite: '^5.0.0',
            '@vitejs/plugin-vue': '^4.4.0',
          };
        case PackageJsonGenerator2.PROJECT_TYPES.BUN_EXPRESS:
          return {
            nodemon: '^3.0.0',
            'ts-node': '^10.9.0',
          };
        default:
          return {};
      }
    }
  };
});

// ../../packages/core/src/services/validators/project-name-validator.ts
function validateProjectNameRequired(name) {
  if (!name || name.trim().length === 0) {
    return 'Project name is required';
  }
  return null;
}
function validateProjectNameSecurity(name) {
  for (const pattern of DANGEROUS_NAME_PATTERNS) {
    if (pattern.test(name)) {
      return `Invalid project name: "${name}" contains forbidden characters or patterns`;
    }
  }
  return null;
}
function validateProjectNameLength(name) {
  const result = { error: null, warning: null };
  if (name.length === 0) {
    result.error = 'Project name must be at least 1 character long';
  } else if (name.length > MAX_PROJECT_NAME_LENGTH) {
    result.warning = 'Project name exceeds 214 characters, may cause issues on some systems';
  }
  return result;
}
function validateProjectNameFormat(name) {
  if (!PROJECT_NAME_PATTERN.test(name)) {
    return 'Project name must follow npm package naming: lowercase, hyphens only, no spaces';
  }
  return null;
}
function validateProjectNameReserved(name) {
  if (RESERVED_PROJECT_NAMES.includes(name.toLowerCase())) {
    return `"${name}" is a reserved name that may cause conflicts`;
  }
  return null;
}
function validateProjectName2(name, warnings, errors2) {
  const requiredError = validateProjectNameRequired(name);
  if (requiredError) {
    errors2.push(requiredError);
    return;
  }
  const securityError = validateProjectNameSecurity(name);
  if (securityError) {
    errors2.push(securityError);
    return;
  }
  validateRemainingProjectNameAspects(name, warnings, errors2);
}
function validateRemainingProjectNameAspects(name, warnings, errors2) {
  const lengthValidation = validateProjectNameLength(name);
  if (lengthValidation.error) {
    errors2.push(lengthValidation.error);
    return;
  }
  if (lengthValidation.warning) {
    warnings.push(lengthValidation.warning);
  }
  const formatError = validateProjectNameFormat(name);
  if (formatError) {
    errors2.push(formatError);
  }
  const reservedWarning = validateProjectNameReserved(name);
  if (reservedWarning) {
    warnings.push(reservedWarning);
  }
}
var init_project_name_validator = __esm(() => {
  init_validation_constants();
});

// ../../packages/core/src/services/validators/security-validator.ts
function validateDescriptionSecurity(description) {
  const errors2 = [];
  for (const pattern of XSS_PATTERNS) {
    if (pattern.test(description)) {
      errors2.push('Project description contains potentially dangerous content');
      break;
    }
  }
  return errors2;
}
function validateAuthorSecurity(author) {
  const errors2 = [];
  for (const pattern of DANGEROUS_AUTHOR_PATTERNS) {
    if (pattern.test(author)) {
      errors2.push('Author field contains potentially dangerous content');
      break;
    }
  }
  return errors2;
}
function validateDescriptionLength(description) {
  if (description.length > MAX_DESCRIPTION_LENGTH) {
    return 'Project description is very long, consider shortening it';
  }
  return null;
}
function validateAuthorLength(author) {
  if (author.length > MAX_AUTHOR_LENGTH) {
    return 'Author name is quite long';
  }
  return null;
}
function validateAiAssistantsCount(aiAssistants) {
  if (aiAssistants.length > MAX_AI_ASSISTANTS) {
    return 'Using many AI assistants may impact project performance';
  }
  return null;
}
function validateQualityLevelSecurity(qualityLevel) {
  if (qualityLevel === 'light') {
    return 'Light quality level provides minimal security protections';
  }
  return null;
}
function validateSecurityConstraints(config, warnings, errors2) {
  validateDescriptionSecurityAndLength(config.description, warnings, errors2);
  validateAuthorSecurityAndLength(config.author, warnings, errors2);
  validateAiAssistantsConfiguration(config.aiAssistants, warnings);
  validateQualityLevelSecurityImplications(config.qualityLevel, warnings);
}
function validateDescriptionSecurityAndLength(description, warnings, errors2) {
  if (!description) {
    return;
  }
  const descriptionErrors = validateDescriptionSecurity(description);
  errors2.push(...descriptionErrors);
  const lengthWarning = validateDescriptionLength(description);
  if (lengthWarning) {
    warnings.push(lengthWarning);
  }
}
function validateAuthorSecurityAndLength(author, warnings, errors2) {
  if (!author) {
    return;
  }
  const authorErrors = validateAuthorSecurity(author);
  errors2.push(...authorErrors);
  const lengthWarning = validateAuthorLength(author);
  if (lengthWarning) {
    warnings.push(lengthWarning);
  }
}
function validateAiAssistantsConfiguration(aiAssistants, warnings) {
  if (!aiAssistants) {
    return;
  }
  const assistantsWarning = validateAiAssistantsCount(aiAssistants);
  if (assistantsWarning) {
    warnings.push(assistantsWarning);
  }
}
function validateQualityLevelSecurityImplications(qualityLevel, warnings) {
  if (!qualityLevel) {
    return;
  }
  const qualityWarning = validateQualityLevelSecurity(qualityLevel);
  if (qualityWarning) {
    warnings.push(qualityWarning);
  }
}
var init_security_validator = __esm(() => {
  init_validation_constants();
});

// ../../packages/core/src/services/validators/template-compatibility-validator.ts
function isExactMatch(template, projectType) {
  return template === projectType;
}
function checkMatrixCompatibility(template, projectType) {
  const compatibleTypes = COMPATIBILITY_MATRIX[template];
  if (compatibleTypes) {
    return compatibleTypes.includes(projectType);
  }
  return false;
}
function checkDefaultCompatibility(template, projectType) {
  switch (template) {
    case BASIC:
      return [BASIC, BUN_TYPESCRIPT].includes(projectType);
    case BUN_TYPESCRIPT:
      return [BASIC, BUN_TYPESCRIPT, BUN_REACT, BUN_VUE, BUN_EXPRESS].includes(projectType);
    default:
      return true;
  }
}
function isTemplateCompatible(template, projectType) {
  if (isExactMatch(template, projectType)) {
    return true;
  }
  if (checkMatrixCompatibility(template, projectType)) {
    return true;
  }
  return checkDefaultCompatibility(template, projectType);
}
function validateTemplateCompatibility(template, projectType) {
  if (!template || !projectType) {
    return null;
  }
  const isCompatible = isTemplateCompatible(template, projectType);
  if (!isCompatible) {
    return `Template '${template}' may not be compatible with project type '${projectType}'`;
  }
  return null;
}
var COMPATIBILITY_MATRIX;
var init_template_compatibility_validator = __esm(() => {
  init_validation_constants();
  COMPATIBILITY_MATRIX = {
    [BASIC]: [BASIC],
    [BUN_TYPESCRIPT]: [BUN_TYPESCRIPT],
    [BUN_REACT]: [BUN_REACT],
    [BUN_VUE]: [BUN_VUE],
    [BUN_EXPRESS]: [BUN_EXPRESS],
  };
});

// ../../packages/core/src/services/validators/validation-helpers.ts
function validateProjectType(projectType) {
  if (projectType && !VALID_PROJECT_TYPES.includes(projectType)) {
    return ERROR_MESSAGES.INVALID_PROJECT_TYPE(projectType);
  }
  return null;
}
function validateQualityLevel(qualityLevel) {
  if (qualityLevel && !VALID_QUALITY_LEVELS.includes(qualityLevel)) {
    return ERROR_MESSAGES.INVALID_QUALITY_LEVEL(qualityLevel);
  }
  return null;
}
function validateAIAssistants2(aiAssistants) {
  const warnings = [];
  if (!aiAssistants) {
    return warnings;
  }
  for (const assistant of aiAssistants) {
    if (!VALID_AI_ASSISTANTS2.includes(assistant)) {
      warnings.push(ERROR_MESSAGES.INVALID_AI_ASSISTANT(assistant));
    }
  }
  return warnings;
}
function validateLicense(license) {
  if (license && !COMMON_LICENSES.includes(license)) {
    return ERROR_MESSAGES.INVALID_LICENSE(license);
  }
  return null;
}
function validateTargetDirectorySecurity(targetDirectory) {
  const result = { errors: [], warnings: [] };
  if (targetDirectory.includes('..') || targetDirectory.includes('~')) {
    result.errors.push('Target directory cannot contain ".." or "~" for security reasons');
    return result;
  }
  const pathParts = targetDirectory.split(/[/\\]/);
  for (const part of pathParts) {
    if (DANGEROUS_DIRECTORIES.includes(part.toLowerCase())) {
      result.warnings.push(`Target directory contains potentially dangerous path: "${part}"`);
    }
  }
  return result;
}
function validateTargetDirectory(config, warnings, errors2) {
  const targetDir = config.targetDirectory || `./${config.name}`;
  const validation = validateTargetDirectorySecurity(targetDir);
  warnings.push(...validation.warnings);
  errors2.push(...validation.errors);
}
function runAllValidations(config) {
  const warnings = [];
  const errors2 = [];
  validateBasicProjectFields(config, warnings, errors2);
  validateAdvancedProjectFields(config, warnings, errors2);
  return {
    valid: errors2.length === 0,
    warnings,
    errors: errors2,
  };
}
function validateBasicProjectFields(config, warnings, errors2) {
  validateProjectName2(config.name, warnings, errors2);
  const projectTypeWarning = validateProjectType(config.projectType);
  if (projectTypeWarning) {
    warnings.push(projectTypeWarning);
  }
  const qualityWarning = validateQualityLevel(config.qualityLevel);
  if (qualityWarning) {
    warnings.push(qualityWarning);
  }
  const aiWarnings = validateAIAssistants2(config.aiAssistants);
  warnings.push(...aiWarnings);
  const licenseWarning = validateLicense(config.license);
  if (licenseWarning) {
    warnings.push(licenseWarning);
  }
}
function validateAdvancedProjectFields(config, warnings, errors2) {
  const templateWarning = validateTemplateCompatibility(config.template, config.projectType);
  if (templateWarning) {
    warnings.push(templateWarning);
  }
  validateTargetDirectory(config, warnings, errors2);
  validateSecurityConstraints(config, warnings, errors2);
}
var init_validation_helpers = __esm(() => {
  init_project_name_validator();
  init_security_validator();
  init_template_compatibility_validator();
  init_validation_constants();
});

// ../../packages/core/src/services/project-config-processor.ts
class ProjectConfigProcessorImpl {
  packageJsonGenerator;
  directoryStructureGenerator;
  constructor() {
    this.packageJsonGenerator = new PackageJsonGenerator2();
    this.directoryStructureGenerator = new DirectoryStructureGenerator();
  }
  async process(config) {
    const processedConfig = this.applyDefaults(config);
    const validation = await this.validateFinalConfig(processedConfig);
    if (!validation.valid) {
      const errorMsg =
        validation.errors.length > 0 ? validation.errors.join(', ') : 'Unknown validation error';
      throw new Error(`Configuration validation failed: ${errorMsg}`);
    }
    return processedConfig;
  }
  async generatePackageJson(config) {
    return this.packageJsonGenerator.generate(config);
  }
  async generateDirectoryStructure(config) {
    return this.directoryStructureGenerator.generate(config);
  }
  async validateFinalConfig(config) {
    return runAllValidations(config);
  }
  applyDefaults(config) {
    const name = config.name || 'my-project';
    return {
      name,
      description: config.description === undefined ? '' : config.description,
      author: config.author === undefined ? '' : config.author,
      license: config.license || MIT,
      qualityLevel: config.qualityLevel || MEDIUM,
      projectType: config.projectType || BASIC,
      aiAssistants: config.aiAssistants || [CLAUDE_CODE],
      template: config.template,
      targetDirectory: config.targetDirectory || '.',
      nonInteractive: config.nonInteractive || false,
    };
  }
}
var init_project_config_processor = __esm(() => {
  init_directory_structure_generator();
  init_package_json_generator2();
  init_validation_constants();
  init_validation_helpers();
});

// ../../packages/core/src/services/generators/documentation-generator.ts
var init_documentation_generator = __esm(() => {
  init_logger();
  init_content_generators();
});
// ../../packages/core/src/services/generators/configuration-files-generator.ts
var init_configuration_files_generator = __esm(() => {
  init_validation_constants();
  init_config_file_generators();
});

// ../../packages/core/src/index.ts
var init_src = __esm(() => {
  init_directory_structure_generator();
  init_template_generator();
  init_test_file_generator();
  init_test_structure_generator();
  init_index_generator();
  init_documentation_generator();
  init_configuration_files_generator();
  init_defaults();
  init_logger();
  init_project_config_processor();
});

// src/commands/init-config.ts
import { readFileSync as readFileSync3, existsSync } from 'fs';
import { resolve as resolve10 } from 'path';
async function loadConfigurationFile(configPath, output) {
  if (!configPath) {
    return {};
  }
  try {
    const resolvedPath = resolve10(configPath);
    if (!existsSync(resolvedPath)) {
      output.error(
        import_picocolors2.default.red(`${ERROR_MESSAGES2.CONFIG_NOT_FOUND} ${configPath}`)
      );
      process.exit(1);
    }
    const configData = readFileSync3(resolvedPath, 'utf-8');
    const customConfig = JSON.parse(configData);
    output.success(
      import_picocolors2.default.green(`\u2705 Loaded configuration from: ${configPath}`)
    );
    return customConfig;
  } catch (error) {
    output.error(
      import_picocolors2.default.red(`${ERROR_MESSAGES2.CONFIG_LOAD_FAILED} ${configPath}`)
    );
    output.error(
      import_picocolors2.default.red(
        `Error: ${error instanceof Error ? error.message : 'Unknown error'}`
      )
    );
    process.exit(1);
  }
}
async function handleNonInteractiveMode(argv, config2, output) {
  if (!argv.nonInteractive) {
    return config2;
  }
  const argsConfig = buildConfigFromArgs(argv, output);
  const mergedConfig = { ...argsConfig, ...config2 };
  if (!mergedConfig.name && !argv.projectName) {
    output.error(import_picocolors2.default.red(ERROR_MESSAGES2.PROJECT_NAME_REQUIRED));
    output.info(
      import_picocolors2.default.dim('Usage: nimata init <project-name> --non-interactive')
    );
    process.exit(1);
  }
  return mergedConfig;
}
function setProjectNameFromArgs(config2, projectName) {
  if (!config2.name && projectName) {
    config2.name = projectName;
  }
  return config2;
}
async function runNonInteractive(config2, wizard, output) {
  output.info(import_picocolors2.default.blue('\uD83D\uDE80 Running in non-interactive mode...'));
  const validation = wizard.validate(config2);
  if (!validation.valid) {
    output.error(import_picocolors2.default.red('\u274C Configuration validation failed:'));
    for (const error of validation.errors) {
      output.error(import_picocolors2.default.red(`  \u2022 ${error}`));
    }
    throw new Error('Invalid configuration');
  }
  const defaults2 = {
    description: '',
    qualityLevel: 'medium',
    projectType: 'basic',
    aiAssistants: ['claude-code'],
  };
  const finalConfig = {
    ...defaults2,
    ...config2,
  };
  output.success(import_picocolors2.default.green('\u2705 Configuration validated successfully'));
  return finalConfig;
}
async function processConfiguration(config2, deps) {
  const finalConfig = await deps.processor.process(config2);
  return finalConfig;
}
function buildConfigFromArgs(argv, _output) {
  const config2 = {};
  if (argv.projectName) {
    config2.name = argv.projectName;
  }
  if (argv.template) {
    config2.template = argv.template;
    config2.projectType = argv.template;
  }
  if (argv.description) {
    config2.description = argv.description;
  }
  if (argv.author) {
    config2.author = argv.author;
  }
  config2.qualityLevel = argv.quality ? argv.quality : 'medium';
  config2.aiAssistants = argv.ai ? argv.ai.split(',').map((ai) => ai.trim()) : ['claude-code'];
  config2['nonInteractive'] = true;
  return config2;
}
function handleError(error, output) {
  const message = error instanceof Error ? error.message : 'Unknown error occurred';
  output.error(import_picocolors2.default.red(`${ERROR_MESSAGES2.UNKNOWN_ERROR} ${message}`));
  process.exit(1);
}
var import_picocolors2, ERROR_MESSAGES2;
var init_init_config = __esm(() => {
  import_picocolors2 = __toESM(require_picocolors(), 1);
  ERROR_MESSAGES2 = {
    CONFIG_NOT_FOUND: '\u274C Configuration file not found:',
    CONFIG_LOAD_FAILED: '\u274C Failed to load configuration file:',
    PROJECT_NAME_REQUIRED: '\u274C Project name is required in non-interactive mode',
    UNKNOWN_ERROR: '\u274C Error:',
  };
});

// ../../packages/adapters/src/repositories/yaml-config-repository.ts
import { homedir } from 'os';
import { join as join5 } from 'path';
var BYTES_PER_KB = 1024,
  KB_PER_MB = 1024,
  BYTES_PER_MB,
  MAX_NESTING_DEPTH = 10,
  YAMLConfigRepository;
var init_yaml_config_repository = __esm(() => {
  init_src();
  BYTES_PER_MB = BYTES_PER_KB * KB_PER_MB;
  YAMLConfigRepository = class YAMLConfigRepository {
    static MAX_FILE_SIZE_MB = 1;
    static MAX_FILE_SIZE = YAMLConfigRepository.MAX_FILE_SIZE_MB * BYTES_PER_MB;
    static PROJECT_CONFIG_NAME = '.nimatarc';
    cachedConfig = null;
    cacheKey = null;
    async load(projectRoot) {
      const root = projectRoot || process.cwd();
      if (this.cachedConfig && this.cacheKey === root) {
        return this.cachedConfig;
      }
      let config2 = { ...DEFAULT_CONFIG };
      config2 = await this.loadAndMergeGlobalConfig(config2);
      config2 = await this.loadAndMergeProjectConfig(config2, root);
      this.cachedConfig = config2;
      this.cacheKey = root;
      return config2;
    }
    async save(config2, projectRoot) {
      const configPath = join5(projectRoot, YAMLConfigRepository.PROJECT_CONFIG_NAME);
      const yamlString = Bun.YAML.stringify(config2);
      await Bun.write(configPath, yamlString);
      this.cachedConfig = config2;
      this.cacheKey = projectRoot;
    }
    merge(base, override) {
      return deepMerge2(base, override);
    }
    validate(config2) {
      return config2;
    }
    clearCache() {
      this.cachedConfig = null;
      this.cacheKey = null;
    }
    async loadAndMergeGlobalConfig(config2) {
      const home = process.env['HOME'] || homedir();
      const globalConfigPath = join5(home, '.nimata', 'config.yaml');
      const globalConfig = await this.loadConfigFile(globalConfigPath);
      if (globalConfig) {
        return this.merge(config2, globalConfig);
      }
      return config2;
    }
    async loadAndMergeProjectConfig(config2, root) {
      const projectConfigPath = join5(root, YAMLConfigRepository.PROJECT_CONFIG_NAME);
      const projectConfig = await this.loadConfigFile(projectConfigPath);
      if (projectConfig) {
        return this.merge(config2, projectConfig);
      }
      return config2;
    }
    async loadConfigFile(path2) {
      try {
        const file = Bun.file(path2);
        const exists = await file.exists();
        if (!exists) {
          return null;
        }
        await this.validateFileSize({ size: () => Promise.resolve(file.size) });
        const content = await file.text();
        const data = await this.parseAndValidateYAML(content);
        return this.validateConfigSchema(data, path2);
      } catch (error) {
        if (error instanceof Error && error.message.includes('Invalid paths')) {
          throw error;
        }
        throw error;
      }
    }
    validateFileSize = async (file) => {
      const size = await file.size();
      if (size > YAMLConfigRepository.MAX_FILE_SIZE) {
        throw new Error(
          `Configuration file too large: ${size} bytes (max: ${YAMLConfigRepository.MAX_FILE_SIZE} bytes)`
        );
      }
    };
    async parseAndValidateYAML(content) {
      await this.validateYAMLSecurity(content);
      const data = Bun.YAML.parse(content);
      await this.validateNestingDepth(data);
      return data;
    }
    validateConfigSchema(data, path2) {
      const validated = data;
      const pathErrors = validateConfigPaths(validated);
      if (pathErrors.length > 0) {
        throw new Error(`Invalid paths in ${path2}:
${pathErrors.join(`
`)}`);
      }
      return validated;
    }
    async validateYAMLSecurity(yamlString) {
      if (yamlString.includes('&') || yamlString.includes('*')) {
        throw new Error(
          'Config file contains YAML anchors/aliases which are not allowed for security reasons'
        );
      }
      const suspiciousPatterns = [/\${.*}/, /<script/i, /javascript:/i, /data:.*base64/i];
      for (const pattern of suspiciousPatterns) {
        if (pattern.test(yamlString)) {
          throw new Error('Config file contains potentially unsafe content');
        }
      }
    }
    async validateNestingDepth(obj, depth = 0) {
      if (depth > MAX_NESTING_DEPTH) {
        throw new Error(`Config exceeds maximum nesting depth of ${MAX_NESTING_DEPTH} levels`);
      }
      if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
        for (const value of Object.values(obj)) {
          await this.validateNestingDepth(value, depth + 1);
        }
      }
    }
    countEnabledTools(config2) {
      return Object.values(config2.tools).filter((tool) => Boolean(tool && tool['enabled'])).length;
    }
  };
});

// ../../packages/adapters/src/utils/constants-new.ts
var REGEX_PATTERNS, NUMERIC_CONSTANTS;
var init_constants_new = __esm(() => {
  REGEX_PATTERNS = {
    PROJECT_NAME: /^[a-z][\da-z-]*$/,
    START_WITH_LETTER: /^[a-z]/,
    VARIABLE_REFERENCE: /^{{[^}]*$/,
    HELPER_SYNTAX: /^{{helper:[a-z]*}}$/gi,
    HELPER_CALL: /^{{helper:[a-z]*}}$/gi,
    CONDITIONAL_BLOCK: /^{{#if/gi,
    LOOP_BLOCK: /^{{#each/gi,
    SIMPLE_VAR: /{{([^{}]+)}}/g,
    QUOTED_STRING: /^["'][^"']*["']$/,
    BOOL_EXPRESSION: /^[\w.@]+\s*==\s*\S+(?:\s+\S+)*$/i,
    HELPER_CONDITION: /^\(.+\)$/,
    VARIABLE_PATH: /^[\w.@]+$/,
    ARGUMENT_PARTS: /\S+/g,
    ESCAPE_REGEX: /[$()*+.?[\\\]^{|}]/g,
  };
  NUMERIC_CONSTANTS = {
    QUOTE_SLICE_START: 1,
    QUOTE_SLICE_END: -2,
    VAR_SLICE_START: 2,
    VAR_SLICE_END: -2,
    DECIMAL_RADIX: 10,
  };
});

// ../../packages/adapters/src/template-engine/argument-processor.ts
function processHelperArguments(argsString, context) {
  const argsStringTrimmed = argsString.trim();
  if (!argsStringTrimmed) {
    return [];
  }
  const matches = argsStringTrimmed.match(REGEX_PATTERNS.ARGUMENT_PARTS);
  if (!matches) {
    return [];
  }
  return matches
    .filter((part) => typeof part === 'string' && part.length > 0)
    .map((part) => processHelperArgument(part, context));
}
function processHelperArgument(part, context) {
  if (isQuotedArgument(part)) {
    return part.slice(NUMERIC_CONSTANTS.QUOTE_SLICE_START, NUMERIC_CONSTANTS.QUOTE_SLICE_END);
  }
  if (isVariableReference(part)) {
    const varName = part
      .slice(NUMERIC_CONSTANTS.VAR_SLICE_START, NUMERIC_CONSTANTS.VAR_SLICE_END)
      .trim();
    return varName ? getNestedValue(context, varName) : undefined;
  }
  if (REGEX_PATTERNS.VARIABLE_PATH.test(part) && part) {
    return getNestedValue(context, part);
  }
  return part;
}
function isQuotedArgument(part) {
  return (
    (part.startsWith('"') && part.endsWith('"')) || (part.startsWith("'") && part.endsWith("'"))
  );
}
function isVariableReference(part) {
  return part.startsWith('{{') && part.endsWith('}}');
}
function getNestedValue(obj, path2) {
  const parts = path2.split('.');
  let current = obj;
  for (const part of parts) {
    if (current && typeof current === 'object' && part in current) {
      current = current[part];
    } else {
      return;
    }
  }
  return current;
}
var init_argument_processor = __esm(() => {
  init_constants_new();
});

// ../../packages/adapters/src/template-engine/template-helpers.ts
function capitalizeHelper(...args) {
  const str = String(args[0] || '');
  return str ? str.charAt(0).toUpperCase() + str.slice(1) : '';
}
function camelCaseHelper(...args) {
  const str = String(args[0] || '');
  if (!str) return '';
  if (str.length > 0 && str[0] !== undefined && str[0] === str[0].toUpperCase()) {
    return str[0].toLowerCase() + str.slice(1);
  }
  return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
}
function kebabCaseHelper(...args) {
  const str = String(args[0] || '');
  return str
    ? str
        .replace(/([A-Z])/g, '-$1')
        .toLowerCase()
        .replace(/^-/, '')
    : '';
}
function snakeCaseHelper(...args) {
  const str = String(args[0] || '');
  return str ? str.replace(/-([a-z])/g, (_, char) => `_${char}`) : '';
}
function lowercaseHelper(...args) {
  const str = String(args[0] || '');
  return str.toLowerCase();
}
function uppercaseHelper(...args) {
  const str = String(args[0] || '');
  return str.toUpperCase();
}
function pascalCaseHelper(...args) {
  const str = String(args[0] || '');
  if (!str) return '';
  const camelCase2 = str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
  return camelCase2.charAt(0).toUpperCase() + camelCase2.slice(1);
}
function registerCoreStringHelpers(registerHelper) {
  registerHelper('capitalize', capitalizeHelper);
  registerHelper('camelCase', camelCaseHelper);
  registerHelper('kebabCase', kebabCaseHelper);
}
function registerAdditionalStringHelpers(registerHelper) {
  registerHelper('snakeCase', snakeCaseHelper);
  registerHelper('lowercase', lowercaseHelper);
  registerHelper('uppercase', uppercaseHelper);
  registerHelper('kebabcase', kebabCaseHelper);
  registerHelper('pascalcase', pascalCaseHelper);
  registerHelper('pascalCase', pascalCaseHelper);
  registerHelper('pascal_case', pascalCaseHelper);
  registerHelper('camel_case', camelCaseHelper);
  registerHelper('kebab_case', kebabCaseHelper);
  registerHelper('snake_case', snakeCaseHelper);
}
function registerStringHelpers(registerHelper) {
  registerCoreStringHelpers(registerHelper);
  registerAdditionalStringHelpers(registerHelper);
}
function registerArrayHelpers(registerHelper) {
  registerHelper('join', (...args) => {
    const array = args[0];
    const separator = args[1] !== undefined && args[1] !== null ? String(args[1]) : ', ';
    return Array.isArray(array) ? array.join(separator) : String(array || '');
  });
  registerHelper('first', (...args) => {
    const array = args[0];
    return Array.isArray(array) && array.length > 0 ? array[0] : undefined;
  });
  registerHelper('last', (...args) => {
    const array = args[0];
    return Array.isArray(array) && array.length > 0 ? array[array.length - 1] : undefined;
  });
}
function registerConditionalHelpers(registerHelper) {
  registerHelper('eq', (...args) => args[0] === args[1]);
  registerHelper('ne', (...args) => args[0] !== args[1]);
  registerHelper('gt', (...args) => Number(args[0]) > Number(args[1]));
  registerHelper('gte', (...args) => Number(args[0]) >= Number(args[1]));
  registerHelper('lt', (...args) => Number(args[0]) < Number(args[1]));
  registerHelper('lte', (...args) => Number(args[0]) <= Number(args[1]));
}
function registerUtilityHelpers(registerHelper) {
  registerHelper('now', () => new Date().toISOString());
  registerHelper('year', () => new Date().getFullYear());
}

// ../../packages/adapters/src/template-engine/conditional-processor.ts
function findConditionalBlock(template, startPos) {
  const ifStart = template.indexOf('{{#if ', startPos);
  if (ifStart === -1) return null;
  const ifEnd = template.indexOf('}}', ifStart);
  if (ifEnd === -1) return null;
  const condition = template.slice(ifStart + IF_TOKEN_LENGTH, ifEnd).trim();
  const elseStart = template.indexOf('{{else}}', ifEnd);
  const endIfStart = template.indexOf('{{/if}}', ifEnd);
  if (endIfStart === -1) return null;
  return { ifStart, ifEnd, condition, elseStart, endIfStart };
}
function extractConditionalContent(template, ifEnd, elseStart, endIfStart) {
  return elseStart !== -1 && elseStart < endIfStart
    ? {
        ifContent: template.slice(ifEnd + BRACE_LENGTH, elseStart),
        elseContent: template.slice(elseStart + ELSE_TOKEN_LENGTH, endIfStart),
      }
    : {
        ifContent: template.slice(ifEnd + BRACE_LENGTH, endIfStart),
        elseContent: '',
      };
}
async function processSingleConditional(template, context, currentPos) {
  const block = findConditionalBlock(template, currentPos);
  if (!block) {
    return Promise.resolve({
      content: template.slice(currentPos),
      newPos: template.length,
      finished: true,
    });
  }
  const { ifStart, ifEnd, condition, elseStart, endIfStart } = block;
  const { ifContent, elseContent } = extractConditionalContent(
    template,
    ifEnd,
    elseStart,
    endIfStart
  );
  const shouldRender = evaluateCondition(condition, context);
  const selectedContent = shouldRender ? ifContent : elseContent;
  const result = [template.slice(currentPos, ifStart), selectedContent];
  return Promise.resolve({
    content: result.join(''),
    newPos: endIfStart + ENDIF_TOKEN_LENGTH,
    finished: false,
  });
}
function evaluateCondition(condition, context) {
  const cleanCondition = condition.replace(/["']/g, '').trim();
  if (cleanCondition === 'true') return true;
  if (cleanCondition === 'false') return false;
  if (cleanCondition === 'null' || cleanCondition === 'undefined') return false;
  if (cleanCondition.includes('&&')) {
    const parts = cleanCondition.split('&&').map((p) => p.trim());
    return parts.every((part) => evaluateCondition(part, context));
  }
  if (cleanCondition.includes('||')) {
    const parts = cleanCondition.split('||').map((p) => p.trim());
    return parts.some((part) => evaluateCondition(part, context));
  }
  if (cleanCondition.startsWith('!')) {
    return !evaluateCondition(cleanCondition.slice(1), context);
  }
  const value = getNestedValue(context, cleanCondition);
  return value != null && Boolean(value);
}
async function processConditionalPass(currentTemplate, context) {
  let hasChanges = false;
  const result = [];
  let pos = 0;
  while (pos < currentTemplate.length) {
    const processed = await processSingleConditional(currentTemplate, context, pos);
    if (processed.content !== currentTemplate.slice(pos, processed.newPos)) {
      hasChanges = true;
    }
    result.push(processed.content);
    if (processed.finished) {
      break;
    }
    pos = processed.newPos;
  }
  return [hasChanges, result.join('')];
}
async function processConditionals(template, context) {
  let currentTemplate = template;
  let hasChanges = true;
  while (hasChanges) {
    const [changed, newTemplate] = await processConditionalPass(currentTemplate, context);
    hasChanges = changed && newTemplate !== currentTemplate;
    currentTemplate = newTemplate;
  }
  return currentTemplate;
}
var IF_TOKEN_LENGTH = 6,
  ELSE_TOKEN_LENGTH = 8,
  ENDIF_TOKEN_LENGTH = 7,
  BRACE_LENGTH = 2;
var init_conditional_processor = __esm(() => {
  init_argument_processor();
});

// ../../packages/adapters/src/template-engine/helper-processor.ts
var exports_helper_processor = {};
__export(exports_helper_processor, {
  processHelpers: () => processHelpers,
});
function findNextHelperMatch(template, startPos) {
  const helperRegex = /{{helper:([A-Z_a-z][\w-]*)(?:\s+|}})/;
  const match = template.substring(startPos).match(helperRegex);
  if (!match) return null;
  const matchIndex = template.indexOf(match[0], startPos);
  const helperName = match[1] || '';
  const hasNoArgs = match[0].endsWith('}}');
  const closingBraceIndex = hasNoArgs
    ? matchIndex + match[0].length - DOUBLE_BRACE_LENGTH
    : template.indexOf('}}', matchIndex + match[0].length);
  if (closingBraceIndex === -1) return null;
  return { match, matchIndex, helperName, closingBraceIndex, hasNoArgs };
}
function extractHelperArguments(template, params) {
  const { matchIndex, match, closingBraceIndex, hasNoArgs } = params;
  return hasNoArgs ? '' : template.substring(matchIndex + match[0].length, closingBraceIndex);
}
function executeHelper(helper, argsString, context) {
  try {
    const args = processHelperArguments(argsString, context);
    const helperResult = helper(...args);
    return String(helperResult);
  } catch {
    return '';
  }
}
function processSingleHelper(template, matchInfo, context, helpers) {
  const { match, matchIndex, helperName, closingBraceIndex, hasNoArgs } = matchInfo;
  const argsString = extractHelperArguments(template, {
    matchIndex,
    match,
    closingBraceIndex,
    hasNoArgs,
  });
  const helper = helpers.get(helperName || '');
  if (helper) {
    return executeHelper(helper, argsString, context);
  }
  return template.substring(matchIndex, closingBraceIndex + DOUBLE_BRACE_LENGTH);
}
async function processHelpers(template, context, helpers = new Map()) {
  let result = '';
  let pos = 0;
  while (pos < template.length) {
    const matchInfo = findNextHelperMatch(template, pos);
    if (!matchInfo) {
      result += template.substring(pos);
      break;
    }
    const { matchIndex, closingBraceIndex } = matchInfo;
    result += template.substring(pos, matchIndex);
    result += processSingleHelper(template, matchInfo, context, helpers);
    pos = closingBraceIndex + DOUBLE_BRACE_LENGTH;
  }
  return result;
}
var DOUBLE_BRACE_LENGTH = 2;
var init_helper_processor = __esm(() => {
  init_argument_processor();
});

// ../../packages/adapters/src/template-engine/loop-processor.ts
var exports_loop_processor = {};
__export(exports_loop_processor, {
  processLoops: () => processLoops,
});
function createLoopItemContext(params) {
  const { baseContext, item, index, arrayLength, arrayName, key } = params;
  const itemContext = {
    ...baseContext,
    this: item,
    '@index': index.toString(),
    '@first': index === 0,
    '@last': index === arrayLength - 1,
    '@key': key?.toString() || '',
  };
  if (arrayName) {
    itemContext[arrayName] = item;
  }
  if (item && typeof item === 'object' && !Array.isArray(item)) {
    const itemObj = item;
    for (const [key2, value] of Object.entries(itemObj)) {
      itemContext[key2] = value;
    }
  }
  return itemContext;
}
async function processLoopItem(content, itemContext) {
  let processedContent = content;
  const { processHelpers: processHelpers2 } = await Promise.resolve().then(
    () => (init_helper_processor(), exports_helper_processor)
  );
  processedContent = await processHelpers2(processedContent, itemContext);
  const { processLoops } = await Promise.resolve().then(
    () => (init_loop_processor(), exports_loop_processor)
  );
  processedContent = await processLoops(processedContent, itemContext);
  processedContent = processedContent.replace(REGEX_PATTERNS.SIMPLE_VAR, (match, variablePath) => {
    const trimmedPath = variablePath.trim();
    const value = getNestedValue(itemContext, trimmedPath);
    return value === null || value === undefined ? '' : String(value);
  });
  return processedContent;
}
async function processArrayItems(array, content, context, arrayName) {
  const processedItems = [];
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    const itemContext = createLoopItemContext({
      baseContext: context,
      item,
      index: i,
      arrayLength: array.length,
      arrayName,
    });
    let processedContent = await processLoopItem(content, itemContext);
    if (i === array.length - 1) {
      processedContent = processedContent.replace(/,\s*$/, '');
    }
    processedItems.push(processedContent);
  }
  return processedItems.join('');
}
async function processObjectItems(obj, content, context, objectName) {
  const processedItems = [];
  let i = 0;
  const keys = Object.keys(obj);
  for (const key of keys) {
    const value = obj[key];
    const itemContext = createLoopItemContext({
      baseContext: context,
      item: value,
      index: i,
      arrayLength: keys.length,
      arrayName: objectName,
      key,
    });
    let processedContent = await processLoopItem(content, itemContext);
    if (i === keys.length - 1) {
      processedContent = processedContent.replace(/,\s*$/, '');
    }
    processedItems.push(processedContent);
    i++;
  }
  return processedItems.join('');
}
function findClosingTag(template, contentStart) {
  let depth = 1;
  let j = contentStart;
  const EACH_START_TAG = '{{#each';
  const EACH_END_TAG = '{{/each}}';
  while (j < template.length && depth > 0) {
    if (template.substring(j).startsWith(EACH_START_TAG)) {
      depth++;
      j += EACH_START_TAG.length;
    } else if (template.substring(j).startsWith(EACH_END_TAG)) {
      depth--;
      if (depth === 0) {
        return j;
      }
      j += EACH_END_TAG.length;
    } else {
      j++;
    }
  }
  return -1;
}
function extractLoopMatch(template, startIndex, arrayName, match) {
  const contentStart = startIndex + match[0].length;
  const closingPos = findClosingTag(template, contentStart);
  if (closingPos === -1) {
    return null;
  }
  const EACH_END_TAG = '{{/each}}';
  const content = template.substring(contentStart, closingPos);
  const fullMatch = template.substring(startIndex, closingPos + EACH_END_TAG.length);
  return {
    fullMatch,
    arrayName,
    content,
    startIndex,
    endIndex: closingPos + EACH_END_TAG.length,
  };
}
function processLoopStart(params) {
  const { template, position, depth, results, pattern } = params;
  const remainder = template.substring(position);
  const match = remainder.match(pattern);
  if (match && depth === 0) {
    const arrayName = match[1] || '';
    const loopMatch = extractLoopMatch(template, position, arrayName, match);
    if (loopMatch) {
      results.push(loopMatch);
      return loopMatch.endIndex - 1;
    }
  }
  return position + '{{#each'.length;
}
function findTopLevelLoops(template) {
  const results = [];
  const startPattern = /^{{#each\s+([\w.]+)}}/;
  const EACH_START = '{{#each';
  const EACH_END = '{{/each}}';
  let currentDepth = 0;
  let i = 0;
  while (i < template.length) {
    const remainder = template.substring(i);
    if (remainder.startsWith(EACH_START)) {
      i = processLoopStart({
        template,
        position: i,
        depth: currentDepth,
        results,
        pattern: startPattern,
      });
      currentDepth++;
    } else if (remainder.startsWith(EACH_END)) {
      currentDepth--;
      i += EACH_END.length;
    } else {
      i++;
    }
  }
  return results;
}
async function processLoopIteration(currentResult, context) {
  const matches = findTopLevelLoops(currentResult);
  matches.sort((a, b) => a.startIndex - b.startIndex);
  const firstMatch = matches[0];
  if (!firstMatch) {
    return [false, currentResult];
  }
  const { fullMatch, arrayName, content } = firstMatch;
  const processedContent = await processEachBlock(fullMatch, arrayName, content, context);
  return [true, currentResult.replace(fullMatch, processedContent)];
}
async function processLoops(template, context) {
  let result = template;
  let hasChanges = true;
  while (hasChanges) {
    [hasChanges, result] = await processLoopIteration(result, context);
  }
  return result;
}
async function processEachBlock(fullMatch, arrayName, content, context) {
  const value = getNestedValue(context, arrayName ?? '');
  if (!Array.isArray(value) && typeof value !== 'object') {
    return '';
  }
  if (Array.isArray(value)) {
    return processArrayItems(value, content, context, arrayName);
  }
  if (value && typeof value === 'object') {
    return processObjectItems(value, content, context, arrayName);
  }
  return '';
}
var init_loop_processor = __esm(() => {
  init_constants_new();
  init_argument_processor();
});

// ../../packages/adapters/src/template-engine/variable-processor.ts
var init_variable_processor = __esm(() => {
  init_constants_new();
  init_argument_processor();
});

// ../../packages/adapters/src/template-engine/template-processor.ts
var init_template_processor = __esm(() => {
  init_conditional_processor();
  init_helper_processor();
  init_loop_processor();
  init_variable_processor();
});

// ../../packages/adapters/src/template-engine/template-validator.ts
function validateTemplateSyntax(template, helpers) {
  const errors2 = [];
  validateBlockPairs(template, errors2);
  validateVariableReferences(template, errors2);
  validateHelperSyntax(template, helpers, errors2);
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function validateBlockPairs(template, errors2) {
  const blockPairs = [
    { open: '{{#if', close: '{{/if', name: '{{#if}}' },
    { open: '{{#each', close: '{{/each', name: '{{#each}}' },
  ];
  for (const { open, close, name } of blockPairs) {
    const openCount = (template.match(new RegExp(escapeRegExp(open), 'g')) || []).length;
    const closeCount = (template.match(new RegExp(escapeRegExp(close), 'g')) || []).length;
    if (openCount !== closeCount) {
      errors2.push(`Unclosed ${name} blocks: ${openCount} open, ${closeCount} closed`);
    }
  }
}
function validateVariableReferences(template, errors2) {
  const malformedVars = template.match(REGEX_PATTERNS.VARIABLE_REFERENCE);
  if (malformedVars) {
    errors2.push(`Malformed variable references: ${malformedVars.join(', ')}`);
  }
}
function validateHelperSyntax(template, helpers, errors2) {
  const helperMatches = template.match(REGEX_PATTERNS.HELPER_SYNTAX);
  if (!helperMatches) {
    return;
  }
  for (const match of helperMatches) {
    const helperName = match.match(/{{helper:([A-Z_a-z]\w*)}}/)?.[1];
    if (helperName && !helpers.has(helperName)) {
      errors2.push(`Unknown helper: ${helperName}`);
    }
  }
}
function escapeRegExp(string) {
  return string.replace(REGEX_PATTERNS.ESCAPE_REGEX, '\\$&');
}
function validateTemplateStructure(template) {
  const errors2 = [];
  validateBasicTemplateFields(template, errors2);
  validateTemplateArrays(template, errors2);
  validateTemplateFiles(template, errors2);
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function validateBasicTemplateFields(template, errors2) {
  if (!template.name) {
    errors2.push('Template name is required');
  }
  if (!template.version) {
    errors2.push('Template version is required');
  }
}
function validateTemplateArrays(template, errors2) {
  if (!Array.isArray(template.supportedProjectTypes)) {
    errors2.push('Template supportedProjectTypes must be an array');
  }
  if (!Array.isArray(template.variables)) {
    errors2.push('Template variables must be an array');
  }
}
function validateTemplateFiles(template, errors2) {
  if (!Array.isArray(template.files)) {
    errors2.push('Template files must be an array');
    return;
  }
  for (const [index, file] of template.files.entries()) {
    validateTemplateFile(file, index, errors2);
  }
}
function validateTemplateFile(file, index, errors2) {
  if (!file.path) {
    errors2.push(`File ${index}: path is required`);
  }
  if (!file.template) {
    errors2.push(`File ${index}: template is required`);
  }
}
var init_template_validator = __esm(() => {
  init_constants_new();
});

// ../../packages/adapters/src/template-engine.ts
import fs7 from 'fs/promises';
import path2 from 'path';

class TemplateEngine {
  helpers = new Map();
  templatesDir;
  constructor(templatesDir) {
    if (templatesDir) {
      this.templatesDir = templatesDir;
    } else {
      const currentFilePath = new URL(import.meta.url).pathname;
      const currentDir = path2.dirname(currentFilePath);
      this.templatesDir = path2.resolve(currentDir, '../templates');
    }
    this.registerDefaultHelpers();
  }
  async loadTemplate(templateName) {
    const templatePath = path2.join(this.templatesDir, `${templateName}.json`);
    try {
      const content = await fs7.readFile(templatePath, 'utf-8');
      const template = JSON.parse(content);
      const validation = validateTemplateStructure(template);
      if (!validation.valid) {
        throw new Error(`Invalid template structure: ${validation.errors.join(', ')}`);
      }
      return template;
    } catch (error) {
      if (error instanceof Error && error.message.includes('ENOENT')) {
        throw new Error(`Template '${templateName}' not found at ${templatePath}`);
      }
      throw error;
    }
  }
  processPipeVariable(trimmedPath, context) {
    const pipeMatch = trimmedPath.match(/^([^|]+)\|(\w+)$/);
    if (!pipeMatch) return '';
    const [, varName, helperName] = pipeMatch;
    const value = getNestedValue(context, varName || '');
    if (value === undefined || value === null) {
      return '';
    }
    const helper = this.helpers.get(helperName || '');
    if (helper) {
      try {
        return String(helper(value));
      } catch {
        return String(value);
      }
    }
    return String(value);
  }
  processSimpleVariables(result, context) {
    return result.replace(REGEX_PATTERNS.SIMPLE_VAR, (match, variablePath) => {
      const trimmedPath = variablePath.trim();
      const pipeMatch = trimmedPath.match(/^([^|]+)\|(\w+)$/);
      if (pipeMatch) {
        return this.processPipeVariable(trimmedPath, context);
      }
      const value = getNestedValue(context, trimmedPath);
      if (value === undefined || value === null) {
        return '';
      }
      return String(value);
    });
  }
  async renderTemplate(template, context) {
    let result = template;
    let hasChanges = true;
    while (hasChanges) {
      hasChanges = false;
      const previousResult = result;
      result = await processHelpers(result, context, this.helpers);
      result = await processConditionals(result, context);
      result = await processLoops(result, context);
      result = this.processSimpleVariables(result, context);
      if (result !== previousResult) {
        hasChanges = true;
      }
    }
    return this.finalCleanup(result, context);
  }
  finalCleanup(result, context) {
    let finalResult = result;
    let hasChanges = true;
    const MAX_PROCESSING_PASSES = 3;
    for (let i = 0; i < MAX_PROCESSING_PASSES && hasChanges; i++) {
      hasChanges = false;
      const previousResult = finalResult;
      finalResult = this.processSimpleVariables(finalResult, context);
      if (finalResult !== previousResult) {
        hasChanges = true;
      }
    }
    return finalResult;
  }
  validateTemplate(template) {
    return validateTemplateSyntax(template, this.helpers);
  }
  async processProjectTemplate(projectTemplate, context) {
    const generatedFiles = [];
    for (const file of projectTemplate.files) {
      if (file.condition) {
        const conditionValue = context[file.condition];
        const shouldRender = Boolean(conditionValue);
        if (!shouldRender) {
          continue;
        }
      }
      try {
        const content = await this.renderTemplate(file.template, context);
        const filePath = await this.renderTemplate(file.path, context);
        generatedFiles.push({
          path: filePath,
          content,
          permissions: file.permissions,
        });
      } catch (error) {
        throw new Error(
          `Failed to process file '${file.path}': ${error instanceof Error ? error.message : 'Unknown error'}`
        );
      }
    }
    return generatedFiles;
  }
  registerHelper(name, helper) {
    this.helpers.set(name, helper);
  }
  async getAvailableTemplates() {
    try {
      const files = await fs7.readdir(this.templatesDir);
      return files
        .filter((file) => file.endsWith('.json'))
        .map((file) => file.replace('.json', ''));
    } catch {
      return [];
    }
  }
  registerDefaultHelpers() {
    registerStringHelpers(this.registerHelper.bind(this));
    registerArrayHelpers(this.registerHelper.bind(this));
    registerConditionalHelpers(this.registerHelper.bind(this));
    registerUtilityHelpers(this.registerHelper.bind(this));
  }
}
var init_template_engine = __esm(() => {
  init_argument_processor();
  init_template_processor();
  init_template_validator();
  init_constants_new();
});

// ../../packages/adapters/src/generators/project-generator-helpers.ts
function createBaseResult() {
  return {
    success: false,
    files: [],
    errors: [],
    warnings: [],
    duration: 0,
  };
}
function handleUnexpectedError(error, startTime) {
  const result = createBaseResult();
  result.errors.push(
    `Unexpected error: ${error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE2}`
  );
  result.duration = Date.now() - startTime;
  return result;
}
function createErrorResult(result, errorMessage, errors2, startTime) {
  result.success = false;
  result.errors.push(errorMessage);
  if (errors2.length > 0) {
    result.errors.push(...errors2);
  }
  result.duration = Date.now() - startTime;
  return result;
}
async function createSuccessResult(files, projectDir, startTime, addValidationWarnings) {
  const result = {
    success: true,
    files,
    errors: [],
    warnings: [],
    duration: Date.now() - startTime,
  };
  await addValidationWarnings(result, projectDir);
  return result;
}
function normalizeQualityLevel(level) {
  return level === 'high' ? 'strict' : level;
}
function normalizeProjectType(type) {
  const projectTypeMap = {
    basic: 'basic',
    web: 'web',
    cli: 'cli',
    library: 'library',
    'bun-react': 'web',
    'bun-vue': 'web',
    'bun-express': 'web',
    'bun-typescript': 'basic',
  };
  return projectTypeMap[type] || 'basic';
}
function normalizeConfigForGenerators(config2) {
  const qualityLevel = normalizeQualityLevel(config2.qualityLevel);
  const projectType = normalizeProjectType(config2.projectType);
  const aiAssistants = config2.aiAssistants.filter(
    (assistant) => assistant === 'claude-code' || assistant === 'copilot'
  );
  return {
    name: config2.name,
    description: config2.description,
    qualityLevel,
    projectType,
    aiAssistants,
  };
}
var UNKNOWN_ERROR_MESSAGE2 = 'Unknown error';

// ../../packages/adapters/src/utils/project-generation-constants.ts
var PROJECT_GENERATION_CONSTANTS;
var init_project_generation_constants = __esm(() => {
  PROJECT_GENERATION_CONSTANTS = {
    MAX_DESCRIPTION_LENGTH: 500,
    MAX_AUTHOR_NAME_LENGTH: 100,
    MAX_NAME_LENGTH: 50,
    VALID_PROJECT_TYPES: [
      'basic',
      'web',
      'cli',
      'library',
      'bun-react',
      'bun-vue',
      'bun-express',
      'bun-typescript',
    ],
    VALID_QUALITY_LEVELS: ['light', 'medium', 'strict', 'high'],
    VALID_AI_ASSISTANTS: ['claude-code', 'copilot', 'github-copilot', 'ai-context', 'cursor'],
    ERROR_MESSAGES: {
      PROJECT_NAME_REQUIRED: 'Project name is required',
      QUALITY_LEVEL_REQUIRED: 'Quality level is required',
      PROJECT_TYPE_REQUIRED: 'Project type is required',
      AI_ASSISTANT_REQUIRED: 'At least one AI assistant must be selected',
      INVALID_QUALITY_LEVEL: 'Invalid quality level. Must be: light, medium, strict, or high',
      INVALID_PROJECT_TYPE:
        'Invalid project type. Must be: basic, web, cli, library, bun-react, bun-vue, bun-express, or bun-typescript',
      INVALID_AI_ASSISTANTS: (invalid) =>
        `Invalid AI assistants: ${invalid.join(', ')}. Valid options: claude-code, copilot, github-copilot, ai-context, cursor`,
      DESCRIPTION_TOO_LONG: (max) => `Description must be less than ${max} characters`,
      AUTHOR_NAME_TOO_LONG: (max) => `Author name must be less than ${max} characters`,
      INVALID_LICENSE: 'Invalid license. Use a valid SPDX license identifier or leave empty',
    },
    PROJECT_NAME_PATTERN: /^[\d_a-z-]+$/,
    PROJECT_NAME_START_PATTERN: /^[\d.]/,
  };
});

// ../../packages/adapters/src/utils/project-validation-helpers.ts
function validateProjectNameConfig(config2, errors2) {
  if (!config2.name) {
    errors2.push(PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.PROJECT_NAME_REQUIRED);
    return;
  }
  const nameValidation = validateProjectName3(config2.name);
  if (!nameValidation.valid) {
    errors2.push(...nameValidation.errors);
  }
}
function validateQualityLevelConfig(config2, errors2) {
  if (!config2.qualityLevel) {
    errors2.push(PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.QUALITY_LEVEL_REQUIRED);
    return;
  }
  if (!PROJECT_GENERATION_CONSTANTS.VALID_QUALITY_LEVELS.includes(config2.qualityLevel)) {
    errors2.push(PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.INVALID_QUALITY_LEVEL);
  }
}
function validateProjectTypeConfig(config2, errors2) {
  if (!config2.projectType) {
    errors2.push(PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.PROJECT_TYPE_REQUIRED);
    return;
  }
  if (!PROJECT_GENERATION_CONSTANTS.VALID_PROJECT_TYPES.includes(config2.projectType)) {
    errors2.push(PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.INVALID_PROJECT_TYPE);
  }
}
function validateAIAssistantsConfig(config2, errors2) {
  if (!config2.aiAssistants || config2.aiAssistants.length === 0) {
    errors2.push(PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.AI_ASSISTANT_REQUIRED);
    return;
  }
  const invalidAssistants = config2.aiAssistants.filter(
    (assistant) => !PROJECT_GENERATION_CONSTANTS.VALID_AI_ASSISTANTS.includes(assistant)
  );
  if (invalidAssistants.length > 0) {
    errors2.push(
      PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.INVALID_AI_ASSISTANTS(invalidAssistants)
    );
  }
}
function validateOptionalConfig(config2, errors2) {
  if (
    config2.description &&
    config2.description.length > PROJECT_GENERATION_CONSTANTS.MAX_DESCRIPTION_LENGTH
  ) {
    errors2.push(
      PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.DESCRIPTION_TOO_LONG(
        PROJECT_GENERATION_CONSTANTS.MAX_DESCRIPTION_LENGTH
      )
    );
  }
  if (
    config2.author &&
    config2.author.length > PROJECT_GENERATION_CONSTANTS.MAX_AUTHOR_NAME_LENGTH
  ) {
    errors2.push(
      PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.AUTHOR_NAME_TOO_LONG(
        PROJECT_GENERATION_CONSTANTS.MAX_AUTHOR_NAME_LENGTH
      )
    );
  }
  if (config2.license && !isValidLicense2(config2.license)) {
    errors2.push(PROJECT_GENERATION_CONSTANTS.ERROR_MESSAGES.INVALID_LICENSE);
  }
}
function validateProjectName3(name) {
  const errors2 = [];
  if (!PROJECT_GENERATION_CONSTANTS.PROJECT_NAME_PATTERN.test(name)) {
    errors2.push(
      'Project name must contain only lowercase letters, numbers, hyphens, and underscores'
    );
  }
  if (name.length === 0 || name.length > PROJECT_GENERATION_CONSTANTS.MAX_NAME_LENGTH) {
    errors2.push(
      `Project name must be between 1 and ${PROJECT_GENERATION_CONSTANTS.MAX_NAME_LENGTH} characters`
    );
  }
  if (PROJECT_GENERATION_CONSTANTS.PROJECT_NAME_START_PATTERN.test(name)) {
    errors2.push('Project name cannot start with a number or dot');
  }
  const reservedNames = ['npm', 'node', 'bun', 'test', 'lib', 'bin', 'config'];
  if (reservedNames.includes(name)) {
    errors2.push(`Project name '${name}' is reserved`);
  }
  if (name.includes('..') || name.startsWith('.') || name.endsWith('.')) {
    errors2.push('Project name cannot contain consecutive dots or start/end with dots');
  }
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function isValidLicense2(license) {
  const validLicenses = [
    'MIT',
    'Apache-2.0',
    'GPL-3.0-or-later',
    'BSD-3-Clause',
    'BSD-2-Clause',
    'ISC',
    'LGPL-3.0-or-later',
    'AGPL-3.0-or-later',
    'Unlicense',
    'CC0-1.0',
    'MPL-2.0',
    'BSL-1.0',
    'Zlib',
    'WTFPL',
    '0BSD',
  ];
  return validLicenses.includes(license) || /^[\d.A-Za-z-]+$/.test(license);
}
var init_project_validation_helpers = __esm(() => {
  init_project_generation_constants();
});

// ../../packages/adapters/src/utils/project-generation-helpers.ts
import fs8 from 'fs/promises';
import path3 from 'path';
function validateFilePermissions(mode) {
  if ((mode & WORLD_WRITABLE_BIT) !== 0) {
    return false;
  }
  if ((mode & SETUID_SETGID_BITS) !== 0) {
    return false;
  }
  const safePermissions = SAFE_FILE_PERMISSIONS;
  return safePermissions.includes(mode);
}
async function setFilePermissions(filePath, permissions) {
  const mode = Number.parseInt(permissions, 8);
  if (!validateFilePermissions(mode)) {
    throw new Error(
      `Unsafe file permissions: ${permissions}. Only allow read/write for owner and group, and read for others.`
    );
  }
  await fs8.chmod(filePath, mode);
}
function validateRequiredConfigFields(config2) {
  const errors2 = [];
  validateProjectNameConfig(config2, errors2);
  validateQualityLevelConfig(config2, errors2);
  validateProjectTypeConfig(config2, errors2);
  validateAIAssistantsConfig(config2, errors2);
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
function validateOptionalConfigFields(config2) {
  const errors2 = [];
  validateOptionalConfig(config2, errors2);
  return {
    valid: errors2.length === 0,
    errors: errors2,
  };
}
async function checkDirectoryExists(projectDir, allowExisting = true) {
  try {
    await fs8.access(projectDir);
    if (!allowExisting) {
      throw new Error(`Directory already exists: ${projectDir}`);
    }
  } catch (error) {
    if (error instanceof Error && error.message.includes('already exists')) {
      throw error;
    }
  }
}
async function writeFilesToDisk(files, projectDir) {
  const writeErrors = [];
  for (const file of files) {
    try {
      const filePath = path3.join(projectDir, file.path);
      const fileDir = path3.dirname(filePath);
      await fs8.mkdir(fileDir, { recursive: true });
      await fs8.writeFile(filePath, file.content, { encoding: 'utf-8' });
      if (file.permissions) {
        await setFilePermissions(filePath, file.permissions);
      }
    } catch (error) {
      writeErrors.push(
        `Failed to write file '${file.path}': ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }
  return writeErrors;
}
async function validateRequiredFiles(projectPath) {
  const errors2 = [];
  const requiredFiles = ['package.json', 'tsconfig.json'];
  for (const file of requiredFiles) {
    const filePath = path3.join(projectPath, file);
    try {
      await fs8.access(filePath);
    } catch {
      errors2.push(`Missing required file: ${file}`);
    }
  }
  return errors2;
}
async function validateSrcDirectory(projectPath) {
  const errors2 = [];
  const srcDir = path3.join(projectPath, 'src');
  try {
    await fs8.access(srcDir);
    const indexFile = path3.join(srcDir, 'index.ts');
    try {
      await fs8.access(indexFile);
    } catch {
      errors2.push('Missing src/index.ts file');
    }
  } catch {
    errors2.push('Missing src directory');
  }
  return errors2;
}
function validateBasicPackageFields(packageJson, errors2) {
  if (!packageJson['name']) {
    errors2.push('package.json missing name field');
  }
  if (!packageJson['version']) {
    errors2.push('package.json missing version field');
  }
}
function validatePackageScripts(packageJson, errors2) {
  if (packageJson['scripts']) {
    const requiredScripts = ['build', 'test', 'lint'];
    for (const script of requiredScripts) {
      if (!packageJson['scripts'][script]) {
        errors2.push(`package.json missing script: ${script}`);
      }
    }
  } else {
    errors2.push('package.json missing scripts field');
  }
}
async function validatePackageJson(projectPath) {
  const errors2 = [];
  try {
    const packageJsonPath = path3.join(projectPath, 'package.json');
    const packageContent = await fs8.readFile(packageJsonPath, 'utf-8');
    const packageJson = JSON.parse(packageContent);
    validateBasicPackageFields(packageJson, errors2);
    validatePackageScripts(packageJson, errors2);
  } catch {
    errors2.push('Invalid package.json format');
  }
  return errors2;
}
var WORLD_WRITABLE_BIT = 2,
  SETUID_SETGID_BITS = 3072;
var init_project_generation_helpers = __esm(() => {
  init_constants();
  init_project_validation_helpers();
});

// ../../packages/adapters/src/utils/string-utils.ts
function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
}
function toPascalCase2(str) {
  const camelCase2 = toCamelCase(str);
  return camelCase2.charAt(0).toUpperCase() + camelCase2.slice(1);
}
function toKebabCase(str) {
  return str.replace(/([A-Z])/g, '-$1').toLowerCase();
}
function toSnakeCase(str) {
  return str.replace(/-([a-z])/g, (_, char) => `_${char}`).toLowerCase();
}

// ../../packages/adapters/src/utils/project-utilities.ts
import path4 from 'path';
function getProjectDirectory(config2) {
  if (config2.targetDirectory) {
    const targetBasename = path4.basename(config2.targetDirectory);
    if (targetBasename === config2.name) {
      return path4.resolve(config2.targetDirectory);
    }
    return path4.resolve(config2.targetDirectory, config2.name);
  }
  return path4.resolve(process.cwd(), config2.name);
}
function createTemplateContext(config2) {
  return {
    name: config2.name,
    description: config2.description || '',
    author: config2.author || '',
    license: config2.license || 'MIT',
    qualityLevel: config2.qualityLevel,
    projectType: config2.projectType,
    aiAssistants: config2.aiAssistants,
    year: new Date().getFullYear().toString(),
    now: new Date().toISOString(),
    camelCaseName: toCamelCase(config2.name),
    pascalCaseName: toPascalCase2(config2.name),
    kebabCaseName: toKebabCase(config2.name),
    snakeCaseName: toSnakeCase(config2.name),
  };
}
var init_project_utilities = () => {};

// ../../packages/adapters/src/generators/claude-md-constants.ts
var CLAUDE_MD_CONSTANTS,
  ESLINT_CRITICAL_RULES = `**CRITICAL RULE**: NEVER disable ESLint rules via inline comments (eslint-disable, eslint-disable-next-line, etc.).

1. \u274C **NEVER USE** \`// eslint-disable-next-line\`
2. \u274C **NEVER USE** \`/* eslint-disable */\`
3. \u2705 **ALWAYS FIX** the underlying code issue

**Rationale**: Disabling rules masks code quality issues and creates technical debt. Code must comply with all ESLint rules without exceptions.`,
  MUTATION_THRESHOLDS = `### Mutation Testing Thresholds

**CRITICAL RULE**: NEVER reduce mutation testing thresholds to make tests pass. If mutation score is below threshold:

1. \u2705 **ADD MORE TESTS** to kill surviving mutants
2. \u2705 **IMPROVE TEST QUALITY** to cover edge cases
3. \u274C **NEVER LOWER THRESHOLDS** as a shortcut

**Rationale**: Lowering thresholds masks quality issues and creates technical debt. Always improve test coverage instead.`,
  CODE_STYLE_REQUIREMENTS = `### Code Style Requirements

**CRITICAL RULE**: All code, code comments, and technical documentation MUST be written in **English**.

- **Code**: English only
- **Code comments**: English only
- **Technical documentation**: English only
- **Commit messages**: English only
- **Pull request descriptions**: English only

- **Indentation**: 2 spaces (no tabs)
- **Quotes**: Single quotes preferred`,
  GOOD_PATTERNS = `### Good Patterns
\`\`\`typescript
// Use explicit return types
function processData(input: string): Promise<ProcessedData> {
  // Implementation
}

// Use proper error handling
try {
  const result = await operation();
  return result;
} catch (error) {
  console.error('Operation failed:', error);
  throw error;
}`,
  BAD_PATTERNS = `### Avoid These Patterns
\`\`\`typescript
// Avoid any types
const data: any = fetchData();

// Avoid console.log in production code
console.log(data); // \u274C

// Avoid missing return types
function process(input) { // \u274C
  return input.trim();
}
\`\`\``,
  CLI_PATTERN = `// Use command pattern for CLI operations
class CreateCommand {
  async execute(options: CommandOptions): Promise<void> {
    // Implementation
  }
}`;
var init_claude_md_constants = __esm(() => {
  CLAUDE_MD_CONSTANTS = {
    COVERAGE_THRESHOLD: {
      LIGHT: 70,
      MEDIUM: 85,
      STRICT: 95,
      DEFAULT: 80,
    },
    CODE_STYLE: {
      DEFAULT_INDENT_SIZE: 2,
      DEFAULT_PRINT_WIDTH: 100,
      LIGHT_PRINT_WIDTH: 120,
      MEDIUM_PRINT_WIDTH: 100,
      STRICT_PRINT_WIDTH: 80,
    },
  };
});

// ../../packages/adapters/src/generators/claude-md-ai-helpers.ts
function buildAIContextHeader(config2, options) {
  const today = new Date().toISOString().split('T')[0];
  return `# AI Context for ${config2.name}

**Generated**: ${today}
**Quality Level**: ${options.qualityLevel}
**Project Type**: ${config2.projectType}`;
}
function buildAIContextOverview(config2) {
  const projectTypeNames = {
    basic: 'Basic TypeScript Project',
    web: 'Web Application Project',
    cli: 'CLI Application Project',
    library: 'Library Package Project',
  };
  return `## Project Information

**Name**: ${config2.name}
**Type**: ${projectTypeNames[config2.projectType] || config2.projectType}
**Description**: ${config2.description || 'A TypeScript project configured for Claude Code integration'}`;
}
function buildAIContextDependencies(config2) {
  const baseDependencies = [
    '- TypeScript for type safety',
    '- ESLint for code quality',
    '- Prettier for code formatting',
    '- Vitest for testing',
  ];
  const projectSpecificDependencies = {
    web: ['- Express.js for web server'],
    cli: ['- Commander.js for CLI argument parsing'],
    library: ['- Rollup for bundling'],
    basic: [],
  };
  const additionalDeps = projectSpecificDependencies[config2.projectType] || [];
  return `### Key Dependencies

${[...baseDependencies, ...additionalDeps].join(`
`)}`;
}
function buildAIContextCodePatterns(config2) {
  const cliPattern =
    config2.projectType === 'cli'
      ? `

${CLI_PATTERN}`
      : '';
  const cliBulletPattern =
    config2.projectType === 'cli'
      ? `

- Use command pattern for CLI operations`
      : '';
  return `## Code Patterns

${GOOD_PATTERNS}

${cliBulletPattern ? cliBulletPattern.trim() : ''}
\`\`\`
${cliPattern ? cliPattern : ''}

${BAD_PATTERNS}`;
}
function buildAIContextTestingStrategy(options, getCoverageThreshold) {
  return `## Testing Strategy

- Achieve ${getCoverageThreshold(options.qualityLevel)}% test coverage
- Use Vitest as the primary testing framework
- Test both happy path and error cases
- Mock external dependencies`;
}
function buildAIContextGuidelines(projectType) {
  const cliGuidelines =
    projectType === 'cli'
      ? `
- Implement proper error handling with user-friendly messages`
      : '';
  return `## Development Guidelines

- Follow the existing code style
- Write tests for new features
- Update documentation when needed
- Use TypeScript strictly
- Handle errors properly${cliGuidelines}`;
}
function buildAIContextProjectStructure() {
  return `## Project Structure

\`\`\`
src/
\u251C\u2500\u2500 components/     # UI components (if web project)
\u251C\u2500\u2500 utils/         # Utility functions
\u251C\u2500\u2500 types/         # TypeScript type definitions
\u2514\u2500\u2500 tests/         # Test files
\`\`\``;
}
var init_claude_md_ai_helpers = __esm(() => {
  init_claude_md_constants();
});

// ../../packages/adapters/src/generators/claude-md-content-builders.ts
function getCoverageThreshold(qualityLevel) {
  switch (qualityLevel) {
    case 'light':
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.LIGHT;
    case 'medium':
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.MEDIUM;
    case 'strict':
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.STRICT;
    default:
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.DEFAULT;
  }
}
function getPrintWidth(qualityLevel) {
  switch (qualityLevel) {
    case 'light':
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.LIGHT_PRINT_WIDTH;
    case 'medium':
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.MEDIUM_PRINT_WIDTH;
    case 'strict':
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.STRICT_PRINT_WIDTH;
    default:
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.DEFAULT_PRINT_WIDTH;
  }
}
function buildCodeStyleSection(options) {
  const { qualityLevel, codeStyle } = options;
  return `## Code Style Configuration

- **Indent Size**: ${codeStyle.indentSize} spaces
- **Use Tabs**: ${codeStyle.useTabs ? 'Yes' : 'No'}
- **Semicolons**: ${codeStyle.semi ? 'Required' : 'Optional'}
- **Quotes**: ${codeStyle.singleQuote ? 'Single' : 'Double'}
- **Trailing Commas**: ${codeStyle.trailingComma}
- **Print Width**: ${codeStyle.printWidth || getPrintWidth(qualityLevel)} characters
- **Line Endings**: LF

## Quality Standards

- **Quality Level**: ${qualityLevel}
- **Coverage Threshold**: ${getCoverageThreshold(qualityLevel)}%
- **TypeScript**: ${options.enableTypeScript ? 'Enabled' : 'Disabled'}
- **Testing**: ${options.enableTesting ? 'Enabled' : 'Disabled'}`;
}
function buildArchitectureSection(projectType) {
  const architectureMap = {
    basic: 'Basic project structure with standard conventions',
    web: 'Web application with frontend components and build pipeline',
    cli: 'Command-line interface tool with argument parsing',
    library: 'Reusable library with public API documentation',
  };
  let specificComponents = '';
  if (projectType === 'cli') {
    specificComponents = `- **src/commands/**: CLI command implementations
- **src/utils/**: Utility functions and helpers`;
  } else if (projectType === 'web') {
    specificComponents = `- **src/components/**: Reusable UI components
- **src/pages/**: Page-level components`;
  } else if (projectType === 'library') {
    specificComponents = `- **src/**: Library source code
- **types/**: TypeScript type definitions`;
  }
  return `## Architecture

This is a ${projectType} project with the following characteristics:

${architectureMap[projectType]}

### Key Components

- Source code in \`src/\` directory
- Configuration files in root directory
- Test files alongside source code
- Documentation in \`docs/\` directory${buildSpecificComponents(specificComponents)}`;
}
function buildSpecificComponents(specificComponents) {
  return specificComponents
    ? `

${specificComponents}`
    : '';
}
function buildCliDevelopmentSection(projectType) {
  if (projectType !== 'cli') {
    return '';
  }
  return `

### CLI Development
- Implement proper error handling with user-friendly messages
- Use commander.js for argument parsing
- Add help text and usage examples
- Test CLI commands with different argument combinations`;
}
function buildDevelopmentWorkflowSection(options, projectType) {
  return `## Development Workflow

### Setup
1. Install dependencies: \`bun install\`
2. Run development server: \`bun run dev\`
3. Run tests: \`bun test\`

### Code Quality
- Use ESLint for code linting
- Use Prettier for code formatting
- Maintain ${getCoverageThreshold(options.qualityLevel)}% test coverage
- Follow TypeScript best practices${options.enableTypeScript ? ' (enabled)' : ''}

### Git Workflow
- Use conventional commit messages
- Create feature branches from main
- Submit pull requests for review
- Ensure CI/CD pipeline passes${buildCliDevelopmentSection(projectType)}`;
}
var init_claude_md_content_builders = __esm(() => {
  init_claude_md_constants();
});

// ../../packages/adapters/src/generators/claude-md-helpers.ts
function getTargetEnvironment(projectType) {
  switch (projectType) {
    case 'web':
      return 'browser';
    case 'cli':
      return 'node';
    case 'library':
      return 'both';
    default:
      return 'node';
  }
}
function getEnvironmentName(targetEnvironment) {
  const names = {
    node: 'Node.js',
    browser: 'Browser',
    both: 'Universal (Node.js + Browser)',
  };
  return names[targetEnvironment] || 'Unknown';
}

// ../../packages/adapters/src/generators/claude-md-core-helpers.ts
function buildHeader(config2) {
  const projectTypeNames = {
    basic: 'Basic Application',
    web: 'Web Application',
    cli: 'CLI Application',
    library: 'Library Package',
  };
  const descriptionSection = config2.description
    ? `> ${config2.description}`
    : 'A project configured for Claude Code assistant integration';
  return `# ${config2.name}

${descriptionSection}

## Project Information

- **Name**: ${config2.name}
- **Project Type**: ${projectTypeNames[config2.projectType] || config2.projectType}
- **Environment**: ${getEnvironmentName(getTargetEnvironment(config2.projectType || 'basic'))}
- **Quality Level**: ${config2.qualityLevel}
- **AI Assistants**: ${config2.aiAssistants.join(', ')}`;
}
function buildTestingSection(options, getCoverageThreshold2) {
  const coverageThreshold = getCoverageThreshold2(options.qualityLevel);
  return `## Testing

${
  options.enableTesting
    ? `
- Run tests with \`npm test\`
- Target coverage: ${coverageThreshold}%
- Use Vitest for unit testing
- Use ESLint for code quality
- Use Prettier for code formatting
`
    : '- Testing disabled'
}

## Code Quality Standards

- **Coverage Threshold**: ${coverageThreshold}%
- **Quality Level**: ${options.qualityLevel}
- **TypeScript**: ${options.enableTypeScript ? 'Enabled' : 'Disabled'}`;
}
function getCoverageThreshold2(qualityLevel) {
  switch (qualityLevel) {
    case 'light':
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.LIGHT;
    case 'medium':
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.MEDIUM;
    case 'strict':
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.STRICT;
    default:
      return CLAUDE_MD_CONSTANTS.COVERAGE_THRESHOLD.DEFAULT;
  }
}
function buildKeyDependenciesSection(config2) {
  const basicDependencies = ['typescript', 'eslint', 'prettier', 'vitest'];
  return `## Key Dependencies

${basicDependencies.map((dep) => `- ${dep}`).join(`
`)}

## Claude Code Integration

This project is optimized for Claude Code with:

- Proper project structure
- Comprehensive documentation
- Type safety${config2.aiAssistants.includes('claude-code') ? ' (Claude Code enabled)' : ''}
- Development guidelines${config2.aiAssistants.includes('copilot') ? ' (GitHub Copilot compatible)' : ''}`;
}
function buildGenerationTimestamp(date) {
  return `**Generated**: ${date}`;
}
function buildFooter() {
  return `---

*This CLAUDE.md file was automatically generated by N\xECmata CLI.*
*Modify with care, as changes may be overwritten during regeneration.*`;
}
function buildLanguageRequirementsSection() {
  return `## Language Requirements

All code, code comments, and technical documentation MUST be written in **English**.

- **Code**: English only
- **Code comments**: English only
- **Technical documentation** (README files, API docs, inline docs, etc.): English only
- **Commit messages**: English only
- **Pull request descriptions**: English only`;
}
function buildCodeStyleConfiguration(qualityLevel) {
  return {
    indentSize: CLAUDE_MD_CONSTANTS.CODE_STYLE.DEFAULT_INDENT_SIZE,
    useTabs: false,
    semi: true,
    singleQuote: true,
    trailingComma: (() => {
      if (qualityLevel === 'light') return 'none';
      if (qualityLevel === 'strict') return 'all';
      return 'es5';
    })(),
    printWidth: getPrintWidth2(qualityLevel),
  };
}
function getPrintWidth2(qualityLevel) {
  switch (qualityLevel) {
    case 'light':
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.LIGHT_PRINT_WIDTH;
    case 'medium':
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.MEDIUM_PRINT_WIDTH;
    case 'strict':
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.STRICT_PRINT_WIDTH;
    default:
      return CLAUDE_MD_CONSTANTS.CODE_STYLE.DEFAULT_PRINT_WIDTH;
  }
}
function buildEslintRulesSection(options) {
  const codeStyleConfig = buildCodeStyleConfiguration(options.qualityLevel);
  const trailingCommaText = (() => {
    if (codeStyleConfig.trailingComma === 'none') return 'none';
    if (codeStyleConfig.trailingComma === 'all') return 'all';
    return 'es5';
  })();
  const lineWidthText = `Maximum ${codeStyleConfig.printWidth} characters`;
  return `### ESLint Rules

${ESLINT_CRITICAL_RULES}

${MUTATION_THRESHOLDS}

${CODE_STYLE_REQUIREMENTS}

- **Semicolons**: Required
- **Trailing commas**: ${trailingCommaText}
- **Line length**: ${lineWidthText}

### Testing Requirements

- Maintain ${options.enableTypeScript ? '90%' : '85%'} test coverage
- Write tests for all public methods and functions
- Test both success and error scenarios
- Use descriptive test names
- Mock external dependencies in tests
- **Test files**: Use \`.test.ts\` or \`.spec.ts\` suffix
- **Framework**: Vitest with TypeScript support
- **Coverage**: Minimum ${(() => {
    if (options.qualityLevel === 'light') return '70';
    if (options.qualityLevel === 'strict') return '95';
    if (options.qualityLevel === 'medium') return options.enableTypeScript ? '90' : '85';
    return '85';
  })()}% required for all tests`;
}
var init_claude_md_core_helpers = __esm(() => {
  init_claude_md_constants();
});

// ../../packages/adapters/src/generators/claude-md-generator.ts
class ClaudeMdGenerator {
  generate(config2) {
    const options = {
      qualityLevel: config2.qualityLevel,
      projectType: config2.projectType,
      enableTypeScript: true,
      enableTesting: true,
      codeStyle: this.getDefaultCodeStyle(config2.qualityLevel),
    };
    const content = this.buildClaudeMdContent(config2, options);
    const results = [
      {
        filename: 'CLAUDE.md',
        content,
        description: 'Claude Code assistant configuration with project guidelines',
      },
    ];
    if (config2.aiAssistants.includes('claude-code')) {
      const aiContextContent = this.buildAIContextContent(config2, options);
      results.push({
        filename: '.claude/ai-context.md',
        content: aiContextContent,
        description: 'Claude Code AI context with project-specific instructions',
      });
    }
    return results;
  }
  getDefaultCodeStyle(qualityLevel) {
    return {
      indentSize: CLAUDE_MD_CONSTANTS.CODE_STYLE.DEFAULT_INDENT_SIZE,
      useTabs: false,
      semi: true,
      singleQuote: true,
      trailingComma: qualityLevel === 'light' ? 'none' : 'es5',
      printWidth: this.getPrintWidth(qualityLevel),
    };
  }
  getPrintWidth(qualityLevel) {
    switch (qualityLevel) {
      case 'light':
        return CLAUDE_MD_CONSTANTS.CODE_STYLE.LIGHT_PRINT_WIDTH;
      case 'medium':
        return CLAUDE_MD_CONSTANTS.CODE_STYLE.MEDIUM_PRINT_WIDTH;
      case 'strict':
        return CLAUDE_MD_CONSTANTS.CODE_STYLE.STRICT_PRINT_WIDTH;
      default:
        return CLAUDE_MD_CONSTANTS.CODE_STYLE.DEFAULT_PRINT_WIDTH;
    }
  }
  buildClaudeMdContent(config2, options) {
    const today = new Date().toISOString().split('T')[0] || '2025-01-01';
    const sections = [
      buildHeader(config2),
      buildGenerationTimestamp(today),
      buildLanguageRequirementsSection(),
      buildArchitectureSection(config2.projectType || 'library'),
      buildEslintRulesSection(options),
      buildCodeStyleSection(options),
      buildTestingSection(options, getCoverageThreshold2),
      buildDevelopmentWorkflowSection(options, config2.projectType),
      buildKeyDependenciesSection(config2),
      buildFooter(),
    ];
    return sections.join(`

`);
  }
  buildAIContextContent(config2, options) {
    const sections = [
      buildAIContextHeader(config2, options),
      buildAIContextOverview(config2),
      buildAIContextDependencies(config2),
      buildAIContextCodePatterns(config2),
      buildAIContextTestingStrategy(options, getCoverageThreshold2),
      buildAIContextGuidelines(config2.projectType),
      buildAIContextProjectStructure(),
    ];
    return sections.join(`

`);
  }
}
var init_claude_md_generator = __esm(() => {
  init_claude_md_ai_helpers();
  init_claude_md_constants();
  init_claude_md_content_builders();
  init_claude_md_core_helpers();
});

// ../../packages/adapters/src/generators/copilot-constants.ts
var COPILOT_CONSTANTS;
var init_copilot_constants = __esm(() => {
  COPILOT_CONSTANTS = {
    COVERAGE_THRESHOLD: {
      LIGHT: 70,
      MEDIUM: 85,
      STRICT: 95,
    },
    CODE_STYLE: {
      DEFAULT_PRINT_WIDTH: 100,
      DEFAULT_INDENT_SIZE: 2,
    },
  };
});

// ../../packages/adapters/src/generators/copilot-content-builders.ts
function getQualityConfig(qualityLevel) {
  switch (qualityLevel) {
    case 'light':
      return {
        trailingCommas: 'none',
        lineLength: MAX_LINE_LENGTH_LIGHT,
        qualityFocus: '- Focus on readability and basic functionality',
      };
    case 'strict':
      return {
        trailingCommas: 'all',
        lineLength: MAX_LINE_LENGTH_STRICT,
        qualityFocus: '- Maximum code quality and maintainability standards',
      };
    default:
      return {
        trailingCommas: 'es5',
        lineLength: 100,
        qualityFocus: '- Maintain high code readability and maintainability',
      };
  }
}
function buildFrameworksList(frameworks) {
  return frameworks.map((f) => `- ${f}`).join(`
`);
}
function getSecurityGuidelines(projectType) {
  const baseSecurity = [
    '- Validate all user inputs',
    '- Handle sensitive data properly',
    '- Use secure authentication practices',
    '- Follow OWASP security guidelines',
    '- Sanitize data to prevent XSS attacks',
  ];
  const webSpecific = [
    '- Implement CSRF protection',
    '- Use HTTPS in production',
    '- Set proper security headers',
  ];
  return projectType === 'web'
    ? [...baseSecurity, ...webSpecific].join(`
`)
    : baseSecurity.join(`
`);
}
function getCopilotCoverageThreshold(qualityLevel) {
  switch (qualityLevel) {
    case 'light':
      return COPILOT_CONSTANTS.COVERAGE_THRESHOLD.LIGHT;
    case 'medium':
      return COPILOT_CONSTANTS.COVERAGE_THRESHOLD.MEDIUM;
    case 'strict':
      return COPILOT_CONSTANTS.COVERAGE_THRESHOLD.STRICT;
    default:
      return COPILOT_CONSTANTS.COVERAGE_THRESHOLD.MEDIUM;
  }
}
function buildProjectContextSection(options) {
  return `## Project Context

You are working on **${options.projectName}**, a ${options.projectType} project.

${options.projectDescription ? `> ${options.projectDescription}` : ''}

### Environment
- Target: ${options.targetEnvironment}
- Testing: ${options.testing ? 'Enabled' : 'Disabled'}
- Quality Level: ${options.qualityLevel}

### Frameworks and Libraries
${options.frameworks.length > 0 ? buildFrameworksList(options.frameworks) : '- No specific frameworks configured'}`;
}
function buildCodingStandardsSection(options) {
  const coverageThreshold = getCopilotCoverageThreshold(options.qualityLevel);
  const qualityConfig = getQualityConfig(options.qualityLevel);
  return `## Coding Standards

### Code Style
- Use ${options.codeStyle['singleQuote'] ? 'single' : 'double'} quotes for strings
- Use ${options.codeStyle['semi'] ? 'semicolons' : 'no semicolons'}
- Use ${options.codeStyle['useTabs'] ? 'tabs' : `${options.codeStyle['indentSize'] || COPILOT_CONSTANTS.CODE_STYLE.DEFAULT_INDENT_SIZE} spaces`} for indentation
- Maximum line length: ${qualityConfig.lineLength} characters
- Use trailing commas: ${qualityConfig.trailingCommas}

### Quality Requirements
- Maintain ${coverageThreshold}% test coverage
- Write meaningful tests for all new functionality
- Follow TypeScript best practices${options.targetEnvironment === 'node' || options.targetEnvironment === 'both' ? ' (Node.js compatible)' : ''}
- Use modern JavaScript/TypeScript features appropriately
${qualityConfig.qualityFocus}

### Documentation
- Write clear JSDoc comments for functions and classes
- Include parameter descriptions and return types
- Document complex business logic
- Keep comments up-to-date with code changes`;
}
function buildSecurityPerformanceSection(options) {
  const securityGuidelines = getSecurityGuidelines(options.projectType);
  return `## Security and Performance

### Security Guidelines
${securityGuidelines}

### Performance Considerations
- Optimize algorithms for time and space complexity
- Use appropriate data structures
- Minimize bundle size for web applications
- Implement efficient caching strategies
- Monitor and optimize bottlenecks

### Code Quality
- Write readable and maintainable code
- Follow established patterns and conventions
- Refactor complex code into smaller functions
- Use meaningful variable and function names
- Keep functions focused on single responsibilities`;
}
var MAX_LINE_LENGTH_LIGHT = 120,
  MAX_LINE_LENGTH_STRICT = 80;
var init_copilot_content_builders = __esm(() => {
  init_copilot_constants();
});

// ../../packages/adapters/src/generators/copilot-patterns-content.ts
function getCLIPatternsContent() {
  return `### Command pattern example
\`\`\`typescript
export class MyCommand {
  constructor(private readonly dependencies: CommandDependencies) {}

  async execute(options: CommandOptions): Promise<void> {
    try {
      console.log('Command executed successfully');
    } catch (error) {
      console.error('Command failed:', error.message);
      process.exit(1);
    }
  }
}
\`\`\``;
}
function getExpressRouteExample() {
  return `### Express route example
\`\`\`typescript
import { Request, Response } from 'express';

export const getUserHandler = async (req: Request, res: Response): Promise<void> => {
  try {
    const user = await userService.findById(req.params.id);
    res.json(user);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
};
\`\`\``;
}
function getRestfulApiPattern() {
  return `### RESTful API Pattern
\`\`\`typescript
import { Request, Response } from 'express';

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export const createSuccessResponse = <T>(data: T): ApiResponse<T> => ({
  success: true,
  data,
});

export const createErrorResponse = (error: string): ApiResponse<never> => ({
  success: false,
  error,
});
\`\`\``;
}
function getWebPatternsContent() {
  return `${getExpressRouteExample()}

${getRestfulApiPattern()}`;
}
function getProjectSpecificPatternsContent(projectType) {
  switch (projectType) {
    case 'cli':
      return getCLIPatternsContent();
    case 'web':
      return getWebPatternsContent();
    default:
      return '';
  }
}
function getBestPracticesList() {
  return `
## Best Practices

- **Always** use proper TypeScript typing
- **Follow** established naming conventions
- **Write** comprehensive tests for all new code
- **Handle** errors gracefully and consistently
- **Include** proper JSDoc documentation
- **Use** async/await instead of Promise chains
- **Prefer** functional programming patterns where appropriate
- **Ensure** all generated code follows these guidelines`;
}
function getTestingPattern() {
  return `### Testing Pattern
\`\`\`typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';

describe('Example functionality', () => {
  beforeEach(() => {
    // Setup before each test
  });

  it('should handle valid input correctly', async () => {
    // Arrange
    const input = 'test input';

    // Act
    const result = await exampleFunction(input);

    // Assert
    expect(result).toBe('Processed: test input');
  });

  it('should throw error for invalid input', async () => {
    // Arrange
    const input = '';

    // Act & Assert
    await expect(exampleFunction(input)).rejects.toThrow('Parameter is required');
  });
});
\`\`\``;
}
function getBestPracticesContent() {
  return `${getBestPracticesList()}

${getTestingPattern()}`;
}

// ../../packages/adapters/src/generators/copilot-patterns.ts
function getFunctionPattern() {
  return `### TypeScript Function Pattern
\`\`\`typescript
// Example function with proper typing and documentation
/**
 * Process input data and return result
 * @param {string} input - The input data to process
 * @returns {void} Promise that resolves to processed data
 */
async function processData(input: string): Promise<ProcessedData> {
  try {
    const result = await someOperation(input);
    return result;
  } catch (error) {
    console.error('Processing failed:', error);
    throw error;
  }
}
\`\`\``;
}
function getClassPattern() {
  return `### Class Pattern
\`\`\`typescript
/**
 * Example service class with dependency injection
 */
export class DataService {
  constructor(private repository: DataRepository) {}

  async findById(id: string): Promise<Data | null> {
    return this.repository.findById(id);
  }

  async create(data: CreateDataDto): Promise<Data> {
    const entity = new Data();
    Object.assign(entity, data);
    return this.repository.save(entity);
  }
}
\`\`\``;
}
function getErrorHandlingPattern() {
  return `### Error Handling Pattern
\`\`\`typescript
/**
 * Standardized error handling wrapper
 */
export async function withErrorHandling<T>(
  operation: () => Promise<T>,
  context: string
): Promise<Result<T>> {
  try {
    const result = await operation();
    return { success: true, data: result };
  } catch (error) {
    console.error(\`Error in \${context}:\`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}
\`\`\``;
}
function getTestingPattern2() {
  return `### Testing Pattern
\`\`\`typescript
/**
 * Example test with proper structure and assertions
 */
describe('DataService', () => {
  let service: DataService;
  let mockRepository: jest.Mocked<DataRepository>;

  beforeEach(() => {
    mockRepository = createMockRepository();
    service = new DataService(mockRepository);
  });

  it('should create data successfully', async () => {
    // Arrange
    const inputData = { name: 'Test', value: 123 };
    const expectedData = { id: '1', ...inputData };
    mockRepository.save.mockResolvedValue(expectedData);

    // Act
    const result = await service.create(inputData);

    // Assert
    expect(result).toEqual(expectedData);
    expect(mockRepository.save).toHaveBeenCalledWith(
      expect.objectContaining(inputData)
    );
  });
});
\`\`\``;
}
function getProjectGuidelines() {
  return `## Project-Specific Guidelines

- Always use proper TypeScript types
- Follow the established folder structure
- Write meaningful commit messages
- Add JSDoc comments for public APIs
- Handle errors gracefully and consistently
- Write tests for all public methods
- Use async/await instead of promises with .then()
- Prefer functional programming patterns where appropriate`;
}
function getCodePatternsContent() {
  const patterns = [
    '## Common Patterns',
    getFunctionPattern(),
    getClassPattern(),
    getErrorHandlingPattern(),
    getTestingPattern2(),
    getProjectGuidelines(),
    '## API Patterns',
    getAPIPatterns('web'),
    '## Configuration Patterns',
    getConfigurationPatterns(),
    '## Error Handling Patterns',
    getErrorHandlingPatterns(),
  ];
  return patterns.join(`

`);
}
function getErrorHandlingPatterns() {
  return `// Error handling pattern
export class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly statusCode: number = 500
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export const safeExecute = async <T>(
  operation: () => Promise<T>,
  errorMessage: string
): Promise<T> => {
  try {
    return await operation();
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    throw new AppError(errorMessage, 'OPERATION_FAILED');
  }
};`;
}
function getAPIPatterns(projectType) {
  if (projectType === 'web') {
    return `// RESTful API pattern
export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}

export const createSuccessResponse = <T>(data: T): ApiResponse<T> => ({
  data,
  success: true,
});

export const createErrorResponse = (message: string): ApiResponse<null> => ({
  data: null,
  success: false,
  message,
});`;
  }
  return '';
}
function getConfigurationPatterns() {
  return `// Configuration pattern
export interface AppConfig {
  port: number;
  database: DatabaseConfig;
  logging: LoggingConfig;
}

export const loadConfig = (): AppConfig => {
  return {
    port: parseInt(process.env.PORT || '3000', 10),
    database: {
      host: process.env.DB_HOST || 'localhost',
      port: parseInt(process.env.DB_PORT || '5432', 10),
    },
    logging: {
      level: process.env.LOG_LEVEL || 'info',
    },
  };
};`;
}

// ../../packages/adapters/src/generators/copilot-generator.ts
class CopilotGenerator {
  generate(config2) {
    const targetEnvironment = this.getTargetEnvironment(config2.projectType);
    const options = {
      qualityLevel: config2.qualityLevel,
      projectType: config2.projectType,
      targetEnvironment,
      projectName: config2.name,
      projectDescription: config2.description,
      codeStyle: this.getDefaultCodeStyle(),
      testing: true,
      frameworks: this.getFrameworks(config2.projectType),
    };
    const instructionsContent = this.buildCopilotInstructions(options);
    const patternsContent = this.buildCopilotPatterns(options);
    return [
      {
        filename: '.github/copilot-instructions.md',
        content: instructionsContent,
        description: 'GitHub Copilot assistant instructions with project guidelines',
      },
      {
        filename: '.github/copilot-patterns.md',
        content: patternsContent,
        description: 'GitHub Copilot code patterns and examples',
      },
    ];
  }
  getTargetEnvironment(projectType) {
    switch (projectType) {
      case 'web':
        return 'browser';
      case 'cli':
        return 'node';
      case 'library':
        return 'both';
      default:
        return 'node';
    }
  }
  getFormattedEnvironment(targetEnvironment) {
    switch (targetEnvironment) {
      case 'browser':
        return 'Browser';
      case 'node':
        return 'Node.js';
      case 'both':
        return 'Universal (Node.js + Browser)';
      default:
        return 'Node.js';
    }
  }
  getDefaultCodeStyle() {
    return {
      singleQuote: true,
      semi: true,
      useTabs: false,
      indentSize: COPILOT_CONSTANTS.CODE_STYLE.DEFAULT_INDENT_SIZE,
      printWidth: COPILOT_CONSTANTS.CODE_STYLE.DEFAULT_PRINT_WIDTH,
      trailingComma: 'es5',
    };
  }
  getFrameworks(projectType) {
    switch (projectType) {
      case 'web':
        return ['React', 'TypeScript', 'Vite', 'ESLint', 'Prettier'];
      case 'cli':
        return ['Node.js', 'TypeScript', 'Commander.js', 'Inquirer.js'];
      case 'library':
        return ['TypeScript', 'Rollup', 'Jest', 'ESLint'];
      default:
        return ['TypeScript', 'ESLint', 'Prettier'];
    }
  }
  buildCopilotInstructions(options) {
    const sections = [
      this.buildHeader(options),
      buildProjectContextSection(options),
      this.buildLanguageStandardsSection(),
      this.buildFormattingRulesSection(options),
      buildCodingStandardsSection(options),
      this.buildTestingRequirementsSection(options),
      this.buildCodePatternsSection(),
      this.buildWhatToAvoidSection(options),
      this.buildProjectSpecificGuidelines(options),
      buildSecurityPerformanceSection(options),
      this.buildCopilotSpecificInstructions(options),
    ];
    return sections.join(`

`);
  }
  buildHeader(options) {
    const today = new Date().toISOString().split('T')[0];
    const projectTypeNames = {
      basic: 'Basic Application',
      web: 'Web Application',
      cli: 'CLI Application',
      library: 'Library Package',
    };
    return `# ${options.projectName} - GitHub Copilot Instructions

*Instructions generated by N\xECmata CLI - Last updated: ${today}*

**Last Updated**: ${today}

## Overview

This file contains specific instructions for GitHub Copilot to help generate high-quality code for **${options.projectName}**.

### Project Information
- **Name**: ${options.projectName}
- **Project Type**: ${projectTypeNames[options.projectType] || options.projectType}
- **Environment**: ${this.getFormattedEnvironment(options.targetEnvironment)}
- **Quality Level**: ${options.qualityLevel}`;
  }
  buildLanguageStandardsSection() {
    return `### Language Standards

**MUST** write all code, comments, and documentation in **English** only

**MUST** use TypeScript with strict type checking enabled

- Files: \`kebab-case\`
- Classes/Types: \`PascalCase\`
- Functions/Variables: \`camelCase\`
- Constants: \`UPPER_SNAKE_CASE\``;
  }
  buildFormattingRulesSection(options) {
    const indentSize =
      options.codeStyle['indentSize'] || COPILOT_CONSTANTS.CODE_STYLE.DEFAULT_INDENT_SIZE;
    let trailingCommaText;
    if (options.qualityLevel === 'light') {
      trailingCommaText = 'none';
    } else if (options.qualityLevel === 'strict') {
      trailingCommaText = 'all';
    } else {
      trailingCommaText = 'es5';
    }
    let lineLength;
    if (options.qualityLevel === 'light') {
      lineLength = LINE_LENGTH_LIGHT;
    } else if (options.qualityLevel === 'strict') {
      lineLength = LINE_LENGTH_STRICT;
    } else {
      lineLength = LINE_LENGTH_MEDIUM;
    }
    return `### Formatting Rules

- **Indentation**: ${indentSize} spaces (never tabs)
- **Semicolons**: Always use semicolons
- **Quotes**: Single quotes for strings
- **Trailing commas**: ${trailingCommaText}
- **Line length**: Maximum ${lineLength} characters`;
  }
  buildTestingRequirementsSection(options) {
    const coverageThreshold = getCopilotCoverageThreshold(options.qualityLevel);
    let framework = 'Vitest';
    if (options.projectType === 'web' || options.projectType === 'basic') {
      framework = 'Vitest with TypeScript support';
    }
    return `## Testing Requirements

- **Framework**: Use ${framework}
- **Coverage**: Minimum ${coverageThreshold}% code coverage required
- **Test Structure**: Use describe/it/test pattern`;
  }
  buildWhatToAvoidSection(options) {
    const strictRules =
      options.qualityLevel === 'strict'
        ? `
- **NEVER** use console.log in production code`
        : '';
    return `## What to Avoid

- **NEVER** disable ESLint rules with inline comments
- **NEVER** use \`any\` type in TypeScript
- **ALWAYS** handle errors properly${strictRules}`;
  }
  buildCodePatternsSection() {
    return `## Code Patterns

### Project Structure
- Follow standard TypeScript project structure
- Separate concerns with clear module boundaries

### Testing Patterns
- Write unit tests for all business logic
- Use integration tests for component interactions

### Error Handling
- Use try-catch blocks for async operations
- Return Result types for business operations

### API Patterns
- Use RESTful principles for API design
- Implement proper HTTP status codes

### Configuration
- Use environment variables for configuration
- Validate configuration at startup`;
  }
  buildProjectSpecificGuidelines(options) {
    if (options.projectType === 'cli') {
      return `## CLI Development Guidelines

- Use command pattern for CLI operations
- **Commander.js**: Use command pattern, implement help text`;
    } else if (options.projectType === 'web') {
      return `## Web Development Guidelines

- Use MVC or similar architectural pattern
- **Express.js**: Use middleware for cross-cutting concerns`;
    } else if (options.projectType === 'library') {
      return `## Library Development Guidelines

- Design with clear public APIs and minimal surface area
- Use semantic versioning for releases`;
    }
    return '';
  }
  buildCopilotSpecificInstructions(_options) {
    return `${this.buildCodeGenerationInstructions()}
${this.buildRefactoringInstructions()}
${this.buildTestingInstructions()}
${this.getCodeQualityStandards()}
${this.getFinalInstructions()}`;
  }
  buildCodeGenerationInstructions() {
    return `### When Generating Code

1. **Always** follow the coding standards and patterns defined above
2. **Prefer** modern JavaScript/TypeScript features when appropriate
3. **Include** proper error handling and validation
4. **Write** meaningful comments for complex logic
5. **Consider** performance implications of generated code
6. **Ensure** compatibility with the target environment`;
  }
  buildRefactoringInstructions() {
    return `### When Refactoring Code

1. **Maintain** existing functionality while improving structure
2. **Follow** established patterns and conventions
3. **Update** comments and documentation as needed
4. **Preserve** error handling behavior
5. **Consider** impact on dependent code`;
  }
  buildTestingInstructions() {
    return `### When Writing Tests

1. **Test** behavior, not implementation details
2. **Cover** edge cases and error conditions
3. **Use** descriptive test names
4. **Follow** the testing patterns defined above
5. **Maintain** high test coverage`;
  }
  getCodeQualityStandards() {
    return `### Code Quality Standards

- Write clean, readable code
- Follow SOLID principles

- Use consistent formatting
- Follow project style guide

- Document complex logic
- Use meaningful variable names

- Avoid hardcoded values
- Prefer composition over inheritance`;
  }
  getFinalInstructions() {
    return `### Final Instructions

- **Always** prioritize code quality and maintainability
- **Consider** the specific needs of this project
- **Follow** security best practices
- **Write** code that is easy to understand and modify
- **Ensure** all generated code follows these guidelines`;
  }
  buildCopilotPatterns(options) {
    const today = new Date().toISOString().split('T')[0];
    const patterns = getCodePatternsContent();
    const projectPatterns = getProjectSpecificPatternsContent(options.projectType);
    const bestPractices = getBestPracticesContent();
    return `# Code Patterns and Examples

**Last Updated**: ${today}

${patterns}

${projectPatterns}

${bestPractices}`;
  }
}
var LINE_LENGTH_LIGHT = 120,
  LINE_LENGTH_MEDIUM = 100,
  LINE_LENGTH_STRICT = 80;
var init_copilot_generator = __esm(() => {
  init_copilot_constants();
  init_copilot_content_builders();
});

// ../../packages/adapters/src/generators/project-generator-workflow.ts
import fs9 from 'fs/promises';
async function prepareProjectSetup(config2, templateEngine, startTime) {
  const result = {
    success: false,
    files: [],
    errors: [],
    warnings: [],
    duration: 0,
  };
  try {
    const projectDir = getProjectDirectory(config2);
    const templateName = config2.template || config2.projectType;
    await checkDirectoryExists(projectDir);
    await templateEngine.loadTemplate(templateName);
    result.success = true;
    result.files = [{ path: '', content: '', permissions: '' }];
    result.duration = Date.now() - startTime;
  } catch (error) {
    return createErrorResult(
      result,
      error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE3,
      [],
      startTime
    );
  }
  return result;
}
async function loadAndProcessTemplate(config2, templateEngine) {
  const templateName = config2.template || config2.projectType;
  const template = await templateEngine.loadTemplate(templateName);
  const context = createTemplateContext(config2);
  return templateEngine.processProjectTemplate(template, context);
}
async function generateFilesFromTemplate(config2, templateEngine, files, startTime) {
  const result = {
    success: false,
    files: [],
    errors: [],
    warnings: [],
    duration: 0,
  };
  try {
    const generatedFiles = await loadAndProcessTemplate(config2, templateEngine);
    const aiContextFiles = generateAIContextFiles(config2);
    result.files = [...generatedFiles, ...aiContextFiles];
    result.success = true;
    result.duration = Date.now() - startTime;
  } catch (error) {
    return createErrorResult(
      result,
      `Failed to process template: ${error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE3}`,
      [],
      startTime
    );
  }
  return result;
}
function generateAIContextFiles(config2) {
  const aiFiles = [];
  const normalizedConfig = normalizeConfigForGenerators(config2);
  if (config2.aiAssistants.includes('claude-code')) {
    const claudeGenerator = new ClaudeMdGenerator();
    const claudeConfigs = claudeGenerator.generate(normalizedConfig);
    for (const claudeConfig of claudeConfigs) {
      aiFiles.push({
        path: claudeConfig.filename,
        content: claudeConfig.content,
      });
    }
  }
  if (config2.aiAssistants.includes('copilot')) {
    const copilotGenerator = new CopilotGenerator();
    const copilotConfigs = copilotGenerator.generate(normalizedConfig);
    for (const copilotConfig of copilotConfigs) {
      aiFiles.push({
        path: copilotConfig.filename,
        content: copilotConfig.content,
      });
    }
  }
  return aiFiles;
}
async function createProjectAndWriteFiles(config2, files) {
  const projectDir = getProjectDirectory(config2);
  await fs9.mkdir(projectDir, { recursive: true });
  const writeErrors = await writeFilesToDisk(files, projectDir);
  return { projectDir, writeErrors };
}
async function finalizeProject(config2, files, startTime, addValidationWarnings) {
  const result = {
    success: false,
    files,
    errors: [],
    warnings: [],
    duration: 0,
  };
  try {
    const { projectDir, writeErrors } = await createProjectAndWriteFiles(config2, files);
    if (writeErrors.length > 0) {
      return createErrorResult(result, 'File writing errors:', writeErrors, startTime);
    }
    return await createSuccessResult(files, projectDir, startTime, addValidationWarnings);
  } catch (error) {
    return createErrorResult(
      result,
      `Failed to create project directory: ${error instanceof Error ? error.message : UNKNOWN_ERROR_MESSAGE3}`,
      [],
      startTime
    );
  }
}
var UNKNOWN_ERROR_MESSAGE3 = 'Unknown error';
var init_project_generator_workflow = __esm(() => {
  init_project_generation_helpers();
  init_project_utilities();
  init_claude_md_generator();
  init_copilot_generator();
});

// ../../packages/adapters/src/project-generator.ts
var exports_project_generator = {};
__export(exports_project_generator, {
  ProjectGenerator: () => ProjectGenerator,
});
import fs10 from 'fs/promises';
import path5 from 'path';

class ProjectGenerator {
  templateEngine;
  templatesDir;
  constructor(templatesDir) {
    if (templatesDir) {
      this.templatesDir = templatesDir;
    } else {
      const currentFilePath = new URL(import.meta.url).pathname;
      const currentDir = path5.dirname(currentFilePath);
      this.templatesDir = path5.resolve(currentDir, '../templates');
    }
    this.templateEngine = new TemplateEngine(this.templatesDir);
  }
  async generateProject(config2) {
    const startTime = Date.now();
    try {
      const configValidation = this.validateProjectConfig(config2);
      if (!configValidation.valid) {
        return createErrorResult(
          createBaseResult(),
          'Invalid project configuration:',
          configValidation.errors,
          startTime
        );
      }
      return this.executeProjectGeneration(config2, startTime);
    } catch (error) {
      return handleUnexpectedError(error, startTime);
    }
  }
  async executeProjectGeneration(config2, startTime) {
    const setupResult = await prepareProjectSetup(config2, this.templateEngine, startTime);
    if (!setupResult.success) {
      return setupResult;
    }
    const generationResult = await generateFilesFromTemplate(
      config2,
      this.templateEngine,
      setupResult.files || [],
      startTime
    );
    if (!generationResult.success) {
      return generationResult;
    }
    return finalizeProject(
      config2,
      generationResult.files || [],
      startTime,
      this.addValidationWarnings.bind(this)
    );
  }
  async addValidationWarnings(result, projectDir) {
    const projectValidation = await this.validateProject(projectDir);
    if (!projectValidation.valid) {
      result.warnings.push('Project validation warnings:');
      result.warnings.push(...projectValidation.errors);
    }
  }
  validateProjectConfig(config2) {
    const requiredValidation = validateRequiredConfigFields(config2);
    const optionalValidation = validateOptionalConfigFields(config2);
    const allErrors = [...requiredValidation.errors, ...optionalValidation.errors];
    return {
      valid: allErrors.length === 0,
      errors: allErrors,
    };
  }
  async validateProject(projectPath) {
    const errors2 = [];
    try {
      await fs10.access(projectPath);
      const requiredFileErrors = await validateRequiredFiles(projectPath);
      errors2.push(...requiredFileErrors);
      const srcDirectoryErrors = await validateSrcDirectory(projectPath);
      errors2.push(...srcDirectoryErrors);
      const packageJsonErrors = await validatePackageJson(projectPath);
      errors2.push(...packageJsonErrors);
    } catch (error) {
      errors2.push(
        `Project directory not accessible: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
    return {
      valid: errors2.length === 0,
      errors: errors2,
    };
  }
  addTemplate(template) {
    const errors2 = [];
    if (!template.name) {
      errors2.push('Template name is required');
    }
    if (!template.version) {
      errors2.push('Template version is required');
    }
    if (
      !Array.isArray(template.supportedProjectTypes) ||
      template.supportedProjectTypes.length === 0
    ) {
      errors2.push('Template supportedProjectTypes must be a non-empty array');
    }
    if (!Array.isArray(template.files) || template.files.length === 0) {
      errors2.push('Template files must be a non-empty array');
    }
    if (errors2.length > 0) {
      throw new Error(`Invalid template: ${errors2.join(', ')}`);
    }
  }
  getAvailableTemplates() {
    return ['basic', 'web', 'cli', 'library'];
  }
  validateProjectName(name) {
    if (!name || name.trim().length === 0) {
      return {
        valid: false,
        errors: ['Project name is required'],
      };
    }
    if (!/^[\w-]+$/.test(name)) {
      return {
        valid: false,
        errors: ['Project name can only contain letters, numbers, hyphens, and underscores'],
      };
    }
    return {
      valid: true,
      errors: [],
    };
  }
}
var init_project_generator = __esm(() => {
  init_project_generator_workflow();
  init_template_engine();
  init_project_generation_helpers();
});

// ../../packages/adapters/src/generators/eslint-rules-constants.ts
var init_eslint_rules_constants = () => {};

// ../../packages/adapters/src/generators/eslint-rules.ts
var init_eslint_rules = __esm(() => {
  init_eslint_rules_constants();
});
// ../../packages/adapters/src/generators/eslint-generator.ts
var init_eslint_generator = __esm(() => {
  init_eslint_rules();
});

// ../../packages/adapters/src/generators/typescript-compiler-options.ts
var init_typescript_compiler_options = () => {};

// ../../packages/adapters/src/generators/typescript-config-builders.ts
var init_typescript_config_builders = __esm(() => {
  init_constants();
});

// ../../packages/adapters/src/generators/typescript-utilities.ts
var init_typescript_utilities = () => {};

// ../../packages/adapters/src/generators/typescript-generator.ts
var init_typescript_generator = __esm(() => {
  init_typescript_compiler_options();
  init_typescript_config_builders();
  init_typescript_utilities();
});

// ../../packages/adapters/src/generators/prettier-constants.ts
var init_prettier_constants = () => {};

// ../../packages/adapters/src/generators/prettier-config-builders.ts
var init_prettier_config_builders = __esm(() => {
  init_constants();
  init_prettier_constants();
});

// ../../packages/adapters/src/generators/prettier-file-generators.ts
var init_prettier_file_generators = __esm(() => {
  init_constants();
});

// ../../packages/adapters/src/generators/prettier-generator.ts
var init_prettier_generator = __esm(() => {
  init_constants();
  init_prettier_config_builders();
  init_prettier_file_generators();
});
// ../../packages/adapters/src/generators/vitest-generator.ts
var init_vitest_generator = __esm(() => {
  init_constants();
});
// ../../packages/adapters/src/utils/code-style-builders.ts
var init_code_style_builders = __esm(() => {
  init_constants();
});
// ../../packages/adapters/src/utils/manifest-builders.ts
var init_manifest_builders = __esm(() => {
  init_constants();
});
// ../../packages/adapters/src/generators/ai-context-constants.ts
var init_ai_context_constants = () => {};

// ../../packages/adapters/src/generators/ai-context-helpers.ts
var init_ai_context_helpers = __esm(() => {
  init_ai_context_constants();
});

// ../../packages/adapters/src/generators/ai-context-generator.ts
var init_ai_context_generator = __esm(() => {
  init_code_style_builders();
  init_constants();
  init_manifest_builders();
  init_ai_context_helpers();
});

// ../../packages/adapters/src/commands/init.ts
var init_init = __esm(() => {
  init_constants();
});

// ../../packages/adapters/src/utils/console-output.ts
class ConsoleOutput {
  static instance;
  options;
  constructor(options = {}) {
    this.options = {
      useColor: options.useColor ?? true,
      usePrefixes: options.usePrefixes ?? true,
    };
  }
  static getInstance(options) {
    if (!ConsoleOutput.instance) {
      ConsoleOutput.instance = new ConsoleOutput(options);
    }
    return ConsoleOutput.instance;
  }
  log(message) {
    this.output('log', message);
  }
  info(message) {
    this.output('info', message);
  }
  warn(message) {
    this.output('warn', message);
  }
  error(message) {
    this.output('error', message);
  }
  output(level, message) {
    const formattedMessage = this.formatMessage(level, message);
    switch (level) {
      case 'error':
        process.stderr.write(`${formattedMessage}
`);
        break;
      case 'warn':
        process.stderr.write(`${formattedMessage}
`);
        break;
      case 'info':
        process.stdout.write(`${formattedMessage}
`);
        break;
      case 'log':
      default:
        process.stdout.write(`${formattedMessage}
`);
        break;
    }
  }
  formatMessage(level, message) {
    const colorReset = this.options.useColor ? '\x1B[0m' : '';
    const messageStr = typeof message === 'string' ? message : JSON.stringify(message);
    if (!this.options.usePrefixes) {
      return messageStr;
    }
    const prefix = this.getPrefixForLevel(level);
    if (prefix) {
      return `${prefix}${colorReset} ${messageStr}`;
    }
    return messageStr;
  }
  getPrefixForLevel(level) {
    switch (level) {
      case 'error':
        return this.options.useColor ? '\x1B[31m\u2717' : '\u274C';
      case 'warn':
        return this.options.useColor ? '\x1B[33m\u26A0\uFE0F' : '\u26A0\uFE0F';
      case 'info':
        return '\u2139\uFE0F';
      case 'log':
      default:
        return '';
    }
  }
  help(message) {
    const formattedMessage = this.options.usePrefixes ? `\u2139\uFE0F ${message}` : message;
    process.stdout.write(`${formattedMessage}
`);
  }
  suggestion(message) {
    const formattedMessage = this.options.usePrefixes ? `\u2139\uFE0F ${message}` : message;
    process.stdout.write(`${formattedMessage}
`);
  }
  numberedSuggestion(index, message) {
    const formattedMessage = this.options.usePrefixes
      ? `\u2139\uFE0F   ${index}. ${message}`
      : `   ${index}. ${message}`;
    process.stdout.write(`${formattedMessage}
`);
  }
  step(current, total, message) {
    const formattedMessage = this.options.usePrefixes
      ? `\uD83D\uDCCD (${current}/${total}) ${message}`
      : `(${current}/${total}) ${message}`;
    process.stdout.write(`${formattedMessage}
`);
  }
  header(title) {
    const color = this.options.useColor ? '\x1B[36m' : '';
    const colorReset = this.options.useColor ? '\x1B[0m' : '';
    const formattedMessage = `
${color}=== ${title} ===${colorReset}`;
    process.stdout.write(`${formattedMessage}
`);
  }
  separator() {
    process.stdout.write(`
`);
  }
}
var consoleOutput;
var init_console_output = __esm(() => {
  consoleOutput = ConsoleOutput.getInstance();
});

// ../../packages/adapters/src/utils/cli-error-handler.ts
var init_cli_error_handler = __esm(() => {
  init_console_output();
});
// ../../packages/adapters/src/utils/progress.ts
class ProgressIndicator {
  current = 0;
  total;
  width;
  showPercentage;
  showTime;
  label;
  startTime;
  lastUpdate = 0;
  isActive = false;
  constructor(options) {
    this.total = options.total;
    this.width = options.width || DEFAULT_WIDTH;
    this.showPercentage = options.showPercentage !== false;
    this.showTime = options.showTime !== false;
    this.label = options.label || '';
    this.startTime = Date.now();
  }
  start() {
    this.isActive = true;
    this.render();
  }
  update(value, message) {
    if (!this.isActive) return;
    this.current = Math.min(value, this.total);
    this.render(message);
  }
  increment(message) {
    if (!this.isActive) return;
    this.current = Math.min(this.current + 1, this.total);
    this.render(message);
  }
  complete(message) {
    if (!this.isActive) return;
    this.current = this.total;
    this.render(message);
    process.stdout.write(`
`);
    this.isActive = false;
  }
  stop() {
    if (!this.isActive) return;
    this.isActive = false;
    process.stdout.write(`
`);
  }
  render(message) {
    const now = Date.now();
    if (this.shouldSkipUpdate(now)) {
      return;
    }
    this.lastUpdate = now;
    const display = this.buildDisplayString(now, message);
    this.renderToTerminal(display);
  }
  shouldSkipUpdate(now) {
    return now - this.lastUpdate < UPDATE_THROTTLE_MS && this.current < this.total;
  }
  buildDisplayString(now, message) {
    const progressData = this.calculateProgress();
    const bar = this.buildProgressBar(progressData.filled, progressData.empty);
    let display = this.buildLabelString();
    display += `[${bar}]`;
    display += this.buildPercentageString(progressData.percentage);
    display += this.buildTimeString(now);
    display += this.buildMessageString(message);
    return display;
  }
  calculateProgress() {
    const percentage = Math.round((this.current / this.total) * PERCENTAGE_MULTIPLIER);
    const filled = Math.round((this.current / this.total) * this.width);
    const empty = this.width - filled;
    return { percentage, filled, empty };
  }
  buildProgressBar(filled, empty) {
    return '\u2588'.repeat(filled) + '\u2591'.repeat(empty);
  }
  buildLabelString() {
    return this.label ? `${this.label} ` : '';
  }
  buildPercentageString(percentage) {
    return this.showPercentage ? ` ${percentage}%` : '';
  }
  buildTimeString(now) {
    if (!this.showTime) return '';
    const elapsed = now - this.startTime;
    return ` (${this.formatTime(elapsed)})`;
  }
  buildMessageString(message) {
    return message ? ` - ${message}` : '';
  }
  renderToTerminal(display) {
    process.stdout.write(`\r${' '.repeat(process.stdout.columns || DEFAULT_TERMINAL_WIDTH)}\r`);
    process.stdout.write(display);
  }
  formatTime(ms) {
    if (ms < MILLISECOND_IN_SECOND) {
      return `${ms}ms`;
    } else if (ms < MILLISECOND_IN_MINUTE) {
      return `${(ms / MILLISECOND_IN_SECOND).toFixed(1)}s`;
    }
    const minutes = Math.floor(ms / MILLISECOND_IN_MINUTE);
    const seconds = Math.floor((ms % MILLISECOND_IN_MINUTE) / MILLISECOND_IN_SECOND);
    return `${minutes}m ${seconds}s`;
  }
}

class StepProgressIndicator {
  steps;
  currentStep = 0;
  currentProgress = null;
  label;
  constructor(steps, label) {
    this.steps = steps;
    this.label = label || 'Progress';
  }
  start(steps, label) {
    if (steps) {
      this.steps = steps;
    }
    if (label) {
      this.label = label;
    }
    this.currentStep = 0;
    this.nextStep();
  }
  nextStep() {
    if (this.currentProgress) {
      this.currentProgress.complete();
    }
    if (this.currentStep >= this.steps.length) {
      return;
    }
    const step = this.steps[this.currentStep];
    if (!step) return;
    const weight = step.weight || 1;
    this.currentProgress = new ProgressIndicator({
      total: weight,
      label: `(${this.currentStep + 1}/${this.steps.length}) ${step.name}`,
      showPercentage: true,
      showTime: true,
    });
    this.currentProgress.start();
    this.currentStep++;
  }
  update(value, message) {
    if (this.currentProgress) {
      this.currentProgress.update(value, message);
    }
  }
  increment(message) {
    if (this.currentProgress) {
      this.currentProgress.increment(message);
    }
  }
  complete(message) {
    if (this.currentProgress) {
      this.currentProgress.complete();
    }
    if (message) {
      process.stdout.write(`\u2705 ${message}
`);
    } else {
      process.stdout.write(`\u2705 ${this.label} completed!
`);
    }
  }
  error(message) {
    if (this.currentProgress) {
      this.currentProgress.stop();
    }
    if (message) {
      process.stderr.write(`\u274C ${message}
`);
    } else {
      process.stderr.write(`\u274C ${this.label} failed!
`);
    }
  }
  fail(message) {
    this.error(message);
  }
  next(message) {
    if (message && this.currentProgress) {
      this.currentProgress.update(1, message);
    }
  }
  stop() {
    if (this.currentProgress) {
      this.currentProgress.stop();
    }
  }
}

class Spinner {
  frames = [
    '\u280B',
    '\u2819',
    '\u2839',
    '\u2838',
    '\u283C',
    '\u2834',
    '\u2826',
    '\u2827',
    '\u2807',
    '\u280F',
  ];
  currentFrame = 0;
  interval = null;
  message;
  isActive = false;
  constructor(message = 'Working...') {
    this.message = message;
  }
  start() {
    if (this.isActive) return;
    this.isActive = true;
    this.interval = setInterval(() => {
      this.render();
    }, SPINNER_INTERVAL_MS);
  }
  stop(finalMessage) {
    if (!this.isActive) return;
    this.isActive = false;
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
    process.stdout.write(`\r${' '.repeat(process.stdout.columns || DEFAULT_TERMINAL_WIDTH)}\r`);
    if (finalMessage) {
      process.stdout.write(`${finalMessage}
`);
    }
  }
  updateMessage(message) {
    this.message = message;
  }
  render() {
    const frame = this.frames[this.currentFrame];
    this.currentFrame = (this.currentFrame + 1) % this.frames.length;
    process.stdout.write(`\r${frame} ${this.message}`);
  }
}
var UPDATE_THROTTLE_MS = 50,
  DEFAULT_WIDTH = 40,
  SPINNER_INTERVAL_MS = 100,
  MILLISECOND_IN_SECOND = 1000,
  SECOND_IN_MINUTE = 60,
  MILLISECOND_IN_MINUTE,
  DEFAULT_TERMINAL_WIDTH = 80,
  PERCENTAGE_MULTIPLIER = 100,
  Progress,
  PROJECT_GENERATION_STEPS;
var init_progress = __esm(() => {
  init_constants();
  MILLISECOND_IN_MINUTE = MILLISECOND_IN_SECOND * SECOND_IN_MINUTE;
  Progress = {
    create: (options) => {
      return new ProgressIndicator(options);
    },
    steps: (steps, label) => {
      return new StepProgressIndicator(steps, label);
    },
    spinner: (message) => {
      return new Spinner(message);
    },
  };
  PROJECT_GENERATION_STEPS = [
    { name: 'Validating configuration', weight: 1 },
    { name: 'Creating directory structure', weight: FORMATTING.JSON_INDENT_SIZE },
    { name: 'Generating package.json', weight: 1 },
    { name: 'Setting up TypeScript', weight: FORMATTING.JSON_INDENT_SIZE },
    { name: 'Configuring ESLint', weight: 1 },
    { name: 'Adding Prettier', weight: 1 },
    { name: 'Setting up tests', weight: 1 },
    { name: 'Configuring AI assistants', weight: FORMATTING.JSON_INDENT_SIZE },
    { name: 'Creating source files', weight: FORMATTING.JSON_INDENT_SIZE },
    { name: 'Validating project', weight: 1 },
  ];
});

// ../../packages/adapters/src/utils/cli-helpers.ts
class CLILogger {
  verbose;
  silent;
  json;
  color;
  consoleOutput;
  JSON_SPACING = DEFAULT_SPACING.JSON;
  STANDARD_INDENTATION = DEFAULT_SPACING.INDENTATION;
  constructor(options = {}) {
    this.verbose = options.verbose || false;
    this.silent = options.silent || false;
    this.json = options.json || false;
    this.color = options.color || false;
    this.consoleOutput = new ConsoleOutput({
      useColor: this.color,
      usePrefixes: true,
    });
  }
  info(message) {
    if (this.silent) return;
    if (this.json) {
      this.consoleOutput.log(
        JSON.stringify({ level: 'info', message }, null, JSON_SERIALIZATION.PRETTY_INDENT)
      );
    } else if (this.verbose) {
      this.consoleOutput.info(message);
    }
  }
  success(message, data) {
    if (this.silent) return;
    if (this.json) {
      const output = { status: 'success', message };
      if (data) {
        Object.assign(output, { data });
      }
      this.consoleOutput.log(JSON.stringify(output, null, JSON_SERIALIZATION.PRETTY_INDENT));
    } else {
      this.consoleOutput.log(`\u2705 ${message}`);
    }
  }
  warn(message) {
    if (this.silent) return;
    if (this.json) {
      this.consoleOutput.log(
        JSON.stringify({ level: 'warn', message }, null, JSON_SERIALIZATION.PRETTY_INDENT)
      );
    } else {
      this.consoleOutput.warn(message);
    }
  }
  error(message, details, _forceColor) {
    if (this.silent) return;
    if (this.json) {
      this.consoleOutput.log(
        JSON.stringify({ level: 'error', message, details }, null, JSON_SERIALIZATION.PRETTY_INDENT)
      );
    } else {
      this.consoleOutput.error(message);
      if (details && this.verbose) {
        this.logErrorDetails(details);
      }
    }
  }
  logErrorDetails(details) {
    if (details instanceof Error) {
      this.consoleOutput.error(details.message);
      if (details.stack) {
        this.consoleOutput.error(details.stack);
      }
    } else {
      this.consoleOutput.error(JSON.stringify(details, null, this.JSON_SPACING));
    }
  }
  logVerbose(message) {
    if (this.verbose && !this.silent) {
      if (this.json) {
        this.consoleOutput.log(
          JSON.stringify({ level: 'verbose', message }, null, JSON_SERIALIZATION.PRETTY_INDENT)
        );
      } else {
        const gray = this.color ? '\x1B[90m' : '';
        const reset = this.color ? '\x1B[0m' : '';
        this.consoleOutput.log(`${gray}${message}${reset}`);
      }
    }
  }
  debug(message, data) {
    if (this.verbose && !this.silent) {
      if (this.json) {
        this.consoleOutput.log(
          JSON.stringify({ level: 'debug', message, data }, null, JSON_SERIALIZATION.PRETTY_INDENT)
        );
      } else {
        this.consoleOutput.log(`\uD83D\uDD0D ${message}`);
        if (data) {
          this.consoleOutput.log(`   ${JSON.stringify(data, null, DEBUG_JSON_SPACING)}`);
        }
      }
    }
  }
  step(current, total, message) {
    if (this.silent) return;
    if (this.json) {
      this.consoleOutput.log(
        JSON.stringify(
          {
            level: 'step',
            step: current,
            total,
            message,
          },
          null,
          JSON_SERIALIZATION.PRETTY_INDENT
        )
      );
    } else {
      this.consoleOutput.step(current, total, message);
    }
  }
  spinner(message) {
    if (this.silent || this.json) {
      return new SilentSpinner();
    }
    return new Spinner(message);
  }
  progress(total, label) {
    if (this.silent || this.json) {
      return new SilentProgressIndicator(total);
    }
    return Progress.create({ total, label });
  }
  header(title) {
    if (this.silent) return;
    if (this.json) {
      this.consoleOutput.log(
        JSON.stringify({ status: 'header', title }, null, JSON_SERIALIZATION.PRETTY_INDENT)
      );
    } else {
      this.consoleOutput.header(title);
    }
  }
  separator() {
    if (this.silent) return;
    if (!this.json) {
      this.consoleOutput.separator();
    }
  }
}

class SilentProgressIndicator {
  total;
  constructor(total) {
    this.total = total;
  }
  start() {}
  update(_current) {}
  finish() {}
}
var DEFAULT_SPACING, SilentSpinner;
var init_cli_helpers = __esm(() => {
  init_cli_error_handler();
  init_console_output();
  init_constants();
  init_progress();
  DEFAULT_SPACING = {
    JSON: 2,
    INDENTATION: 2,
  };
  SilentSpinner = class SilentSpinner extends Spinner {
    constructor() {
      super('');
    }
    start() {}
    stop() {}
    succeed(_text) {}
    fail(_text) {}
  };
});

// ../../packages/adapters/src/utils/help-constants.ts
var PADDING_LENGTH = 15,
  FLAG_PADDING = 20,
  CHOICE_PADDING = 23,
  GENERAL_HELP_TEMPLATE = `
\uD83D\uDE80 N\xECmata CLI - TypeScript Project Generator

USAGE:
  nimata [COMMAND] [OPTIONS]

COMMANDS:
  init         Initialize a new TypeScript project
  help         Show this help message
  version      Show version information

Get help for specific command:
  nimata help [COMMAND]
  nimata [COMMAND] --help

EXAMPLES:
  nimata init my-project
  nimata init my-web-app --template web --quality strict
  nimata init my-cli --template cli --ai claude-code,copilot

OPTIONS:
  --help, -h     Show help information
  --version, -v  Show version information

For more information, visit: https://github.com/nimata/cli
`,
  COMMAND_HELP_TEMPLATE = `
\uD83D\uDE80 {{COMMAND_NAME}} - {{DESCRIPTION}}

USAGE:
  nimata {{USAGE}}

EXAMPLES:
{{EXAMPLES}}

OPTIONS:
{{OPTIONS}}
`,
  TOPIC_HELP_HEADER = '\uD83D\uDCDA {{TOPIC_NAME}} - {{DESCRIPTION}}',
  SUBCOMMANDS_HEADER = `
SUBCOMMANDS:
  `,
  USAGE_HEADER = `
USAGE:
  `,
  EXAMPLES_HEADER = `
EXAMPLES:
`,
  OPTIONS_HEADER = `
OPTIONS:
`,
  SEE_ALSO_HEADER = `
SEE ALSO:
  `;

// ../../packages/adapters/src/utils/help-formatters.ts
function formatOptions(options) {
  return options.map((option) => {
    let line = `  ${option.flags.padEnd(FLAG_PADDING)} ${option.description}`;
    if (option.defaultValue !== undefined) {
      line += ` (default: ${option.defaultValue})`;
    }
    if (option.choices) {
      line += `
${' '.repeat(CHOICE_PADDING)}Choices: ${option.choices.join(', ')}`;
    }
    return line;
  }).join(`
`);
}
function formatCommandHelp(command) {
  let output = COMMAND_HELP_TEMPLATE.replace('{{COMMAND_NAME}}', command.name.toUpperCase())
    .replace('{{DESCRIPTION}}', command.description)
    .replace('{{USAGE}}', command.usage)
    .replace(
      '{{EXAMPLES}}',
      command.examples.map((example) => `  ${example}`).join(`
`)
    )
    .replace('{{OPTIONS}}', formatOptions(command.options));
  if (command.subcommands && command.subcommands.length > 0) {
    output += `${SUBCOMMANDS_HEADER}${command.subcommands.join(', ')}`;
  }
  return output.trim();
}
function formatTopicHelp(topic) {
  let output = TOPIC_HELP_HEADER.replace('{{TOPIC_NAME}}', topic.name.toUpperCase()).replace(
    '{{DESCRIPTION}}',
    topic.description
  );
  if (topic.usage) {
    output += `${USAGE_HEADER}${topic.usage}`;
  }
  if (topic.examples && topic.examples.length > 0) {
    const formattedExamples = topic.examples.map((example) => `  ${example}`).join(`
`);
    output += `${EXAMPLES_HEADER}${formattedExamples}`;
  }
  if (topic.options && topic.options.length > 0) {
    output += `${OPTIONS_HEADER}${formatOptions(topic.options)}`;
  }
  if (topic.seeAlso && topic.seeAlso.length > 0) {
    output += `${SEE_ALSO_HEADER}${topic.seeAlso.join(', ')}`;
  }
  return output;
}
function formatTopicsList(topics) {
  const sortedTopics = Array.from(topics.entries()).sort(([a], [b]) => a.localeCompare(b));
  let output = `
\uD83D\uDCDA Available Help Topics:
`;
  for (const [name, topic] of sortedTopics) {
    output += `  ${name.padEnd(PADDING_LENGTH)} - ${topic.description}
`;
  }
  output += `
Get help: nimata help [TOPIC]`;
  return output;
}
var init_help_formatters = () => {};

// ../../packages/adapters/src/utils/help-topics.ts
function createProjectTypesTopic() {
  return {
    [NAME_FIELD]: 'Project Types',
    [DESCRIPTION_FIELD]: 'Different project templates available',
    [EXAMPLES_FIELD]: [
      'nimata init my-app --template basic',
      'nimata init my-web-app --template web',
      'nimata init my-cli-tool --template cli',
      'nimata init my-library --template library',
    ],
    [OPTIONS_FIELD]: [
      {
        flags: TEMPLATE_FLAG,
        [DESCRIPTION_FIELD]: 'Project template to use',
        choices: ['basic', 'web', 'cli', 'library'],
        defaultValue: BASIC_TEMPLATE,
      },
    ],
    [SEE_ALSO_FIELD]: [QUALITY_LEVELS_TOPIC, AI_ASSISTANTS_TOPIC],
  };
}
function createQualityLevelsTopic() {
  return {
    [NAME_FIELD]: 'Quality Levels',
    [DESCRIPTION_FIELD]: 'Code quality configurations available',
    [EXAMPLES_FIELD]: [
      'nimata init my-app --quality light',
      'nimata init my-app --quality medium',
      'nimata init my-app --quality strict',
    ],
    [OPTIONS_FIELD]: [
      {
        flags: QUALITY_FLAG,
        [DESCRIPTION_FIELD]: 'Code quality level',
        choices: ['light', 'medium', 'strict'],
        defaultValue: MEDIUM_QUALITY,
      },
    ],
    [SEE_ALSO_FIELD]: [PROJECT_TYPES_TOPIC, AI_ASSISTANTS_TOPIC],
  };
}
function createAIAssistantsTopic() {
  return {
    [NAME_FIELD]: 'AI Assistants',
    [DESCRIPTION_FIELD]: 'AI assistant configurations available',
    [EXAMPLES_FIELD]: [
      'nimata init my-app --ai claude-code',
      'nimata init my-app --ai copilot',
      'nimata init my-app --ai claude-code,copilot',
    ],
    [OPTIONS_FIELD]: [
      {
        flags: AI_FLAG,
        [DESCRIPTION_FIELD]: 'AI assistants to configure',
        choices: [CLAUDE_CODE2, COPILOT2],
        defaultValue: CLAUDE_CODE2,
      },
    ],
    [SEE_ALSO_FIELD]: [PROJECT_TYPES_TOPIC, QUALITY_LEVELS_TOPIC],
  };
}
function createConfigurationTopic() {
  return {
    [NAME_FIELD]: 'Configuration',
    [DESCRIPTION_FIELD]: 'Configuration options and files',
    [EXAMPLES_FIELD]: [
      'nimata init my-app --config custom.json',
      'nimata config show',
      'nimata config set quality strict',
    ],
    [OPTIONS_FIELD]: [
      {
        flags: CONFIG_FLAG,
        [DESCRIPTION_FIELD]: 'Configuration file to use',
      },
    ],
    [SEE_ALSO_FIELD]: [PROJECT_TYPES_TOPIC, QUALITY_LEVELS_TOPIC],
  };
}
function createTemplatesTopic() {
  return {
    [NAME_FIELD]: 'Templates',
    [DESCRIPTION_FIELD]: 'Custom templates and template management',
    [EXAMPLES_FIELD]: [
      'nimata init my-app --template @myorg/custom-template',
      'nimata template list',
      'nimata template create my-template',
    ],
    [OPTIONS_FIELD]: [
      {
        flags: TEMPLATE_FLAG,
        [DESCRIPTION_FIELD]: 'Template name or package to use',
      },
    ],
    [SEE_ALSO_FIELD]: [PROJECT_TYPES_TOPIC, CONFIGURATION_TOPIC],
  };
}
function createInteractiveModeTopic() {
  return {
    [NAME_FIELD]: 'Interactive Mode',
    [DESCRIPTION_FIELD]: 'Interactive project setup with guided prompts',
    [EXAMPLES_FIELD]: ['nimata init my-app --interactive', 'nimata init -i'],
    [SEE_ALSO_FIELD]: [PROJECT_TYPES_TOPIC, QUALITY_LEVELS_TOPIC],
  };
}
function createAdvancedOptionsTopic() {
  return {
    [NAME_FIELD]: 'Advanced Options',
    [DESCRIPTION_FIELD]: 'Advanced configuration and customization options',
    [EXAMPLES_FIELD]: [
      'nimata init my-app --template web --quality strict --ai claude-code,copilot',
      'nimata init my-app --config custom.json --verbose',
    ],
    [SEE_ALSO_FIELD]: [PROJECT_TYPES_TOPIC, QUALITY_LEVELS_TOPIC, AI_ASSISTANTS_TOPIC],
  };
}
function createTroubleshootingTopic() {
  return {
    [NAME_FIELD]: 'Troubleshooting',
    [DESCRIPTION_FIELD]: 'Common issues and solutions',
    [EXAMPLES_FIELD]: [
      'Check logs: ~/.nimata/logs/',
      'Verify installation: nimata --version',
      'Get help: nimata help',
    ],
    [SEE_ALSO_FIELD]: [CONFIGURATION_TOPIC],
  };
}
function createHelpTopics() {
  const topics = new Map();
  topics.set(PROJECT_TYPES_TOPIC, createProjectTypesTopic());
  topics.set(QUALITY_LEVELS_TOPIC, createQualityLevelsTopic());
  topics.set(AI_ASSISTANTS_TOPIC, createAIAssistantsTopic());
  topics.set(CONFIGURATION_TOPIC, createConfigurationTopic());
  topics.set(TEMPLATES_TOPIC, createTemplatesTopic());
  topics.set('interactive-mode', createInteractiveModeTopic());
  topics.set('advanced-options', createAdvancedOptionsTopic());
  topics.set('troubleshooting', createTroubleshootingTopic());
  return topics;
}
function createInitCommandHelp() {
  return {
    name: INIT_COMMAND,
    [DESCRIPTION_FIELD]: 'Initialize a new TypeScript project',
    usage: 'init [PROJECT_NAME] [OPTIONS]',
    [EXAMPLES_FIELD]: [
      'nimata init my-project',
      'nimata init my-web-app --template web',
      'nimata init my-cli --template cli --ai claude-code',
      'nimata init my-lib --template library --quality strict',
    ],
    [OPTIONS_FIELD]: getInitCommandOptions(),
  };
}
function getInitCommandOptions() {
  return [
    {
      flags: `${TEMPLATE_FLAG} <name>`,
      [DESCRIPTION_FIELD]: 'Project template to use',
      choices: ['basic', 'web', 'cli', 'library'],
      defaultValue: BASIC_TEMPLATE,
    },
    {
      flags: `${QUALITY_FLAG} <level>`,
      [DESCRIPTION_FIELD]: 'Code quality level',
      choices: ['light', 'medium', 'strict'],
      defaultValue: MEDIUM_QUALITY,
    },
    {
      flags: `${AI_FLAG} <assistants>`,
      [DESCRIPTION_FIELD]: 'AI assistants to configure',
      choices: [CLAUDE_CODE2, COPILOT2],
      defaultValue: CLAUDE_CODE2,
    },
    {
      flags: `${CONFIG_FLAG} <file>`,
      [DESCRIPTION_FIELD]: 'Configuration file to use',
    },
    {
      flags: HELP_FLAG,
      [DESCRIPTION_FIELD]: HELP_DESCRIPTION,
    },
  ];
}
function createHelpCommandHelp() {
  return {
    name: HELP_COMMAND,
    [DESCRIPTION_FIELD]: HELP_DESCRIPTION,
    usage: 'help [COMMAND|TOPIC]',
    [EXAMPLES_FIELD]: [
      'nimata help',
      'nimata help init',
      'nimata help project-types',
      'nimata init --help',
    ],
    [OPTIONS_FIELD]: [
      {
        flags: HELP_FLAG,
        [DESCRIPTION_FIELD]: HELP_DESCRIPTION,
      },
    ],
  };
}
function createVersionCommandHelp() {
  return {
    name: VERSION_COMMAND,
    [DESCRIPTION_FIELD]: 'Show version information',
    usage: 'version',
    [EXAMPLES_FIELD]: ['nimata version', 'nimata --version', 'nimata -v'],
    [OPTIONS_FIELD]: [
      {
        flags: VERSION_FLAG,
        [DESCRIPTION_FIELD]: 'Show version information',
      },
    ],
  };
}
function createCommandHelp() {
  const commands = new Map();
  commands.set(INIT_COMMAND, createInitCommandHelp());
  commands.set(HELP_COMMAND, createHelpCommandHelp());
  commands.set(VERSION_COMMAND, createVersionCommandHelp());
  return commands;
}
var TEMPLATE_FLAG = '--template, -t',
  QUALITY_FLAG = '--quality, -q',
  AI_FLAG = '--ai, -a',
  BASIC_TEMPLATE = 'basic',
  MEDIUM_QUALITY = 'medium',
  PROJECT_TYPES_TOPIC = 'project-types',
  QUALITY_LEVELS_TOPIC = 'quality-levels',
  AI_ASSISTANTS_TOPIC = 'ai-assistants',
  CONFIGURATION_TOPIC = 'configuration',
  TEMPLATES_TOPIC = 'templates',
  CLAUDE_CODE2 = 'claude-code',
  HELP_DESCRIPTION = 'Show help information',
  COPILOT2 = 'copilot',
  INIT_COMMAND = 'init',
  HELP_COMMAND = 'help',
  VERSION_COMMAND = 'version',
  HELP_FLAG = '--help, -h',
  CONFIG_FLAG = '--config, -c',
  VERSION_FLAG = '--version, -v',
  DESCRIPTION_FIELD = 'description',
  EXAMPLES_FIELD = 'examples',
  OPTIONS_FIELD = 'options',
  SEE_ALSO_FIELD = 'seeAlso',
  NAME_FIELD = 'name';

// ../../packages/adapters/src/utils/help-system.ts
class HelpSystem {
  topics;
  commands;
  constructor() {
    this.topics = createHelpTopics();
    this.commands = createCommandHelp();
  }
  showGeneralHelp() {
    process.stdout.write(`${GENERAL_HELP_TEMPLATE.trim()}
`);
  }
  showCommandHelp(commandName) {
    const command = this.commands.get(commandName);
    if (!command) {
      const availableCommands = Array.from(this.commands.keys());
      process.stderr.write(`Unknown command: ${commandName}
`);
      process.stdout.write(`Available commands: ${availableCommands.join(', ')}
`);
      return;
    }
    process.stdout.write(`${formatCommandHelp(command)}
`);
  }
  showTopicHelp(topicName) {
    const topic = this.topics.get(topicName);
    if (!topic) {
      const availableTopics = Array.from(this.topics.keys());
      process.stderr.write(`Unknown topic: ${topicName}
`);
      process.stdout.write(`Available topics: ${availableTopics.join(', ')}
`);
      return;
    }
    process.stdout.write(`${formatTopicHelp(topic)}
`);
  }
  showTopicsList() {
    process.stdout.write(`${formatTopicsList(this.topics)}
`);
  }
  showCommandsList() {
    const commands = Array.from(this.commands.values());
    process.stdout.write(`Available commands:

`);
    const COMMAND_PADDING = 12;
    for (const command of commands) {
      process.stdout.write(`  ${command.name.padEnd(COMMAND_PADDING)} ${command.description}
`);
    }
    process.stdout.write(`
Use "nimata help <command>" for more information on a specific command.
`);
  }
  getAvailableTopics() {
    return Array.from(this.topics.keys());
  }
  getAvailableCommands() {
    return Array.from(this.commands.keys());
  }
  hasTopic(topicName) {
    return this.topics.has(topicName);
  }
  hasCommand(commandName) {
    return this.commands.has(commandName);
  }
  listTopics() {
    this.showTopicsList();
  }
  show() {
    this.showGeneralHelp();
  }
  getTopics() {
    return this.getAvailableTopics();
  }
  getCommands() {
    return this.getAvailableCommands();
  }
}
var helpSystem;
var init_help_system = __esm(() => {
  init_help_formatters();
  helpSystem = new HelpSystem();
});

// ../../packages/adapters/src/utils/cache-implementations.ts
import { promises as fs11 } from 'fs';
import { join as join6 } from 'path';

class MemoryCache {
  cache = new Map();
  maxSize;
  defaultTtl;
  constructor(options = {}) {
    this.maxSize = options.maxSize || DEFAULT_MAX_SIZE;
    this.defaultTtl = options.ttl || DEFAULT_TTL_MINUTES * MINUTE_IN_MS;
  }
  get(key) {
    const item = this.cache.get(key);
    if (!item) {
      return null;
    }
    if (item.ttl && Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }
    return item.value;
  }
  set(key, value, ttl) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.defaultTtl,
    });
  }
  delete(key) {
    return this.cache.delete(key);
  }
  clear() {
    this.cache.clear();
  }
  size() {
    return this.cache.size;
  }
  cleanup() {
    let cleaned = 0;
    const now = Date.now();
    for (const [key, item] of this.cache.entries()) {
      if (item.ttl && now - item.timestamp > item.ttl) {
        this.cache.delete(key);
        cleaned++;
      }
    }
    return cleaned;
  }
}

class FileSystemCache {
  cacheDir;
  defaultTtl;
  constructor(options = {}) {
    this.cacheDir = options.directory || join6(process.cwd(), '.nimata-cache');
    this.defaultTtl = options.ttl || DEFAULT_HOUR_TTL;
  }
  async init() {
    try {
      await fs11.mkdir(this.cacheDir, { recursive: true });
    } catch {}
  }
  async get(key) {
    const filePath = join6(this.cacheDir, `${key}.cache`);
    const metaPath = join6(this.cacheDir, `${key}.meta`);
    try {
      await fs11.access(filePath);
      await fs11.access(metaPath);
      const metaContent = await fs11.readFile(metaPath, 'utf-8');
      const meta = JSON.parse(metaContent);
      if (Date.now() - meta.timestamp > meta.ttl) {
        await fs11.unlink(filePath);
        await fs11.unlink(metaPath);
        return null;
      }
      return await fs11.readFile(filePath, 'utf-8');
    } catch {
      return null;
    }
  }
  async set(key, content, ttl) {
    await this.init();
    const filePath = join6(this.cacheDir, `${key}.cache`);
    const metaPath = join6(this.cacheDir, `${key}.meta`);
    const meta = {
      timestamp: Date.now(),
      ttl: ttl || this.defaultTtl,
    };
    await Promise.all([
      fs11.writeFile(filePath, content, 'utf-8'),
      fs11.writeFile(metaPath, JSON.stringify(meta), 'utf-8'),
    ]);
  }
  async delete(key) {
    const filePath = join6(this.cacheDir, `${key}.cache`);
    const metaPath = join6(this.cacheDir, `${key}.meta`);
    try {
      await Promise.all([fs11.unlink(filePath), fs11.unlink(metaPath)]);
    } catch {}
  }
  async clear() {
    try {
      const files = await fs11.readdir(this.cacheDir);
      await Promise.all(files.map((file) => fs11.unlink(join6(this.cacheDir, file))));
    } catch {}
  }
  async cleanup() {
    try {
      const files = await fs11.readdir(this.cacheDir);
      const now = Date.now();
      let cleaned = 0;
      for (const file of files) {
        if (file.endsWith('.meta')) {
          cleaned += await this.processMetadataFile(file, now);
        }
      }
      return cleaned;
    } catch {
      return 0;
    }
  }
  async processMetadataFile(file, now) {
    const metaPath = join6(this.cacheDir, file);
    const cachePath = join6(this.cacheDir, file.replace('.meta', '.cache'));
    try {
      const shouldDelete = await this.isMetadataExpired(metaPath, now);
      if (shouldDelete) {
        await this.deleteCacheFiles(metaPath, cachePath);
        return 1;
      }
      return 0;
    } catch {
      await this.deleteCacheFilesSafe(metaPath, cachePath);
      return 1;
    }
  }
  async isMetadataExpired(metaPath, now) {
    const metaContent = await fs11.readFile(metaPath, 'utf-8');
    const meta = JSON.parse(metaContent);
    return now - meta.timestamp > meta.ttl;
  }
  async deleteCacheFiles(metaPath, cachePath) {
    await Promise.all([fs11.unlink(metaPath), fs11.unlink(cachePath)]);
  }
  async deleteCacheFilesSafe(metaPath, cachePath) {
    await Promise.all([
      fs11.unlink(metaPath).catch(() => Promise.resolve()),
      fs11.unlink(cachePath).catch(() => Promise.resolve()),
    ]);
  }
}
var DEFAULT_MAX_SIZE = 1000,
  DEFAULT_TTL_MINUTES = 5,
  SECONDS_PER_MINUTE = 60,
  MS_PER_SECOND = 1000,
  DEFAULT_HOUR_TTL,
  MINUTE_IN_MS;
var init_cache_implementations = __esm(() => {
  DEFAULT_HOUR_TTL = SECONDS_PER_MINUTE * SECONDS_PER_MINUTE * MS_PER_SECOND;
  MINUTE_IN_MS = SECONDS_PER_MINUTE * MS_PER_SECOND;
});

// ../../packages/adapters/src/utils/memoization.ts
function createMemoizedFunction(func, cache) {
  const memoCache = cache || new MemoryCache();
  return (...args) => {
    const key = JSON.stringify(args);
    const result = memoCache.get(key);
    if (result === null) {
      const newResult = func(...args);
      memoCache.set(key, newResult);
      return newResult;
    }
    return result;
  };
}
var init_memoization = __esm(() => {
  init_cache_implementations();
});

// ../../packages/adapters/src/utils/performance-core.ts
import { randomBytes } from 'crypto';

class PerformanceMonitor {
  metrics = [];
  activeMetrics = new Map();
  start(operation) {
    const timestamp = Date.now();
    const randomSuffix = randomBytes(RANDOM_BYTES_LENGTH).toString('hex');
    const id = `${operation}_${timestamp}_${randomSuffix}`;
    const metric = {
      operation,
      startTime: timestamp,
      memoryStart: this.getMemoryUsage(),
    };
    this.activeMetrics.set(id, metric);
    return id;
  }
  stop(id) {
    const metric = this.activeMetrics.get(id);
    if (!metric) {
      return null;
    }
    metric.endTime = Date.now();
    metric.duration = metric.endTime - metric.startTime;
    metric.memoryEnd = this.getMemoryUsage();
    metric.memoryDelta = metric.memoryEnd - (metric.memoryStart || 0);
    this.activeMetrics.delete(id);
    this.metrics.push(metric);
    return metric;
  }
  getMetrics() {
    return [...this.metrics];
  }
  getMetricsByOperation(operation) {
    return this.metrics.filter((metric) => metric.operation === operation);
  }
  getAverageDuration(operation) {
    const operationMetrics = this.getMetricsByOperation(operation);
    if (operationMetrics.length === 0) return 0;
    const total = operationMetrics.reduce((sum, metric) => sum + (metric.duration || 0), 0);
    return total / operationMetrics.length;
  }
  clear() {
    this.metrics = [];
    this.activeMetrics.clear();
  }
  printSummary() {
    process.stdout.write(`
\uD83D\uDCCA Performance Summary:
`);
    const operations = [...new Set(this.metrics.map((m) => m.operation))];
    for (const operation of operations) {
      const operationMetrics = this.getMetricsByOperation(operation);
      const avgDuration = this.getAverageDuration(operation);
      const totalDuration = operationMetrics.reduce((sum, m) => sum + (m.duration || 0), 0);
      const avgMemory =
        operationMetrics.reduce((sum, m) => sum + (m.memoryDelta || 0), 0) /
        operationMetrics.length;
      process.stdout.write(`  ${operation}:
`);
      process.stdout.write(`    Operations: ${operationMetrics.length}
`);
      process.stdout.write(`    Avg Duration: ${avgDuration.toFixed(0)}ms
`);
      process.stdout.write(`    Total Duration: ${totalDuration.toFixed(0)}ms
`);
      process.stdout
        .write(`    Avg Memory: ${(avgMemory / BYTES_PER_KB2 / BYTES_PER_KB2).toFixed(1)}MB
`);
    }
  }
  getMemoryUsage() {
    if (typeof process !== 'undefined' && process.memoryUsage) {
      return process.memoryUsage().heapUsed;
    }
    return 0;
  }
}

class AsyncQueue {
  queue = [];
  running = false;
  concurrency;
  activeCount = 0;
  constructor(concurrency = 4) {
    this.concurrency = concurrency;
  }
  async add(operation) {
    return new Promise((resolve11, reject) => {
      this.queue.push(async () => {
        try {
          const result = await operation();
          resolve11(result);
        } catch (error) {
          reject(error);
        }
      });
      this.process();
    });
  }
  async process() {
    if (this.running || this.activeCount >= this.concurrency) {
      return;
    }
    this.running = true;
    while (this.queue.length > 0 && this.activeCount < this.concurrency) {
      const operation = this.queue.shift();
      if (operation) {
        this.activeCount++;
        operation().finally(() => {
          this.activeCount--;
          this.process();
        });
      }
    }
    this.running = false;
  }
  async drain() {
    while (this.queue.length > 0 || this.activeCount > 0) {
      await new Promise((resolve11) => setTimeout(resolve11, DEFAULT_QUEUE_DELAY));
    }
  }
  status() {
    return {
      queue: this.queue.length,
      active: this.activeCount,
      concurrency: this.concurrency,
    };
  }
}
var RANDOM_BYTES_LENGTH = 8,
  DEFAULT_QUEUE_DELAY = 10,
  SECOND_IN_MS = 1000,
  SECONDS_PER_MINUTE2 = 60,
  MINUTE_IN_MS2,
  BYTES_PER_KB2 = 1024,
  PerformanceUtils;
var init_performance_core = __esm(() => {
  MINUTE_IN_MS2 = SECONDS_PER_MINUTE2 * SECOND_IN_MS;
  PerformanceUtils = {
    debounce: (func, wait) => {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => func(...args), wait);
      };
    },
    throttle: (func, limit) => {
      let inThrottle;
      return (...args) => {
        if (!inThrottle) {
          func(...args);
          inThrottle = true;
          setTimeout(() => (inThrottle = false), limit);
        }
      };
    },
    formatDuration: (durationMs) => {
      if (durationMs < SECOND_IN_MS) {
        return `${durationMs}ms`;
      } else if (durationMs < MINUTE_IN_MS2) {
        return `${(durationMs / SECOND_IN_MS).toFixed(1)}s`;
      }
      return `${(durationMs / MINUTE_IN_MS2).toFixed(1)}m`;
    },
  };
});

// ../../packages/adapters/src/utils/performance.ts
var Performance, defaultMemoryCache, defaultFileSystemCache, defaultMonitor;
var init_performance = __esm(() => {
  init_cache_implementations();
  init_memoization();
  init_performance_core();
  Performance = {
    memoryCache: (options) => {
      return new MemoryCache(options);
    },
    fileSystemCache: (options) => {
      return new FileSystemCache(options);
    },
    monitor: () => {
      return new PerformanceMonitor();
    },
    queue: (concurrency) => {
      return new AsyncQueue(concurrency);
    },
    debounce: PerformanceUtils.debounce,
    throttle: PerformanceUtils.throttle,
    memoize: createMemoizedFunction,
    formatDuration: PerformanceUtils.formatDuration,
  };
  defaultMemoryCache = Performance.memoryCache();
  defaultFileSystemCache = Performance.fileSystemCache();
  defaultMonitor = Performance.monitor();
});

// ../../packages/adapters/src/commands/config-validator.ts
var init_config_validator = __esm(() => {
  init_constants_new();
  init_constants();
});

// ../../packages/adapters/src/commands/project-generation-orchestrator-helpers.ts
var init_project_generation_orchestrator_helpers = () => {};

// ../../packages/adapters/src/commands/config-constants.ts
var COVERAGE_THRESHOLDS2, FORMATTING_CONSTANTS;
var init_config_constants = __esm(() => {
  init_constants();
  COVERAGE_THRESHOLDS2 = {
    LIGHT: COVERAGE_LEVELS.LIGHT_THRESHOLD,
    MEDIUM: COVERAGE_LEVELS.MEDIUM_THRESHOLD,
    STRICT: COVERAGE_LEVELS.STRICT_THRESHOLD,
  };
  FORMATTING_CONSTANTS = {
    INDENT_SIZE: FORMATTING.JSON_INDENT_SIZE,
    MAX_LINE_LENGTH: TEXT_LIMITS.MAX_LINE_LENGTH,
    TAB_SIZE: FORMATTING.TAB_WIDTH,
  };
});
// ../../packages/adapters/src/commands/config-generators/core-config-generators.ts
var init_core_config_generators = __esm(() => {
  init_config_constants();
});

// ../../packages/adapters/src/commands/config-generators/testing-config-generators.ts
var init_testing_config_generators = __esm(() => {
  init_constants();
  init_config_constants();
});
// ../../packages/adapters/src/commands/config-generators/index.ts
var init_config_generators2 = __esm(() => {
  init_core_config_generators();
  init_testing_config_generators();
});

// ../../packages/adapters/src/commands/config-generators.ts
var init_config_generators3 = __esm(() => {
  init_config_generators2();
});
// ../../packages/adapters/src/commands/project-setup.ts
var init_project_setup = __esm(() => {
  init_constants();
  init_config_generators3();
});

// ../../packages/adapters/src/commands/project-generation-orchestrator.ts
var init_project_generation_orchestrator = __esm(() => {
  init_constants();
  init_progress();
  init_config_validator();
  init_project_generation_orchestrator_helpers();
  init_project_setup();
});

// ../../packages/adapters/src/commands/enhanced-init.ts
var init_enhanced_init = __esm(() => {
  init_cli_helpers();
  init_constants();
  init_help_system();
  init_performance();
  init_progress();
  init_project_generation_orchestrator();
});

// ../../packages/adapters/src/index.ts
var init_src2 = __esm(() => {
  init_project_utilities();
  init_yaml_config_repository();
  init_project_wizard();
  init_template_engine();
  init_project_generator();
  init_eslint_generator();
  init_typescript_generator();
  init_prettier_generator();
  init_vitest_generator();
  init_claude_md_generator();
  init_copilot_generator();
  init_ai_context_generator();
  init_init();
  init_enhanced_init();
  init_progress();
  init_cli_helpers();
  init_help_system();
  init_performance();
});

// src/commands/init-handlers.ts
function displayConfigurationSummary(finalConfig, output) {
  output.success(import_picocolors3.default.green('\u2705 Project configuration complete!'));
  output.info(
    import_picocolors3.default.cyan(`
\uD83D\uDCCB Project Details:`)
  );
  output.info(import_picocolors3.default.white(`  Name:        ${finalConfig.name}`));
  if (finalConfig.description) {
    output.info(import_picocolors3.default.white(`  Description: ${finalConfig.description}`));
  }
  output.info(import_picocolors3.default.white(`  Type:        ${finalConfig.projectType}`));
  output.info(import_picocolors3.default.white(`  Quality:     ${finalConfig.qualityLevel}`));
  output.info(
    import_picocolors3.default.white(`  AI Assistants: ${finalConfig.aiAssistants.join(', ')}`)
  );
  output.info(
    import_picocolors3.default.white(`  Directory:   ${getProjectDirectory(finalConfig)}`)
  );
  if (finalConfig.author) {
    output.info(import_picocolors3.default.white(`  Author:      ${finalConfig.author}`));
  }
  if (finalConfig.license) {
    output.info(import_picocolors3.default.white(`  License:     ${finalConfig.license}`));
  }
}
async function generateProject(finalConfig, output) {
  output.info(
    import_picocolors3.default.cyan(`
\uD83D\uDE80 Generating project...`)
  );
  try {
    const result = await executeProjectGeneration(finalConfig);
    handleGenerationResult(result, output);
    displaySuccessMessage(finalConfig, output);
  } catch (genError) {
    handleGenerationError(genError, output);
  }
}
async function generateProjectFromTemplate(finalConfig) {
  const projectGenerator = new ProjectGenerator();
  const result = await projectGenerator.generateProject(finalConfig);
  return {
    success: result.success,
    errors: result.errors,
    warnings: result.warnings,
  };
}
async function generateProjectFromDirectoryStructure(finalConfig) {
  const directoryGenerator = new DirectoryStructureGenerator();
  const structure = directoryGenerator.generate(finalConfig);
  const projectDir = getProjectDirectory(finalConfig);
  await directoryGenerator.createStructureFromDirectoryItems(projectDir, structure);
  return {
    success: true,
    errors: [],
    warnings: [],
  };
}
async function executeProjectGeneration(finalConfig) {
  try {
    if (finalConfig.template) {
      return await generateProjectFromTemplate(finalConfig);
    }
    return await generateProjectFromDirectoryStructure(finalConfig);
  } catch (error) {
    return {
      success: false,
      errors: [
        `Failed to generate project: ${error instanceof Error ? error.message : 'Unknown error'}`,
      ],
      warnings: [],
    };
  }
}
function handleGenerationResult(result, output) {
  if (!result.success) {
    output.error(import_picocolors3.default.red(ERROR_MESSAGES3.PROJECT_GENERATION_FAILED));
    for (const error of result.errors) {
      output.error(import_picocolors3.default.red(`   \u2022 ${error}`));
    }
    process.exit(1);
  }
  if (result.warnings.length > 0) {
    output.info(import_picocolors3.default.yellow(WARNING_PREFIX));
    for (const warning of result.warnings) {
      output.info(import_picocolors3.default.yellow(`   \u2022 ${warning}`));
    }
  }
}
function displaySuccessMessage(finalConfig, output) {
  output.success(
    import_picocolors3.default.green(`
\u2705 Project generated successfully!`)
  );
  output.info(
    import_picocolors3.default.cyan(`
\uD83D\uDCDD Next Steps:`)
  );
  output.info(import_picocolors3.default.white(`  cd ${finalConfig.name}`));
  output.info(import_picocolors3.default.white('  bun install'));
  output.info(import_picocolors3.default.white('  bun run dev'));
}
function handleGenerationError(genError, output) {
  const errorMessage = genError instanceof Error ? genError.message : 'Unknown generation error';
  output.error(
    import_picocolors3.default.red(`${ERROR_MESSAGES3.GENERATION_ERROR} ${errorMessage}`)
  );
  process.exit(1);
}
var import_picocolors3,
  ERROR_MESSAGES3,
  WARNING_PREFIX = `
\u26A0\uFE0F  Warnings:`;
var init_init_handlers = __esm(() => {
  init_src2();
  init_src();
  import_picocolors3 = __toESM(require_picocolors(), 1);
  ERROR_MESSAGES3 = {
    CONFIG_NOT_FOUND: '\u274C Configuration file not found:',
    CONFIG_LOAD_FAILED: '\u274C Failed to load configuration file:',
    PROJECT_GENERATION_FAILED: '\u274C Project generation failed:',
    GENERATION_ERROR: '\u274C Failed to generate project:',
    VALIDATION_FAILED: '\u274C Configuration validation failed',
  };
});

// src/commands/init.ts
var exports_init = {};
__export(exports_init, {
  initCommand: () => initCommand,
});
function initializeDependencies() {
  return {
    output: instance.resolve('OutputWriter'),
    wizard: new ProjectWizardImplementation(),
    processor: new ProjectConfigProcessorImpl(),
  };
}
async function buildConfiguration(argv, deps) {
  let config2 = await loadConfigurationFile(argv.config, deps.output);
  config2 = await handleNonInteractiveMode(argv, config2, deps.output);
  config2 = setProjectNameFromArgs(config2, argv.projectName);
  return argv.nonInteractive
    ? runNonInteractive(config2, deps.wizard, deps.output)
    : deps.wizard.run(config2);
}
function buildCommandOptions(yargs) {
  return addBasicOptions(addPositionalArgument(yargs));
}
function addPositionalArgument(yargs) {
  return yargs['positional']('project-name', {
    type: 'string',
    description: 'Name of the project to create',
  });
}
function addProjectOptions(yargs) {
  return yargs
    .option('config', {
      type: 'string',
      description: 'Path to custom configuration file',
      alias: 'c',
    })
    .option('template', {
      type: 'string',
      description: 'Project template to use (basic, web, cli, library)',
      choices: ['basic', 'web', 'cli', 'library'],
    })
    .option('quality', {
      type: 'string',
      description: 'Quality level (light, medium, strict)',
      choices: ['light', 'medium', 'strict'],
    })
    .option('ai', {
      type: 'string',
      description: 'AI assistants to configure (comma-separated)',
    });
}
function addMetadataOptions(yargs) {
  return yargs
    .option('description', {
      type: 'string',
      description: 'Project description',
      alias: 'd',
    })
    .option('author', {
      type: 'string',
      description: 'Project author',
      alias: 'a',
    })
    .option('list-templates', {
      type: 'boolean',
      description: 'List available project templates',
    })
    .option('nonInteractive', {
      type: 'boolean',
      description: 'Run in non-interactive mode with defaults',
      alias: ['no-interactive'],
    });
}
function addBasicOptions(yargs) {
  const withProjectOptions = addProjectOptions(yargs);
  return addMetadataOptions(withProjectOptions);
}
var initCommand;
var init_init2 = __esm(() => {
  init_project_wizard();
  init_src();
  init_esm5();
  init_init_config();
  init_init_handlers();
  initCommand = {
    command: 'init [project-name]',
    describe: 'Initialize a new TypeScript project with opinionated scaffolding',
    builder: (yargs) => buildCommandOptions(yargs),
    handler: async (argv) => {
      const deps = initializeDependencies();
      try {
        if (argv.listTemplates) {
          const { ProjectGenerator: ProjectGenerator2 } = await Promise.resolve().then(
            () => (init_project_generator(), exports_project_generator)
          );
          const generator = new ProjectGenerator2();
          const templates = generator.getAvailableTemplates();
          deps.output.info(`
Available templates:`);
          for (const template of templates) {
            deps.output.info(`  - ${template}`);
          }
          process.exit(0);
        }
        const config2 = await buildConfiguration(argv, deps);
        const finalConfig = await processConfiguration(config2, deps);
        displayConfigurationSummary(finalConfig, deps.output);
        await generateProject(finalConfig, deps.output);
      } catch (error) {
        handleError(error, deps.output);
      }
    },
  };
});

// src/commands/validate.ts
var exports_validate = {};
__export(exports_validate, {
  validateCommand: () => validateCommand,
});
var import_picocolors4, validateCommand;
var init_validate = __esm(() => {
  init_esm5();
  import_picocolors4 = __toESM(require_picocolors(), 1);
  validateCommand = {
    command: 'validate',
    describe: 'Validate TypeScript project for quality issues',
    builder: (yargs) => {
      return yargs
        .option('config', {
          type: 'string',
          description: 'Path to custom configuration file',
          alias: 'c',
        })
        .option('fix', {
          type: 'boolean',
          description: 'Automatically fix detected issues',
          default: false,
        });
    },
    handler: (argv) => {
      const output = instance.resolve('OutputWriter');
      output.log(import_picocolors4.default.yellow('validate command: Not implemented yet'));
      output.log(
        import_picocolors4.default.dim('This command will be implemented in Epic 2 stories')
      );
      if (argv.config) {
        output.log(import_picocolors4.default.dim(`Config file: ${argv.config}`));
      }
      if (argv.fix) {
        output.log(import_picocolors4.default.dim('Fix mode enabled'));
      }
      process.exit(0);
    },
  };
});

// src/commands/fix.ts
var exports_fix = {};
__export(exports_fix, {
  fixCommand: () => fixCommand,
});
var import_picocolors5, fixCommand;
var init_fix = __esm(() => {
  init_esm5();
  import_picocolors5 = __toESM(require_picocolors(), 1);
  fixCommand = {
    command: 'fix',
    describe: 'Automatically fix quality issues in TypeScript project',
    builder: (yargs) => {
      return yargs
        .option('config', {
          type: 'string',
          description: 'Path to custom configuration file',
          alias: 'c',
        })
        .option('interactive', {
          type: 'boolean',
          description: 'Prompt before applying each fix',
          alias: 'i',
          default: false,
        });
    },
    handler: (argv) => {
      const output = instance.resolve('OutputWriter');
      output.log(import_picocolors5.default.yellow('fix command: Not implemented yet'));
      output.log(
        import_picocolors5.default.dim('This command will be implemented in Epic 3 stories')
      );
      if (argv.config) {
        output.log(import_picocolors5.default.dim(`Config file: ${argv.config}`));
      }
      if (argv.interactive) {
        output.log(import_picocolors5.default.dim('Interactive mode enabled'));
      }
      process.exit(0);
    },
  };
});

// src/commands/prompt.ts
var exports_prompt = {};
__export(exports_prompt, {
  promptCommand: () => promptCommand,
});
var import_picocolors6, promptCommand;
var init_prompt = __esm(() => {
  init_esm5();
  import_picocolors6 = __toESM(require_picocolors(), 1);
  promptCommand = {
    command: 'prompt',
    describe: 'Generate AI assistant prompt files (CLAUDE.md, etc.)',
    builder: (yargs) => {
      return yargs
        .option('config', {
          type: 'string',
          description: 'Path to custom configuration file',
          alias: 'c',
        })
        .option('output', {
          type: 'string',
          description: 'Output directory for generated prompt files',
          alias: 'o',
        });
    },
    handler: (argv) => {
      const output = instance.resolve('OutputWriter');
      output.log(import_picocolors6.default.yellow('prompt command: Not implemented yet'));
      output.log(
        import_picocolors6.default.dim(
          'This command will be implemented in Story 1.9: AI Rules Library'
        )
      );
      if (argv.config) {
        output.log(import_picocolors6.default.dim(`Config file: ${argv.config}`));
      }
      if (argv.output) {
        output.log(import_picocolors6.default.dim(`Output directory: ${argv.output}`));
      }
      process.exit(0);
    },
  };
});

// src/index.ts
init_esm5();
var import_reflect_metadata2 = __toESM(require_Reflect(), 1);

// src/app.ts
init_esm5();
var import_picocolors7 = __toESM(require_picocolors(), 1);

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/yerror.js
class YError extends Error {
  constructor(msg) {
    super(msg || 'yargs error');
    this.name = 'YError';
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, YError);
    }
  }
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/apply-extends.js
var previouslyVisitedConfigs = [];
var shim;
function applyExtends(config, cwd, mergeExtends, _shim) {
  shim = _shim;
  let defaultConfig = {};
  if (Object.prototype.hasOwnProperty.call(config, 'extends')) {
    if (typeof config.extends !== 'string') return defaultConfig;
    const isPath = /\.json|\..*rc$/.test(config.extends);
    let pathToDefault = null;
    if (!isPath) {
      try {
        pathToDefault = __require.resolve(config.extends);
      } catch (_err) {
        return config;
      }
    } else {
      pathToDefault = getPathToDefaultConfig(cwd, config.extends);
    }
    checkForCircularExtends(pathToDefault);
    previouslyVisitedConfigs.push(pathToDefault);
    defaultConfig = isPath
      ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8'))
      : __require(config.extends);
    delete config.extends;
    defaultConfig = applyExtends(
      defaultConfig,
      shim.path.dirname(pathToDefault),
      mergeExtends,
      shim
    );
  }
  previouslyVisitedConfigs = [];
  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
    throw new YError(`Circular extended configurations: '${cfgPath}'.`);
  }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
  return shim.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
  const target = {};
  function isObject(obj) {
    return obj && typeof obj === 'object' && !Array.isArray(obj);
  }
  Object.assign(target, config1);
  for (const key of Object.keys(config2)) {
    if (isObject(config2[key]) && isObject(target[key])) {
      target[key] = mergeDeep(config1[key], config2[key]);
    } else {
      target[key] = config2[key];
    }
  }
  return target;
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/process-argv.js
function getProcessArgvBinIndex() {
  if (isBundledElectronApp()) return 0;
  return 1;
}
function isBundledElectronApp() {
  return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
  return !!process.versions.electron;
}
function hideBin(argv) {
  return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}

// ../../node_modules/.bun/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/index.js
import { format } from 'util';
import { normalize, resolve } from 'path';

// ../../node_modules/.bun/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
    return str;
  } else {
    let camelcase = '';
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
      let chr = str.charAt(i);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i !== 0 && (chr === '-' || chr === '_')) {
        nextChrUpper = true;
      } else if (chr !== '-' && chr !== '_') {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || '-';
  let notCamelcase = '';
  for (let i = 0; i < str.length; i++) {
    const chrLower = lowercase.charAt(i);
    const chrString = str.charAt(i);
    if (chrLower !== chrString && i > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === undefined) return false;
  if (typeof x === 'number') return true;
  if (/^0x[0-9a-f]+$/i.test(x)) return true;
  if (/^0[^.]/.test(x)) return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

// ../../node_modules/.bun/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => (typeof e !== 'string' ? e + '' : e));
  }
  argString = argString.trim();
  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];
  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === ' ' && !opening) {
      if (!(prevC === ' ')) {
        i++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args[i]) args[i] = '';
    args[i] += c;
  }
  return args;
}

// ../../node_modules/.bun/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
(function (DefaultValuesForTypeKey2) {
  DefaultValuesForTypeKey2['BOOLEAN'] = 'boolean';
  DefaultValuesForTypeKey2['STRING'] = 'string';
  DefaultValuesForTypeKey2['NUMBER'] = 'number';
  DefaultValuesForTypeKey2['ARRAY'] = 'array';
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

// ../../node_modules/.bun/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/yargs-parser.js
var mixin;

class YargsParser {
  constructor(_mixin) {
    mixin = _mixin;
  }
  parse(argsInput, options) {
    const opts = Object.assign(
      {
        alias: undefined,
        array: undefined,
        boolean: undefined,
        config: undefined,
        configObjects: undefined,
        configuration: undefined,
        coerce: undefined,
        count: undefined,
        default: undefined,
        envPrefix: undefined,
        narg: undefined,
        normalize: undefined,
        string: undefined,
        number: undefined,
        __: undefined,
        key: undefined,
      },
      options
    );
    const args = tokenizeArgString(argsInput);
    const inputIsString = typeof argsInput === 'string';
    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
    const configuration = Object.assign(
      {
        'boolean-negation': true,
        'camel-case-expansion': true,
        'combine-arrays': false,
        'dot-notation': true,
        'duplicate-arguments-array': true,
        'flatten-duplicate-arrays': true,
        'greedy-arrays': true,
        'halt-at-non-option': false,
        'nargs-eats-options': false,
        'negation-prefix': 'no-',
        'parse-numbers': true,
        'parse-positional-numbers': true,
        'populate--': false,
        'set-placeholder-key': false,
        'short-option-groups': true,
        'strip-aliased': false,
        'strip-dashed': false,
        'unknown-options-as-args': false,
      },
      opts.configuration
    );
    const defaults = Object.assign(Object.create(null), opts.default);
    const configObjects = opts.configObjects || [];
    const envPrefix = opts.envPrefix;
    const notFlagsOption = configuration['populate--'];
    const notFlagsArgv = notFlagsOption ? '--' : '_';
    const newAliases = Object.create(null);
    const defaulted = Object.create(null);
    const __ = opts.__ || mixin.format;
    const flags = {
      aliases: Object.create(null),
      arrays: Object.create(null),
      bools: Object.create(null),
      strings: Object.create(null),
      numbers: Object.create(null),
      counts: Object.create(null),
      normalize: Object.create(null),
      configs: Object.create(null),
      nargs: Object.create(null),
      coercions: Object.create(null),
      keys: [],
    };
    const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
    const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
    []
      .concat(opts.array || [])
      .filter(Boolean)
      .forEach(function (opt) {
        const key = typeof opt === 'object' ? opt.key : opt;
        const assignment = Object.keys(opt)
          .map(function (key2) {
            const arrayFlagKeys = {
              boolean: 'bools',
              string: 'strings',
              number: 'numbers',
            };
            return arrayFlagKeys[key2];
          })
          .filter(Boolean)
          .pop();
        if (assignment) {
          flags[assignment][key] = true;
        }
        flags.arrays[key] = true;
        flags.keys.push(key);
      });
    []
      .concat(opts.boolean || [])
      .filter(Boolean)
      .forEach(function (key) {
        flags.bools[key] = true;
        flags.keys.push(key);
      });
    []
      .concat(opts.string || [])
      .filter(Boolean)
      .forEach(function (key) {
        flags.strings[key] = true;
        flags.keys.push(key);
      });
    []
      .concat(opts.number || [])
      .filter(Boolean)
      .forEach(function (key) {
        flags.numbers[key] = true;
        flags.keys.push(key);
      });
    []
      .concat(opts.count || [])
      .filter(Boolean)
      .forEach(function (key) {
        flags.counts[key] = true;
        flags.keys.push(key);
      });
    []
      .concat(opts.normalize || [])
      .filter(Boolean)
      .forEach(function (key) {
        flags.normalize[key] = true;
        flags.keys.push(key);
      });
    if (typeof opts.narg === 'object') {
      Object.entries(opts.narg).forEach(([key, value]) => {
        if (typeof value === 'number') {
          flags.nargs[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.coerce === 'object') {
      Object.entries(opts.coerce).forEach(([key, value]) => {
        if (typeof value === 'function') {
          flags.coercions[key] = value;
          flags.keys.push(key);
        }
      });
    }
    if (typeof opts.config !== 'undefined') {
      if (Array.isArray(opts.config) || typeof opts.config === 'string') {
        []
          .concat(opts.config)
          .filter(Boolean)
          .forEach(function (key) {
            flags.configs[key] = true;
          });
      } else if (typeof opts.config === 'object') {
        Object.entries(opts.config).forEach(([key, value]) => {
          if (typeof value === 'boolean' || typeof value === 'function') {
            flags.configs[key] = value;
          }
        });
      }
    }
    extendAliases(opts.key, aliases, opts.default, flags.arrays);
    Object.keys(defaults).forEach(function (key) {
      (flags.aliases[key] || []).forEach(function (alias) {
        defaults[alias] = defaults[key];
      });
    });
    let error = null;
    checkConfiguration();
    let notFlags = [];
    const argv = Object.assign(Object.create(null), { _: [] });
    const argvReturn = {};
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      const truncatedArg = arg.replace(/^-{3,}/, '---');
      let broken;
      let key;
      let letters;
      let m;
      let next;
      let value;
      if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
        pushPositional(arg);
      } else if (truncatedArg.match(/^---+(=|$)/)) {
        pushPositional(arg);
        continue;
      } else if (
        arg.match(/^--.+=/) ||
        (!configuration['short-option-groups'] && arg.match(/^-.+=/))
      ) {
        m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          if (checkAllAliases(m[1], flags.arrays)) {
            i = eatArray(i, m[1], args, m[2]);
          } else if (checkAllAliases(m[1], flags.nargs) !== false) {
            i = eatNargs(i, m[1], args, m[2]);
          } else {
            setArg(m[1], m[2], true);
          }
        }
      } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
        m = arg.match(negatedBoolean);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        }
      } else if (
        arg.match(/^--.+/) ||
        (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))
      ) {
        m = arg.match(/^--?(.+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (
              next !== undefined &&
              (!next.match(/^-/) || next.match(negative)) &&
              !checkAllAliases(key, flags.bools) &&
              !checkAllAliases(key, flags.counts)
            ) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (arg.match(/^-.\..+=/)) {
        m = arg.match(/^-([^=]+)=([\s\S]*)$/);
        if (m !== null && Array.isArray(m) && m.length >= 3) {
          setArg(m[1], m[2]);
        }
      } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
        next = args[i + 1];
        m = arg.match(/^-(.\..+)/);
        if (m !== null && Array.isArray(m) && m.length >= 2) {
          key = m[1];
          if (
            next !== undefined &&
            !next.match(/^-/) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)
          ) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        }
      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
        letters = arg.slice(1, -1).split('');
        broken = false;
        for (let j = 0; j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (letters[j + 1] && letters[j + 1] === '=') {
            value = arg.slice(j + 3);
            key = letters[j];
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args, value);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args, value);
            } else {
              setArg(key, value);
            }
            broken = true;
            break;
          }
          if (next === '-') {
            setArg(letters[j], next);
            continue;
          }
          if (
            /[A-Za-z]/.test(letters[j]) &&
            /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &&
            checkAllAliases(next, flags.bools) === false
          ) {
            setArg(letters[j], next);
            broken = true;
            break;
          }
          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], next);
            broken = true;
            break;
          } else {
            setArg(letters[j], defaultValue(letters[j]));
          }
        }
        key = arg.slice(-1)[0];
        if (!broken && key !== '-') {
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args);
          } else {
            next = args[i + 1];
            if (
              next !== undefined &&
              (!/^(-|--)[^-]/.test(next) || next.match(negative)) &&
              !checkAllAliases(key, flags.bools) &&
              !checkAllAliases(key, flags.counts)
            ) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        }
      } else if (
        arg.match(/^-[0-9]$/) &&
        arg.match(negative) &&
        checkAllAliases(arg.slice(1), flags.bools)
      ) {
        key = arg.slice(1);
        setArg(key, defaultValue(key));
      } else if (arg === '--') {
        notFlags = args.slice(i + 1);
        break;
      } else if (configuration['halt-at-non-option']) {
        notFlags = args.slice(i);
        break;
      } else {
        pushPositional(arg);
      }
    }
    applyEnvVars(argv, true);
    applyEnvVars(argv, false);
    setConfig(argv);
    setConfigObjects();
    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
    applyCoercions(argv);
    if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);
    Object.keys(flags.counts).forEach(function (key) {
      if (!hasKey(argv, key.split('.'))) setArg(key, 0);
    });
    if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];
    notFlags.forEach(function (key) {
      argv[notFlagsArgv].push(key);
    });
    if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
      Object.keys(argv)
        .filter((key) => key !== '--' && key.includes('-'))
        .forEach((key) => {
          delete argv[key];
        });
    }
    if (configuration['strip-aliased']) {
      [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
        if (configuration['camel-case-expansion'] && alias.includes('-')) {
          delete argv[
            alias
              .split('.')
              .map((prop) => camelCase(prop))
              .join('.')
          ];
        }
        delete argv[alias];
      });
    }
    function pushPositional(arg) {
      const maybeCoercedNumber = maybeCoerceNumber('_', arg);
      if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
        argv._.push(maybeCoercedNumber);
      }
    }
    function eatNargs(i, key, args2, argAfterEqualSign) {
      let ii;
      let toEat = checkAllAliases(key, flags.nargs);
      toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
      if (toEat === 0) {
        if (!isUndefined(argAfterEqualSign)) {
          error = Error(__('Argument unexpected for: %s', key));
        }
        setArg(key, defaultValue(key));
        return i;
      }
      let available = isUndefined(argAfterEqualSign) ? 0 : 1;
      if (configuration['nargs-eats-options']) {
        if (args2.length - (i + 1) + available < toEat) {
          error = Error(__('Not enough arguments following: %s', key));
        }
        available = toEat;
      } else {
        for (ii = i + 1; ii < args2.length; ii++) {
          if (
            !args2[ii].match(/^-[^0-9]/) ||
            args2[ii].match(negative) ||
            isUnknownOptionAsArg(args2[ii])
          )
            available++;
          else break;
        }
        if (available < toEat) error = Error(__('Not enough arguments following: %s', key));
      }
      let consumed = Math.min(available, toEat);
      if (!isUndefined(argAfterEqualSign) && consumed > 0) {
        setArg(key, argAfterEqualSign);
        consumed--;
      }
      for (ii = i + 1; ii < consumed + i + 1; ii++) {
        setArg(key, args2[ii]);
      }
      return i + consumed;
    }
    function eatArray(i, key, args2, argAfterEqualSign) {
      let argsToSet = [];
      let next = argAfterEqualSign || args2[i + 1];
      const nargsCount = checkAllAliases(key, flags.nargs);
      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
        argsToSet.push(true);
      } else if (
        isUndefined(next) ||
        (isUndefined(argAfterEqualSign) &&
          /^-/.test(next) &&
          !negative.test(next) &&
          !isUnknownOptionAsArg(next))
      ) {
        if (defaults[key] !== undefined) {
          const defVal = defaults[key];
          argsToSet = Array.isArray(defVal) ? defVal : [defVal];
        }
      } else {
        if (!isUndefined(argAfterEqualSign)) {
          argsToSet.push(processValue(key, argAfterEqualSign, true));
        }
        for (let ii = i + 1; ii < args2.length; ii++) {
          if (
            (!configuration['greedy-arrays'] && argsToSet.length > 0) ||
            (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount)
          )
            break;
          next = args2[ii];
          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
          i = ii;
          argsToSet.push(processValue(key, next, inputIsString));
        }
      }
      if (
        typeof nargsCount === 'number' &&
        ((nargsCount && argsToSet.length < nargsCount) ||
          (isNaN(nargsCount) && argsToSet.length === 0))
      ) {
        error = Error(__('Not enough arguments following: %s', key));
      }
      setArg(key, argsToSet);
      return i;
    }
    function setArg(key, val, shouldStripQuotes = inputIsString) {
      if (/-/.test(key) && configuration['camel-case-expansion']) {
        const alias = key
          .split('.')
          .map(function (prop) {
            return camelCase(prop);
          })
          .join('.');
        addNewAlias(key, alias);
      }
      const value = processValue(key, val, shouldStripQuotes);
      const splitKey = key.split('.');
      setKey(argv, splitKey, value);
      if (flags.aliases[key]) {
        flags.aliases[key].forEach(function (x) {
          const keyProperties = x.split('.');
          setKey(argv, keyProperties, value);
        });
      }
      if (splitKey.length > 1 && configuration['dot-notation']) {
        (flags.aliases[splitKey[0]] || []).forEach(function (x) {
          let keyProperties = x.split('.');
          const a = [].concat(splitKey);
          a.shift();
          keyProperties = keyProperties.concat(a);
          if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
            setKey(argv, keyProperties, value);
          }
        });
      }
      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
        const keys = [key].concat(flags.aliases[key] || []);
        keys.forEach(function (key2) {
          Object.defineProperty(argvReturn, key2, {
            enumerable: true,
            get() {
              return val;
            },
            set(value2) {
              val = typeof value2 === 'string' ? mixin.normalize(value2) : value2;
            },
          });
        });
      }
    }
    function addNewAlias(key, alias) {
      if (!(flags.aliases[key] && flags.aliases[key].length)) {
        flags.aliases[key] = [alias];
        newAliases[alias] = true;
      }
      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
        addNewAlias(alias, key);
      }
    }
    function processValue(key, val, shouldStripQuotes) {
      if (shouldStripQuotes) {
        val = stripQuotes(val);
      }
      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
        if (typeof val === 'string') val = val === 'true';
      }
      let value = Array.isArray(val)
        ? val.map(function (v) {
            return maybeCoerceNumber(key, v);
          })
        : maybeCoerceNumber(key, val);
      if (
        checkAllAliases(key, flags.counts) &&
        (isUndefined(value) || typeof value === 'boolean')
      ) {
        value = increment();
      }
      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
        if (Array.isArray(val))
          value = val.map((val2) => {
            return mixin.normalize(val2);
          });
        else value = mixin.normalize(val);
      }
      return value;
    }
    function maybeCoerceNumber(key, value) {
      if (!configuration['parse-positional-numbers'] && key === '_') return value;
      if (
        !checkAllAliases(key, flags.strings) &&
        !checkAllAliases(key, flags.bools) &&
        !Array.isArray(value)
      ) {
        const shouldCoerceNumber =
          looksLikeNumber(value) &&
          configuration['parse-numbers'] &&
          Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));
        if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {
          value = Number(value);
        }
      }
      return value;
    }
    function setConfig(argv2) {
      const configLookup = Object.create(null);
      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
      Object.keys(flags.configs).forEach(function (configKey) {
        const configPath = argv2[configKey] || configLookup[configKey];
        if (configPath) {
          try {
            let config = null;
            const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
            const resolveConfig = flags.configs[configKey];
            if (typeof resolveConfig === 'function') {
              try {
                config = resolveConfig(resolvedConfigPath);
              } catch (e) {
                config = e;
              }
              if (config instanceof Error) {
                error = config;
                return;
              }
            } else {
              config = mixin.require(resolvedConfigPath);
            }
            setConfigObject(config);
          } catch (ex) {
            if (ex.name === 'PermissionDenied') error = ex;
            else if (argv2[configKey])
              error = Error(__('Invalid JSON config file: %s', configPath));
          }
        }
      });
    }
    function setConfigObject(config, prev) {
      Object.keys(config).forEach(function (key) {
        const value = config[key];
        const fullKey = prev ? prev + '.' + key : key;
        if (
          typeof value === 'object' &&
          value !== null &&
          !Array.isArray(value) &&
          configuration['dot-notation']
        ) {
          setConfigObject(value, fullKey);
        } else {
          if (
            !hasKey(argv, fullKey.split('.')) ||
            (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])
          ) {
            setArg(fullKey, value);
          }
        }
      });
    }
    function setConfigObjects() {
      if (typeof configObjects !== 'undefined') {
        configObjects.forEach(function (configObject) {
          setConfigObject(configObject);
        });
      }
    }
    function applyEnvVars(argv2, configOnly) {
      if (typeof envPrefix === 'undefined') return;
      const prefix = typeof envPrefix === 'string' ? envPrefix : '';
      const env = mixin.env();
      Object.keys(env).forEach(function (envVar) {
        if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
          const keys = envVar.split('__').map(function (key, i) {
            if (i === 0) {
              key = key.substring(prefix.length);
            }
            return camelCase(key);
          });
          if (
            ((configOnly && flags.configs[keys.join('.')]) || !configOnly) &&
            !hasKey(argv2, keys)
          ) {
            setArg(keys.join('.'), env[envVar]);
          }
        }
      });
    }
    function applyCoercions(argv2) {
      let coerce;
      const applied = new Set();
      Object.keys(argv2).forEach(function (key) {
        if (!applied.has(key)) {
          coerce = checkAllAliases(key, flags.coercions);
          if (typeof coerce === 'function') {
            try {
              const value = maybeCoerceNumber(key, coerce(argv2[key]));
              [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                applied.add(ali);
                argv2[ali] = value;
              });
            } catch (err) {
              error = err;
            }
          }
        }
      });
    }
    function setPlaceholderKeys(argv2) {
      flags.keys.forEach((key) => {
        if (~key.indexOf('.')) return;
        if (typeof argv2[key] === 'undefined') argv2[key] = undefined;
      });
      return argv2;
    }
    function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
      Object.keys(defaults2).forEach(function (key) {
        if (!hasKey(obj, key.split('.'))) {
          setKey(obj, key.split('.'), defaults2[key]);
          if (canLog) defaulted[key] = true;
          (aliases2[key] || []).forEach(function (x) {
            if (hasKey(obj, x.split('.'))) return;
            setKey(obj, x.split('.'), defaults2[key]);
          });
        }
      });
    }
    function hasKey(obj, keys) {
      let o = obj;
      if (!configuration['dot-notation']) keys = [keys.join('.')];
      keys.slice(0, -1).forEach(function (key2) {
        o = o[key2] || {};
      });
      const key = keys[keys.length - 1];
      if (typeof o !== 'object') return false;
      else return key in o;
    }
    function setKey(obj, keys, value) {
      let o = obj;
      if (!configuration['dot-notation']) keys = [keys.join('.')];
      keys.slice(0, -1).forEach(function (key2) {
        key2 = sanitizeKey(key2);
        if (typeof o === 'object' && o[key2] === undefined) {
          o[key2] = {};
        }
        if (typeof o[key2] !== 'object' || Array.isArray(o[key2])) {
          if (Array.isArray(o[key2])) {
            o[key2].push({});
          } else {
            o[key2] = [o[key2], {}];
          }
          o = o[key2][o[key2].length - 1];
        } else {
          o = o[key2];
        }
      });
      const key = sanitizeKey(keys[keys.length - 1]);
      const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
      const isValueArray = Array.isArray(value);
      let duplicate = configuration['duplicate-arguments-array'];
      if (!duplicate && checkAllAliases(key, flags.nargs)) {
        duplicate = true;
        if (
          (!isUndefined(o[key]) && flags.nargs[key] === 1) ||
          (Array.isArray(o[key]) && o[key].length === flags.nargs[key])
        ) {
          o[key] = undefined;
        }
      }
      if (value === increment()) {
        o[key] = increment(o[key]);
      } else if (Array.isArray(o[key])) {
        if (duplicate && isTypeArray && isValueArray) {
          o[key] = configuration['flatten-duplicate-arrays']
            ? o[key].concat(value)
            : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
          o[key] = value;
        } else {
          o[key] = o[key].concat([value]);
        }
      } else if (o[key] === undefined && isTypeArray) {
        o[key] = isValueArray ? value : [value];
      } else if (
        duplicate &&
        !(
          o[key] === undefined ||
          checkAllAliases(key, flags.counts) ||
          checkAllAliases(key, flags.bools)
        )
      ) {
        o[key] = [o[key], value];
      } else {
        o[key] = value;
      }
    }
    function extendAliases(...args2) {
      args2.forEach(function (obj) {
        Object.keys(obj || {}).forEach(function (key) {
          if (flags.aliases[key]) return;
          flags.aliases[key] = [].concat(aliases[key] || []);
          flags.aliases[key].concat(key).forEach(function (x) {
            if (/-/.test(x) && configuration['camel-case-expansion']) {
              const c = camelCase(x);
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].concat(key).forEach(function (x) {
            if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {
              const c = decamelize(x, '-');
              if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                flags.aliases[key].push(c);
                newAliases[c] = true;
              }
            }
          });
          flags.aliases[key].forEach(function (x) {
            flags.aliases[x] = [key].concat(
              flags.aliases[key].filter(function (y) {
                return x !== y;
              })
            );
          });
        });
      });
    }
    function checkAllAliases(key, flag) {
      const toCheck = [].concat(flags.aliases[key] || [], key);
      const keys = Object.keys(flag);
      const setAlias = toCheck.find((key2) => keys.includes(key2));
      return setAlias ? flag[setAlias] : false;
    }
    function hasAnyFlag(key) {
      const flagsKeys = Object.keys(flags);
      const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
      return toCheck.some(function (flag) {
        return Array.isArray(flag) ? flag.includes(key) : flag[key];
      });
    }
    function hasFlagsMatching(arg, ...patterns) {
      const toCheck = [].concat(...patterns);
      return toCheck.some(function (pattern) {
        const match = arg.match(pattern);
        return match && hasAnyFlag(match[1]);
      });
    }
    function hasAllShortFlags(arg) {
      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
        return false;
      }
      let hasAllFlags = true;
      let next;
      const letters = arg.slice(1).split('');
      for (let j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2);
        if (!hasAnyFlag(letters[j])) {
          hasAllFlags = false;
          break;
        }
        if (
          (letters[j + 1] && letters[j + 1] === '=') ||
          next === '-' ||
          (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) ||
          (letters[j + 1] && letters[j + 1].match(/\W/))
        ) {
          break;
        }
      }
      return hasAllFlags;
    }
    function isUnknownOptionAsArg(arg) {
      return configuration['unknown-options-as-args'] && isUnknownOption(arg);
    }
    function isUnknownOption(arg) {
      arg = arg.replace(/^-{3,}/, '--');
      if (arg.match(negative)) {
        return false;
      }
      if (hasAllShortFlags(arg)) {
        return false;
      }
      const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
      const normalFlag = /^-+([^=]+?)$/;
      const flagEndingInHyphen = /^-+([^=]+?)-$/;
      const flagEndingInDigits = /^-+([^=]+?\d+)$/;
      const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
      return !hasFlagsMatching(
        arg,
        flagWithEquals,
        negatedBoolean,
        normalFlag,
        flagEndingInHyphen,
        flagEndingInDigits,
        flagEndingInNonWordCharacters
      );
    }
    function defaultValue(key) {
      if (
        !checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts) &&
        `${key}` in defaults
      ) {
        return defaults[key];
      } else {
        return defaultForType(guessType(key));
      }
    }
    function defaultForType(type) {
      const def = {
        [DefaultValuesForTypeKey.BOOLEAN]: true,
        [DefaultValuesForTypeKey.STRING]: '',
        [DefaultValuesForTypeKey.NUMBER]: undefined,
        [DefaultValuesForTypeKey.ARRAY]: [],
      };
      return def[type];
    }
    function guessType(key) {
      let type = DefaultValuesForTypeKey.BOOLEAN;
      if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;
      else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;
      else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;
      else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;
      return type;
    }
    function isUndefined(num) {
      return num === undefined;
    }
    function checkConfiguration() {
      Object.keys(flags.counts).find((key) => {
        if (checkAllAliases(key, flags.arrays)) {
          error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));
          return true;
        } else if (checkAllAliases(key, flags.nargs)) {
          error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));
          return true;
        }
        return false;
      });
    }
    return {
      aliases: Object.assign({}, flags.aliases),
      argv: Object.assign(argvReturn, argv),
      configuration,
      defaulted: Object.assign({}, defaulted),
      error,
      newAliases: Object.assign({}, newAliases),
    };
  }
}
function combineAliases(aliases) {
  const aliasArrays = [];
  const combined = Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function (key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i = 0; i < aliasArrays.length; i++) {
      for (let ii = i + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function (v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function (aliasArray) {
    aliasArray = aliasArray.filter(function (v, i, self2) {
      return self2.indexOf(v) === i;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== undefined && typeof lastAlias === 'string') {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}
function increment(orig) {
  return orig !== undefined ? orig + 1 : 1;
}
function sanitizeKey(key) {
  if (key === '__proto__') return '___proto___';
  return key;
}
function stripQuotes(val) {
  return typeof val === 'string' &&
    (val[0] === "'" || val[0] === '"') &&
    val[val.length - 1] === val[0]
    ? val.substring(1, val.length - 1)
    : val;
}

// ../../node_modules/.bun/yargs-parser@21.1.1/node_modules/yargs-parser/build/lib/index.js
var _a;
var _b;
var _c;
var minNodeVersion =
  process && process.env && process.env.YARGS_MIN_NODE_VERSION
    ? Number(process.env.YARGS_MIN_NODE_VERSION)
    : 12;
var nodeVersion =
  (_b =
    (_a = process === null || process === undefined ? undefined : process.versions) === null ||
    _a === undefined
      ? undefined
      : _a.node) !== null && _b !== undefined
    ? _b
    : (_c = process === null || process === undefined ? undefined : process.version) === null ||
        _c === undefined
      ? undefined
      : _c.slice(1);
if (nodeVersion) {
  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
  if (major < minNodeVersion) {
    throw Error(
      `yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`
    );
  }
}
var env = process ? process.env : {};
var parser = new YargsParser({
  cwd: process.cwd,
  env: () => {
    return env;
  },
  format,
  normalize,
  resolve,
  require: (path) => {
    if (true) {
      return __require(path);
    } else;
  },
});
var yargsParser = function Parser(args, opts) {
  const result = parser.parse(args.slice(), opts);
  return result.argv;
};
yargsParser.detailed = function (args, opts) {
  return parser.parse(args.slice(), opts);
};
yargsParser.camelCase = camelCase;
yargsParser.decamelize = decamelize;
yargsParser.looksLikeNumber = looksLikeNumber;
var lib_default = yargsParser;

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs
import { notStrictEqual, strictEqual } from 'assert';

// ../../node_modules/.bun/cliui@8.0.1/node_modules/cliui/build/lib/index.js
var align = {
  right: alignRight,
  center: alignCenter,
};
var top = 0;
var right = 1;
var bottom = 2;
var left = 3;

class UI {
  constructor(opts) {
    var _a2;
    this.width = opts.width;
    this.wrap = (_a2 = opts.wrap) !== null && _a2 !== undefined ? _a2 : true;
    this.rows = [];
  }
  span(...args) {
    const cols = this.div(...args);
    cols.span = true;
  }
  resetOutput() {
    this.rows = [];
  }
  div(...args) {
    if (args.length === 0) {
      this.div('');
    }
    if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
      return this.applyLayoutDSL(args[0]);
    }
    const cols = args.map((arg) => {
      if (typeof arg === 'string') {
        return this.colFromString(arg);
      }
      return arg;
    });
    this.rows.push(cols);
    return cols;
  }
  shouldApplyLayoutDSL(...args) {
    return args.length === 1 && typeof args[0] === 'string' && /[\t\n]/.test(args[0]);
  }
  applyLayoutDSL(str) {
    const rows = str
      .split(
        `
`
      )
      .map((row) => row.split('\t'));
    let leftColumnWidth = 0;
    rows.forEach((columns) => {
      if (columns.length > 1 && mixin2.stringWidth(columns[0]) > leftColumnWidth) {
        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin2.stringWidth(columns[0]));
      }
    });
    rows.forEach((columns) => {
      this.div(
        ...columns.map((r, i) => {
          return {
            text: r.trim(),
            padding: this.measurePadding(r),
            width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined,
          };
        })
      );
    });
    return this.rows[this.rows.length - 1];
  }
  colFromString(text) {
    return {
      text,
      padding: this.measurePadding(text),
    };
  }
  measurePadding(str) {
    const noAnsi = mixin2.stripAnsi(str);
    return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
  }
  toString() {
    const lines = [];
    this.rows.forEach((row) => {
      this.rowToString(row, lines);
    });
    return lines.filter((line) => !line.hidden).map((line) => line.text).join(`
`);
  }
  rowToString(row, lines) {
    this.rasterize(row).forEach((rrow, r) => {
      let str = '';
      rrow.forEach((col, c) => {
        const { width } = row[c];
        const wrapWidth = this.negatePadding(row[c]);
        let ts = col;
        if (wrapWidth > mixin2.stringWidth(col)) {
          ts += ' '.repeat(wrapWidth - mixin2.stringWidth(col));
        }
        if (row[c].align && row[c].align !== 'left' && this.wrap) {
          const fn = align[row[c].align];
          ts = fn(ts, wrapWidth);
          if (mixin2.stringWidth(ts) < wrapWidth) {
            ts += ' '.repeat((width || 0) - mixin2.stringWidth(ts) - 1);
          }
        }
        const padding = row[c].padding || [0, 0, 0, 0];
        if (padding[left]) {
          str += ' '.repeat(padding[left]);
        }
        str += addBorder(row[c], ts, '| ');
        str += ts;
        str += addBorder(row[c], ts, ' |');
        if (padding[right]) {
          str += ' '.repeat(padding[right]);
        }
        if (r === 0 && lines.length > 0) {
          str = this.renderInline(str, lines[lines.length - 1]);
        }
      });
      lines.push({
        text: str.replace(/ +$/, ''),
        span: row.span,
      });
    });
    return lines;
  }
  renderInline(source, previousLine) {
    const match = source.match(/^ */);
    const leadingWhitespace = match ? match[0].length : 0;
    const target = previousLine.text;
    const targetTextWidth = mixin2.stringWidth(target.trimRight());
    if (!previousLine.span) {
      return source;
    }
    if (!this.wrap) {
      previousLine.hidden = true;
      return target + source;
    }
    if (leadingWhitespace < targetTextWidth) {
      return source;
    }
    previousLine.hidden = true;
    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
  }
  rasterize(row) {
    const rrows = [];
    const widths = this.columnWidths(row);
    let wrapped;
    row.forEach((col, c) => {
      col.width = widths[c];
      if (this.wrap) {
        wrapped = mixin2.wrap(col.text, this.negatePadding(col), { hard: true }).split(`
`);
      } else {
        wrapped = col.text.split(`
`);
      }
      if (col.border) {
        wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
        wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
      }
      if (col.padding) {
        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
      }
      wrapped.forEach((str, r) => {
        if (!rrows[r]) {
          rrows.push([]);
        }
        const rrow = rrows[r];
        for (let i = 0; i < c; i++) {
          if (rrow[i] === undefined) {
            rrow.push('');
          }
        }
        rrow.push(str);
      });
    });
    return rrows;
  }
  negatePadding(col) {
    let wrapWidth = col.width || 0;
    if (col.padding) {
      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
    }
    if (col.border) {
      wrapWidth -= 4;
    }
    return wrapWidth;
  }
  columnWidths(row) {
    if (!this.wrap) {
      return row.map((col) => {
        return col.width || mixin2.stringWidth(col.text);
      });
    }
    let unset = row.length;
    let remainingWidth = this.width;
    const widths = row.map((col) => {
      if (col.width) {
        unset--;
        remainingWidth -= col.width;
        return col.width;
      }
      return;
    });
    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
    return widths.map((w, i) => {
      if (w === undefined) {
        return Math.max(unsetWidth, _minWidth(row[i]));
      }
      return w;
    });
  }
}
function addBorder(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return '';
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return '  ';
  }
  return '';
}
function _minWidth(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
}
function getWindowWidth() {
  if (typeof process === 'object' && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
}
function alignRight(str, width) {
  str = str.trim();
  const strWidth = mixin2.stringWidth(str);
  if (strWidth < width) {
    return ' '.repeat(width - strWidth) + str;
  }
  return str;
}
function alignCenter(str, width) {
  str = str.trim();
  const strWidth = mixin2.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return ' '.repeat((width - strWidth) >> 1) + str;
}
var mixin2;
function cliui(opts, _mixin) {
  mixin2 = _mixin;
  return new UI({
    width: (opts === null || opts === undefined ? undefined : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === undefined ? undefined : opts.wrap,
  });
}

// ../../node_modules/.bun/cliui@8.0.1/node_modules/cliui/build/lib/string-utils.js
var ansi = new RegExp(
  '\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|' + '\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)',
  'g'
);
function stripAnsi(str) {
  return str.replace(ansi, '');
}
function wrap(str, width) {
  const [start, end] = str.match(ansi) || ['', ''];
  str = stripAnsi(str);
  let wrapped = '';
  for (let i = 0; i < str.length; i++) {
    if (i !== 0 && i % width === 0) {
      wrapped += `
`;
    }
    wrapped += str.charAt(i);
  }
  if (start && end) {
    wrapped = `${start}${wrapped}${end}`;
  }
  return wrapped;
}

// ../../node_modules/.bun/cliui@8.0.1/node_modules/cliui/index.mjs
function ui(opts) {
  return cliui(opts, {
    stringWidth: (str) => {
      return [...str].length;
    },
    stripAnsi,
    wrap,
  });
}

// ../../node_modules/.bun/escalade@3.2.0/node_modules/escalade/sync/index.mjs
import { dirname, resolve as resolve2 } from 'path';
import { readdirSync, statSync } from 'fs';
function sync_default(start, callback) {
  let dir = resolve2('.', start);
  let tmp,
    stats = statSync(dir);
  if (!stats.isDirectory()) {
    dir = dirname(dir);
  }
  while (true) {
    tmp = callback(dir, readdirSync(dir));
    if (tmp) return resolve2(dir, tmp);
    dir = dirname((tmp = dir));
    if (tmp === dir) break;
  }
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs
import { inspect } from 'util';
import { readFileSync as readFileSync2 } from 'fs';
import { fileURLToPath } from 'url';
import { basename, dirname as dirname2, extname, relative, resolve as resolve4 } from 'path';

// ../../node_modules/.bun/y18n@5.0.8/node_modules/y18n/build/lib/platform-shims/node.js
import { readFileSync, statSync as statSync2, writeFile } from 'fs';
import { format as format2 } from 'util';
import { resolve as resolve3 } from 'path';
var node_default = {
  fs: {
    readFileSync,
    writeFile,
  },
  format: format2,
  resolve: resolve3,
  exists: (file) => {
    try {
      return statSync2(file).isFile();
    } catch (err) {
      return false;
    }
  },
};

// ../../node_modules/.bun/y18n@5.0.8/node_modules/y18n/build/lib/index.js
var shim2;

class Y18N {
  constructor(opts) {
    opts = opts || {};
    this.directory = opts.directory || './locales';
    this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;
    this.locale = opts.locale || 'en';
    this.fallbackToLanguage =
      typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true;
    this.cache = Object.create(null);
    this.writeQueue = [];
  }
  __(...args) {
    if (typeof arguments[0] !== 'string') {
      return this._taggedLiteral(arguments[0], ...arguments);
    }
    const str = args.shift();
    let cb = function () {};
    if (typeof args[args.length - 1] === 'function') cb = args.pop();
    cb = cb || function () {};
    if (!this.cache[this.locale]) this._readLocaleFile();
    if (!this.cache[this.locale][str] && this.updateFiles) {
      this.cache[this.locale][str] = str;
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb,
      });
    } else {
      cb();
    }
    return shim2.format.apply(shim2.format, [this.cache[this.locale][str] || str].concat(args));
  }
  __n() {
    const args = Array.prototype.slice.call(arguments);
    const singular = args.shift();
    const plural = args.shift();
    const quantity = args.shift();
    let cb = function () {};
    if (typeof args[args.length - 1] === 'function') cb = args.pop();
    if (!this.cache[this.locale]) this._readLocaleFile();
    let str = quantity === 1 ? singular : plural;
    if (this.cache[this.locale][singular]) {
      const entry = this.cache[this.locale][singular];
      str = entry[quantity === 1 ? 'one' : 'other'];
    }
    if (!this.cache[this.locale][singular] && this.updateFiles) {
      this.cache[this.locale][singular] = {
        one: singular,
        other: plural,
      };
      this._enqueueWrite({
        directory: this.directory,
        locale: this.locale,
        cb,
      });
    } else {
      cb();
    }
    const values = [str];
    if (~str.indexOf('%d')) values.push(quantity);
    return shim2.format.apply(shim2.format, values.concat(args));
  }
  setLocale(locale) {
    this.locale = locale;
  }
  getLocale() {
    return this.locale;
  }
  updateLocale(obj) {
    if (!this.cache[this.locale]) this._readLocaleFile();
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        this.cache[this.locale][key] = obj[key];
      }
    }
  }
  _taggedLiteral(parts, ...args) {
    let str = '';
    parts.forEach(function (part, i) {
      const arg = args[i + 1];
      str += part;
      if (typeof arg !== 'undefined') {
        str += '%s';
      }
    });
    return this.__.apply(this, [str].concat([].slice.call(args, 1)));
  }
  _enqueueWrite(work) {
    this.writeQueue.push(work);
    if (this.writeQueue.length === 1) this._processWriteQueue();
  }
  _processWriteQueue() {
    const _this = this;
    const work = this.writeQueue[0];
    const directory = work.directory;
    const locale = work.locale;
    const cb = work.cb;
    const languageFile = this._resolveLocaleFile(directory, locale);
    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
    shim2.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
      _this.writeQueue.shift();
      if (_this.writeQueue.length > 0) _this._processWriteQueue();
      cb(err);
    });
  }
  _readLocaleFile() {
    let localeLookup = {};
    const languageFile = this._resolveLocaleFile(this.directory, this.locale);
    try {
      if (shim2.fs.readFileSync) {
        localeLookup = JSON.parse(shim2.fs.readFileSync(languageFile, 'utf-8'));
      }
    } catch (err) {
      if (err instanceof SyntaxError) {
        err.message = 'syntax error in ' + languageFile;
      }
      if (err.code === 'ENOENT') localeLookup = {};
      else throw err;
    }
    this.cache[this.locale] = localeLookup;
  }
  _resolveLocaleFile(directory, locale) {
    let file = shim2.resolve(directory, './', locale + '.json');
    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
      const languageFile = shim2.resolve(directory, './', locale.split('_')[0] + '.json');
      if (this._fileExistsSync(languageFile)) file = languageFile;
    }
    return file;
  }
  _fileExistsSync(file) {
    return shim2.exists(file);
  }
}
function y18n(opts, _shim) {
  shim2 = _shim;
  const y18n2 = new Y18N(opts);
  return {
    __: y18n2.__.bind(y18n2),
    __n: y18n2.__n.bind(y18n2),
    setLocale: y18n2.setLocale.bind(y18n2),
    getLocale: y18n2.getLocale.bind(y18n2),
    updateLocale: y18n2.updateLocale.bind(y18n2),
    locale: y18n2.locale,
  };
}

// ../../node_modules/.bun/y18n@5.0.8/node_modules/y18n/index.mjs
var y18n2 = (opts) => {
  return y18n(opts, node_default);
};
var y18n_default = y18n2;

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/lib/platform-shims/esm.mjs
var REQUIRE_ERROR = 'require is not supported by ESM';
var REQUIRE_DIRECTORY_ERROR = 'loading a directory of commands is not supported yet for ESM';
var __dirname2;
try {
  __dirname2 = fileURLToPath(import.meta.url);
} catch (e) {
  __dirname2 = process.cwd();
}
var mainFilename = __dirname2.substring(0, __dirname2.lastIndexOf('node_modules'));
var esm_default = {
  assert: {
    notStrictEqual,
    strictEqual,
  },
  cliui: ui,
  findUp: sync_default,
  getEnv: (key) => {
    return process.env[key];
  },
  inspect,
  getCallerFile: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  getProcessArgvBin,
  mainFilename: mainFilename || process.cwd(),
  Parser: lib_default,
  path: {
    basename,
    dirname: dirname2,
    extname,
    relative,
    resolve: resolve4,
  },
  process: {
    argv: () => process.argv,
    cwd: process.cwd,
    emitWarning: (warning, type) => process.emitWarning(warning, type),
    execPath: () => process.execPath,
    exit: process.exit,
    nextTick: process.nextTick,
    stdColumns: typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null,
  },
  readFileSync: readFileSync2,
  require: () => {
    throw new YError(REQUIRE_ERROR);
  },
  requireDirectory: () => {
    throw new YError(REQUIRE_DIRECTORY_ERROR);
  },
  stringWidth: (str) => {
    return [...str].length;
  },
  y18n: y18n_default({
    directory: resolve4(__dirname2, '../../../locales'),
    updateFiles: false,
  }),
};

// src/constants.ts
var EXIT_CODES = {
  SUCCESS: 0,
  VALIDATION_ERROR: 1,
  CONFIG_ERROR: 3,
  INTERRUPTED: 130,
};

// src/app.ts
async function loadCommands() {
  const [initCommand2, validateCommand2, fixCommand2, promptCommand2] = await Promise.all([
    Promise.resolve()
      .then(() => (init_init2(), exports_init))
      .then((m) => m.initCommand),
    Promise.resolve()
      .then(() => (init_validate(), exports_validate))
      .then((m) => m.validateCommand),
    Promise.resolve()
      .then(() => (init_fix(), exports_fix))
      .then((m) => m.fixCommand),
    Promise.resolve()
      .then(() => (init_prompt(), exports_prompt))
      .then((m) => m.promptCommand),
  ]);
  return {
    initCommand: initCommand2,
    validateCommand: validateCommand2,
    fixCommand: fixCommand2,
    promptCommand: promptCommand2,
  };
}
function configureCli(cli, version) {
  return cli
    .scriptName('nimata')
    .version(version)
    .usage('$0 <command> [options]')
    .option('config', {
      type: 'string',
      description: 'Path to custom configuration file',
      alias: 'c',
      global: true,
    })
    .demandCommand(1, import_picocolors7.default.red('You must specify a command'))
    .help('h')
    .alias('h', 'help')
    .alias('v', 'version')
    .strict()
    .wrap(null)
    .epilogue(
      import_picocolors7.default.dim(
        'For more information, visit: https://github.com/yourusername/nimata'
      )
    );
}
function configureForTestMode(cli) {
  return cli.exitProcess(false).showHelpOnFail(false).fail(false);
}

class CliApp {
  output;
  cliBuilder;
  constructor(output, cliBuilder) {
    this.output = output;
    this.cliBuilder = cliBuilder;
  }
  async getVersion() {
    try {
      const packagePath = new URL('../package.json', import.meta.url);
      const packageJson = await Bun.file(packagePath).json();
      return packageJson.version ?? '0.0.0';
    } catch {
      this.output.error(import_picocolors7.default.red('Error reading package.json version'));
      return '0.0.0';
    }
  }
  setupInterruptHandler() {
    process.on('SIGINT', () => {
      this.output.log(
        import_picocolors7.default.yellow(`

Operation interrupted by user`)
      );
      process.exit(EXIT_CODES.INTERRUPTED);
    });
  }
  async createCli(version, argv, suppressOutput = false) {
    const commands = await loadCommands();
    let cli = configureCli(
      this.cliBuilder
        .create(argv)
        .command(commands.initCommand)
        .command(commands.validateCommand)
        .command(commands.fixCommand)
        .command(commands.promptCommand),
      version
    );
    if (suppressOutput) {
      cli = configureForTestMode(cli);
    }
    return cli;
  }
  async run(argv = hideBin(process.argv)) {
    try {
      this.setupInterruptHandler();
      const version = await this.getVersion();
      const cli = await this.createCli(version, argv);
      await cli.parse();
    } catch (error) {
      this.output.error(import_picocolors7.default.red('Fatal error:'), error);
      process.exit(EXIT_CODES.CONFIG_ERROR);
    }
  }
}
CliApp = __legacyDecorateClassTS(
  [
    injectable_default(),
    __legacyDecorateParamTS(0, inject_default('OutputWriter')),
    __legacyDecorateParamTS(1, inject_default('CliBuilder')),
    __legacyMetadataTS('design:paramtypes', [
      typeof OutputWriter === 'undefined' ? Object : OutputWriter,
      typeof CliBuilder === 'undefined' ? Object : CliBuilder,
    ]),
  ],
  CliApp
);

// src/container.ts
init_esm5();
var import_reflect_metadata = __toESM(require_Reflect(), 1);

// src/cli-builder.ts
init_esm5();

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/typings/common-types.js
function assertNotStrictEqual(actual, expected, shim3, message) {
  shim3.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim3) {
  shim3.assert.strictEqual(typeof actual, 'string');
}
function objectKeys(object) {
  return Object.keys(object);
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/is-promise.js
function isPromise(maybePromise) {
  return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === 'function';
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/parse-command.js
function parseCommand(cmd) {
  const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
  const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
  const bregex = /\.*[\][<>]/g;
  const firstCommand = splitCommand.shift();
  if (!firstCommand) throw new Error(`No command found in: ${cmd}`);
  const parsedCommand = {
    cmd: firstCommand.replace(bregex, ''),
    demanded: [],
    optional: [],
  };
  splitCommand.forEach((cmd2, i) => {
    let variadic = false;
    cmd2 = cmd2.replace(/\s/g, '');
    if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1) variadic = true;
    if (/^\[/.test(cmd2)) {
      parsedCommand.optional.push({
        cmd: cmd2.replace(bregex, '').split('|'),
        variadic,
      });
    } else {
      parsedCommand.demanded.push({
        cmd: cmd2.replace(bregex, '').split('|'),
        variadic,
      });
    }
  });
  return parsedCommand;
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/argsert.js
var positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];
function argsert(arg1, arg2, arg3) {
  function parseArgs() {
    return typeof arg1 === 'object'
      ? [{ demanded: [], optional: [] }, arg1, arg2]
      : [parseCommand(`cmd ${arg1}`), arg2, arg3];
  }
  try {
    let position = 0;
    const [parsed, callerArguments, _length] = parseArgs();
    const args = [].slice.call(callerArguments);
    while (args.length && args[args.length - 1] === undefined) args.pop();
    const length = _length || args.length;
    if (length < parsed.demanded.length) {
      throw new YError(
        `Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`
      );
    }
    const totalCommands = parsed.demanded.length + parsed.optional.length;
    if (length > totalCommands) {
      throw new YError(
        `Too many arguments provided. Expected max ${totalCommands} but received ${length}.`
      );
    }
    parsed.demanded.forEach((demanded) => {
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === '*');
      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);
      position += 1;
    });
    parsed.optional.forEach((optional) => {
      if (args.length === 0) return;
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = optional.cmd.filter((type) => type === observedType || type === '*');
      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}
function guessType(arg) {
  if (Array.isArray(arg)) {
    return 'array';
  } else if (arg === null) {
    return 'null';
  }
  return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) {
  throw new YError(
    `Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`
  );
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/middleware.js
class GlobalMiddleware {
  constructor(yargs) {
    this.globalMiddleware = [];
    this.frozens = [];
    this.yargs = yargs;
  }
  addMiddleware(callback, applyBeforeValidation, global3 = true, mutates = false) {
    argsert(
      '<array|function> [boolean] [boolean] [boolean]',
      [callback, applyBeforeValidation, global3],
      arguments.length
    );
    if (Array.isArray(callback)) {
      for (let i = 0; i < callback.length; i++) {
        if (typeof callback[i] !== 'function') {
          throw Error('middleware must be a function');
        }
        const m = callback[i];
        m.applyBeforeValidation = applyBeforeValidation;
        m.global = global3;
      }
      Array.prototype.push.apply(this.globalMiddleware, callback);
    } else if (typeof callback === 'function') {
      const m = callback;
      m.applyBeforeValidation = applyBeforeValidation;
      m.global = global3;
      m.mutates = mutates;
      this.globalMiddleware.push(callback);
    }
    return this.yargs;
  }
  addCoerceMiddleware(callback, option) {
    const aliases = this.yargs.getAliases();
    this.globalMiddleware = this.globalMiddleware.filter((m) => {
      const toCheck = [...(aliases[option] || []), option];
      if (!m.option) return true;
      else return !toCheck.includes(m.option);
    });
    callback.option = option;
    return this.addMiddleware(callback, true, true, true);
  }
  getMiddleware() {
    return this.globalMiddleware;
  }
  freeze() {
    this.frozens.push([...this.globalMiddleware]);
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    if (frozen !== undefined) this.globalMiddleware = frozen;
  }
  reset() {
    this.globalMiddleware = this.globalMiddleware.filter((m) => m.global);
  }
}
function commandMiddlewareFactory(commandMiddleware) {
  if (!commandMiddleware) return [];
  return commandMiddleware.map((middleware) => {
    middleware.applyBeforeValidation = false;
    return middleware;
  });
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) {
  return middlewares.reduce((acc, middleware) => {
    if (middleware.applyBeforeValidation !== beforeValidation) {
      return acc;
    }
    if (middleware.mutates) {
      if (middleware.applied) return acc;
      middleware.applied = true;
    }
    if (isPromise(acc)) {
      return acc
        .then((initialObj) => Promise.all([initialObj, middleware(initialObj, yargs)]))
        .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
    } else {
      const result = middleware(acc, yargs);
      return isPromise(result)
        ? result.then((middlewareObj) => Object.assign(acc, middlewareObj))
        : Object.assign(acc, result);
    }
  }, argv);
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/maybe-async-result.js
function maybeAsyncResult(
  getResult,
  resultHandler,
  errorHandler = (err) => {
    throw err;
  }
) {
  try {
    const result = isFunction(getResult) ? getResult() : getResult;
    return isPromise(result)
      ? result.then((result2) => resultHandler(result2))
      : resultHandler(result);
  } catch (err) {
    return errorHandler(err);
  }
}
function isFunction(arg) {
  return typeof arg === 'function';
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/which-module.js
function whichModule(exported) {
  if (false);
  for (let i = 0, files = Object.keys(__require.cache), mod; i < files.length; i++) {
    mod = __require.cache[files[i]];
    if (mod.exports === exported) return mod;
  }
  return null;
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/command.js
var DEFAULT_MARKER = /(^\*)|(^\$0)/;

class CommandInstance {
  constructor(usage, validation, globalMiddleware, shim3) {
    this.requireCache = new Set();
    this.handlers = {};
    this.aliasMap = {};
    this.frozens = [];
    this.shim = shim3;
    this.usage = usage;
    this.globalMiddleware = globalMiddleware;
    this.validation = validation;
  }
  addDirectory(dir, req, callerFile, opts) {
    opts = opts || {};
    if (typeof opts.recurse !== 'boolean') opts.recurse = false;
    if (!Array.isArray(opts.extensions)) opts.extensions = ['js'];
    const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;
    opts.visit = (obj, joined, filename) => {
      const visited = parentVisit(obj, joined, filename);
      if (visited) {
        if (this.requireCache.has(joined)) return visited;
        else this.requireCache.add(joined);
        this.addHandler(visited);
      }
      return visited;
    };
    this.shim.requireDirectory({ require: req, filename: callerFile }, dir, opts);
  }
  addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
    let aliases = [];
    const middlewares = commandMiddlewareFactory(commandMiddleware);
    handler = handler || (() => {});
    if (Array.isArray(cmd)) {
      if (isCommandAndAliases(cmd)) {
        [cmd, ...aliases] = cmd;
      } else {
        for (const command of cmd) {
          this.addHandler(command);
        }
      }
    } else if (isCommandHandlerDefinition(cmd)) {
      let command =
        Array.isArray(cmd.command) || typeof cmd.command === 'string'
          ? cmd.command
          : this.moduleName(cmd);
      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);
      this.addHandler(
        command,
        this.extractDesc(cmd),
        cmd.builder,
        cmd.handler,
        cmd.middlewares,
        cmd.deprecated
      );
      return;
    } else if (isCommandBuilderDefinition(builder)) {
      this.addHandler(
        [cmd].concat(aliases),
        description,
        builder.builder,
        builder.handler,
        builder.middlewares,
        builder.deprecated
      );
      return;
    }
    if (typeof cmd === 'string') {
      const parsedCommand = parseCommand(cmd);
      aliases = aliases.map((alias) => parseCommand(alias).cmd);
      let isDefault = false;
      const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
        if (DEFAULT_MARKER.test(c)) {
          isDefault = true;
          return false;
        }
        return true;
      });
      if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0');
      if (isDefault) {
        parsedCommand.cmd = parsedAliases[0];
        aliases = parsedAliases.slice(1);
        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
      }
      aliases.forEach((alias) => {
        this.aliasMap[alias] = parsedCommand.cmd;
      });
      if (description !== false) {
        this.usage.command(cmd, description, isDefault, aliases, deprecated);
      }
      this.handlers[parsedCommand.cmd] = {
        original: cmd,
        description,
        handler,
        builder: builder || {},
        middlewares,
        deprecated,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional,
      };
      if (isDefault) this.defaultCommand = this.handlers[parsedCommand.cmd];
    }
  }
  getCommandHandlers() {
    return this.handlers;
  }
  getCommands() {
    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
  }
  hasDefaultCommand() {
    return !!this.defaultCommand;
  }
  runCommand(command, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
    const commandHandler =
      this.handlers[command] || this.handlers[this.aliasMap[command]] || this.defaultCommand;
    const currentContext = yargs.getInternalMethods().getContext();
    const parentCommands = currentContext.commands.slice();
    const isDefaultCommand = !command;
    if (command) {
      currentContext.commands.push(command);
      currentContext.fullCommands.push(commandHandler.original);
    }
    const builderResult = this.applyBuilderUpdateUsageAndParse(
      isDefaultCommand,
      commandHandler,
      yargs,
      parsed.aliases,
      parentCommands,
      commandIndex,
      helpOnly,
      helpOrVersionSet
    );
    return isPromise(builderResult)
      ? builderResult.then((result) =>
          this.applyMiddlewareAndGetResult(
            isDefaultCommand,
            commandHandler,
            result.innerArgv,
            currentContext,
            helpOnly,
            result.aliases,
            yargs
          )
        )
      : this.applyMiddlewareAndGetResult(
          isDefaultCommand,
          commandHandler,
          builderResult.innerArgv,
          currentContext,
          helpOnly,
          builderResult.aliases,
          yargs
        );
  }
  applyBuilderUpdateUsageAndParse(
    isDefaultCommand,
    commandHandler,
    yargs,
    aliases,
    parentCommands,
    commandIndex,
    helpOnly,
    helpOrVersionSet
  ) {
    const builder = commandHandler.builder;
    let innerYargs = yargs;
    if (isCommandBuilderCallback(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
      if (isPromise(builderOutput)) {
        return builderOutput.then((output) => {
          innerYargs = isYargsInstance(output) ? output : yargs;
          return this.parseAndUpdateUsage(
            isDefaultCommand,
            commandHandler,
            innerYargs,
            parentCommands,
            commandIndex,
            helpOnly
          );
        });
      }
    } else if (isCommandBuilderOptionDefinitions(builder)) {
      yargs.getInternalMethods().getUsageInstance().freeze();
      innerYargs = yargs.getInternalMethods().reset(aliases);
      Object.keys(commandHandler.builder).forEach((key) => {
        innerYargs.option(key, builder[key]);
      });
    }
    return this.parseAndUpdateUsage(
      isDefaultCommand,
      commandHandler,
      innerYargs,
      parentCommands,
      commandIndex,
      helpOnly
    );
  }
  parseAndUpdateUsage(
    isDefaultCommand,
    commandHandler,
    innerYargs,
    parentCommands,
    commandIndex,
    helpOnly
  ) {
    if (isDefaultCommand) innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
    if (this.shouldUpdateUsage(innerYargs)) {
      innerYargs
        .getInternalMethods()
        .getUsageInstance()
        .usage(
          this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler),
          commandHandler.description
        );
    }
    const innerArgv = innerYargs
      .getInternalMethods()
      .runYargsParserAndExecuteCommands(null, undefined, true, commandIndex, helpOnly);
    return isPromise(innerArgv)
      ? innerArgv.then((argv) => ({
          aliases: innerYargs.parsed.aliases,
          innerArgv: argv,
        }))
      : {
          aliases: innerYargs.parsed.aliases,
          innerArgv,
        };
  }
  shouldUpdateUsage(yargs) {
    return (
      !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() &&
      yargs.getInternalMethods().getUsageInstance().getUsage().length === 0
    );
  }
  usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
    const c = DEFAULT_MARKER.test(commandHandler.original)
      ? commandHandler.original.replace(DEFAULT_MARKER, '').trim()
      : commandHandler.original;
    const pc8 = parentCommands.filter((c2) => {
      return !DEFAULT_MARKER.test(c2);
    });
    pc8.push(c);
    return `$0 ${pc8.join(' ')}`;
  }
  handleValidationAndGetResult(
    isDefaultCommand,
    commandHandler,
    innerArgv,
    currentContext,
    aliases,
    yargs,
    middlewares,
    positionalMap
  ) {
    if (!yargs.getInternalMethods().getHasOutput()) {
      const validation = yargs
        .getInternalMethods()
        .runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        validation(result);
        return result;
      });
    }
    if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
      yargs.getInternalMethods().setHasOutput();
      const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
      yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
      innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
      innerArgv = maybeAsyncResult(innerArgv, (result) => {
        const handlerResult = commandHandler.handler(result);
        return isPromise(handlerResult) ? handlerResult.then(() => result) : result;
      });
      if (!isDefaultCommand) {
        yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
      }
      if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
        innerArgv.catch((error) => {
          try {
            yargs.getInternalMethods().getUsageInstance().fail(null, error);
          } catch (_err) {}
        });
      }
    }
    if (!isDefaultCommand) {
      currentContext.commands.pop();
      currentContext.fullCommands.pop();
    }
    return innerArgv;
  }
  applyMiddlewareAndGetResult(
    isDefaultCommand,
    commandHandler,
    innerArgv,
    currentContext,
    helpOnly,
    aliases,
    yargs
  ) {
    let positionalMap = {};
    if (helpOnly) return innerArgv;
    if (!yargs.getInternalMethods().getHasOutput()) {
      positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
    }
    const middlewares = this.globalMiddleware
      .getMiddleware()
      .slice(0)
      .concat(commandHandler.middlewares);
    const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
    return isPromise(maybePromiseArgv)
      ? maybePromiseArgv.then((resolvedInnerArgv) =>
          this.handleValidationAndGetResult(
            isDefaultCommand,
            commandHandler,
            resolvedInnerArgv,
            currentContext,
            aliases,
            yargs,
            middlewares,
            positionalMap
          )
        )
      : this.handleValidationAndGetResult(
          isDefaultCommand,
          commandHandler,
          maybePromiseArgv,
          currentContext,
          aliases,
          yargs,
          middlewares,
          positionalMap
        );
  }
  populatePositionals(commandHandler, argv, context, yargs) {
    argv._ = argv._.slice(context.commands.length);
    const demanded = commandHandler.demanded.slice(0);
    const optional = commandHandler.optional.slice(0);
    const positionalMap = {};
    this.validation.positionalCount(demanded.length, argv._.length);
    while (demanded.length) {
      const demand = demanded.shift();
      this.populatePositional(demand, argv, positionalMap);
    }
    while (optional.length) {
      const maybe = optional.shift();
      this.populatePositional(maybe, argv, positionalMap);
    }
    argv._ = context.commands.concat(argv._.map((a) => '' + a));
    this.postProcessPositionals(
      argv,
      positionalMap,
      this.cmdToParseOptions(commandHandler.original),
      yargs
    );
    return positionalMap;
  }
  populatePositional(positional, argv, positionalMap) {
    const cmd = positional.cmd[0];
    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String);
    } else {
      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];
    }
  }
  cmdToParseOptions(cmdString) {
    const parseOptions = {
      array: [],
      default: {},
      alias: {},
      demand: {},
    };
    const parsed = parseCommand(cmdString);
    parsed.demanded.forEach((d) => {
      const [cmd, ...aliases] = d.cmd;
      if (d.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
      parseOptions.demand[cmd] = true;
    });
    parsed.optional.forEach((o) => {
      const [cmd, ...aliases] = o.cmd;
      if (o.variadic) {
        parseOptions.array.push(cmd);
        parseOptions.default[cmd] = [];
      }
      parseOptions.alias[cmd] = aliases;
    });
    return parseOptions;
  }
  postProcessPositionals(argv, positionalMap, parseOptions, yargs) {
    const options = Object.assign({}, yargs.getOptions());
    options.default = Object.assign(parseOptions.default, options.default);
    for (const key of Object.keys(parseOptions.alias)) {
      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
    }
    options.array = options.array.concat(parseOptions.array);
    options.config = {};
    const unparsed = [];
    Object.keys(positionalMap).forEach((key) => {
      positionalMap[key].map((value) => {
        if (options.configuration['unknown-options-as-args']) options.key[key] = true;
        unparsed.push(`--${key}`);
        unparsed.push(value);
      });
    });
    if (!unparsed.length) return;
    const config2 = Object.assign({}, options.configuration, {
      'populate--': false,
    });
    const parsed = this.shim.Parser.detailed(
      unparsed,
      Object.assign({}, options, {
        configuration: config2,
      })
    );
    if (parsed.error) {
      yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
    } else {
      const positionalKeys = Object.keys(positionalMap);
      Object.keys(positionalMap).forEach((key) => {
        positionalKeys.push(...parsed.aliases[key]);
      });
      Object.keys(parsed.argv).forEach((key) => {
        if (positionalKeys.includes(key)) {
          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
          if (
            !this.isInConfigs(yargs, key) &&
            !this.isDefaulted(yargs, key) &&
            Object.prototype.hasOwnProperty.call(argv, key) &&
            Object.prototype.hasOwnProperty.call(parsed.argv, key) &&
            (Array.isArray(argv[key]) || Array.isArray(parsed.argv[key]))
          ) {
            argv[key] = [].concat(argv[key], parsed.argv[key]);
          } else {
            argv[key] = parsed.argv[key];
          }
        }
      });
    }
  }
  isDefaulted(yargs, key) {
    const { default: defaults2 } = yargs.getOptions();
    return (
      Object.prototype.hasOwnProperty.call(defaults2, key) ||
      Object.prototype.hasOwnProperty.call(defaults2, this.shim.Parser.camelCase(key))
    );
  }
  isInConfigs(yargs, key) {
    const { configObjects } = yargs.getOptions();
    return (
      configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, key)) ||
      configObjects.some((c) =>
        Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key))
      )
    );
  }
  runDefaultBuilderOn(yargs) {
    if (!this.defaultCommand) return;
    if (this.shouldUpdateUsage(yargs)) {
      const commandString = DEFAULT_MARKER.test(this.defaultCommand.original)
        ? this.defaultCommand.original
        : this.defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
      yargs
        .getInternalMethods()
        .getUsageInstance()
        .usage(commandString, this.defaultCommand.description);
    }
    const builder = this.defaultCommand.builder;
    if (isCommandBuilderCallback(builder)) {
      return builder(yargs, true);
    } else if (!isCommandBuilderDefinition(builder)) {
      Object.keys(builder).forEach((key) => {
        yargs.option(key, builder[key]);
      });
    }
    return;
  }
  moduleName(obj) {
    const mod = whichModule(obj);
    if (!mod) throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
    return this.commandFromFilename(mod.filename);
  }
  commandFromFilename(filename) {
    return this.shim.path.basename(filename, this.shim.path.extname(filename));
  }
  extractDesc({ describe, description, desc }) {
    for (const test of [describe, description, desc]) {
      if (typeof test === 'string' || test === false) return test;
      assertNotStrictEqual(test, true, this.shim);
    }
    return false;
  }
  freeze() {
    this.frozens.push({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand,
    });
  }
  unfreeze() {
    const frozen = this.frozens.pop();
    assertNotStrictEqual(frozen, undefined, this.shim);
    ({
      handlers: this.handlers,
      aliasMap: this.aliasMap,
      defaultCommand: this.defaultCommand,
    } = frozen);
  }
  reset() {
    this.handlers = {};
    this.aliasMap = {};
    this.defaultCommand = undefined;
    this.requireCache = new Set();
    return this;
  }
}
function command(usage, validation, globalMiddleware, shim3) {
  return new CommandInstance(usage, validation, globalMiddleware, shim3);
}
function isCommandBuilderDefinition(builder) {
  return typeof builder === 'object' && !!builder.builder && typeof builder.handler === 'function';
}
function isCommandAndAliases(cmd) {
  return cmd.every((c) => typeof c === 'string');
}
function isCommandBuilderCallback(builder) {
  return typeof builder === 'function';
}
function isCommandBuilderOptionDefinitions(builder) {
  return typeof builder === 'object';
}
function isCommandHandlerDefinition(cmd) {
  return typeof cmd === 'object' && !Array.isArray(cmd);
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/obj-filter.js
function objFilter(original = {}, filter = () => true) {
  const obj = {};
  objectKeys(original).forEach((key) => {
    if (filter(key, original[key])) {
      obj[key] = original[key];
    }
  });
  return obj;
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/set-blocking.js
function setBlocking(blocking) {
  if (typeof process === 'undefined') return;
  [process.stdout, process.stderr].forEach((_stream) => {
    const stream = _stream;
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
      stream._handle.setBlocking(blocking);
    }
  });
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/usage.js
function isBoolean(fail) {
  return typeof fail === 'boolean';
}
function usage(yargs, shim3) {
  const __ = shim3.y18n.__;
  const self2 = {};
  const fails = [];
  self2.failFn = function failFn(f) {
    fails.push(f);
  };
  let failMessage = null;
  let globalFailMessage = null;
  let showHelpOnFail = true;
  self2.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
    const [enabled, message] = typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];
    if (yargs.getInternalMethods().isGlobalContext()) {
      globalFailMessage = message;
    }
    failMessage = message;
    showHelpOnFail = enabled;
    return self2;
  };
  let failureOutput = false;
  self2.fail = function fail(msg, err) {
    const logger3 = yargs.getInternalMethods().getLoggerInstance();
    if (fails.length) {
      for (let i = fails.length - 1; i >= 0; --i) {
        const fail = fails[i];
        if (isBoolean(fail)) {
          if (err) throw err;
          else if (msg) throw Error(msg);
        } else {
          fail(msg, err, self2);
        }
      }
    } else {
      if (yargs.getExitProcess()) setBlocking(true);
      if (!failureOutput) {
        failureOutput = true;
        if (showHelpOnFail) {
          yargs.showHelp('error');
          logger3.error();
        }
        if (msg || err) logger3.error(msg || err);
        const globalOrCommandFailMessage = failMessage || globalFailMessage;
        if (globalOrCommandFailMessage) {
          if (msg || err) logger3.error('');
          logger3.error(globalOrCommandFailMessage);
        }
      }
      err = err || new YError(msg);
      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs.getInternalMethods().hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  };
  let usages = [];
  let usageDisabled = false;
  self2.usage = (msg, description) => {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self2;
    }
    usageDisabled = false;
    usages.push([msg, description || '']);
    return self2;
  };
  self2.getUsage = () => {
    return usages;
  };
  self2.getUsageDisabled = () => {
    return usageDisabled;
  };
  self2.getPositionalGroupName = () => {
    return __('Positionals:');
  };
  let examples = [];
  self2.example = (cmd, description) => {
    examples.push([cmd, description || '']);
  };
  let commands = [];
  self2.command = function command(cmd, description, isDefault, aliases, deprecated = false) {
    if (isDefault) {
      commands = commands.map((cmdArray) => {
        cmdArray[2] = false;
        return cmdArray;
      });
    }
    commands.push([cmd, description || '', isDefault, aliases, deprecated]);
  };
  self2.getCommands = () => commands;
  let descriptions = {};
  self2.describe = function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach((k) => {
        self2.describe(k, desc);
      });
    } else if (typeof keyOrKeys === 'object') {
      Object.keys(keyOrKeys).forEach((k) => {
        self2.describe(k, keyOrKeys[k]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  };
  self2.getDescriptions = () => descriptions;
  let epilogs = [];
  self2.epilog = (msg) => {
    epilogs.push(msg);
  };
  let wrapSet = false;
  let wrap2;
  self2.wrap = (cols) => {
    wrapSet = true;
    wrap2 = cols;
  };
  self2.getWrap = () => {
    if (shim3.getEnv('YARGS_DISABLE_WRAP')) {
      return null;
    }
    if (!wrapSet) {
      wrap2 = windowWidth();
      wrapSet = true;
    }
    return wrap2;
  };
  const deferY18nLookupPrefix = '__yargsString__:';
  self2.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
  self2.help = function help() {
    if (cachedHelpMessage) return cachedHelpMessage;
    normalizeAliases();
    const base$0 = yargs.customScriptName ? yargs.$0 : shim3.path.basename(yargs.$0);
    const demandedOptions = yargs.getDemandedOptions();
    const demandedCommands = yargs.getDemandedCommands();
    const deprecatedOptions = yargs.getDeprecatedOptions();
    const groups = yargs.getGroups();
    const options = yargs.getOptions();
    let keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options.default));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(
      keys.reduce((acc, key) => {
        if (key !== '_') acc[key] = true;
        return acc;
      }, {})
    );
    const theWrap = self2.getWrap();
    const ui2 = shim3.cliui({
      width: theWrap,
      wrap: !!theWrap,
    });
    if (!usageDisabled) {
      if (usages.length) {
        usages.forEach((usage2) => {
          ui2.div({ text: `${usage2[0].replace(/\$0/g, base$0)}` });
          if (usage2[1]) {
            ui2.div({ text: `${usage2[1]}`, padding: [1, 0, 0, 0] });
          }
        });
        ui2.div();
      } else if (commands.length) {
        let u = null;
        if (demandedCommands._) {
          u = `${base$0} <${__('command')}>
`;
        } else {
          u = `${base$0} [${__('command')}]
`;
        }
        ui2.div(`${u}`);
      }
    }
    if (commands.length > 1 || (commands.length === 1 && !commands[0][2])) {
      ui2.div(__('Commands:'));
      const context = yargs.getInternalMethods().getContext();
      const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';
      if (yargs.getInternalMethods().getParserConfiguration()['sort-commands'] === true) {
        commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
      }
      const prefix = base$0 ? `${base$0} ` : '';
      commands.forEach((command2) => {
        const commandString = `${prefix}${parentCommands}${command2[0].replace(/^\$0 ?/, '')}`;
        ui2.span(
          {
            text: commandString,
            padding: [0, 2, 0, 2],
            width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4,
          },
          { text: command2[1] }
        );
        const hints = [];
        if (command2[2]) hints.push(`[${__('default')}]`);
        if (command2[3] && command2[3].length) {
          hints.push(`[${__('aliases:')} ${command2[3].join(', ')}]`);
        }
        if (command2[4]) {
          if (typeof command2[4] === 'string') {
            hints.push(`[${__('deprecated: %s', command2[4])}]`);
          } else {
            hints.push(`[${__('deprecated')}]`);
          }
        }
        if (hints.length) {
          ui2.div({
            text: hints.join(' '),
            padding: [0, 0, 0, 2],
            align: 'right',
          });
        } else {
          ui2.div();
        }
      });
      ui2.div();
    }
    const aliasKeys = (Object.keys(options.alias) || []).concat(
      Object.keys(yargs.parsed.newAliases) || []
    );
    keys = keys.filter(
      (key) =>
        !yargs.parsed.newAliases[key] &&
        aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1)
    );
    const defaultGroup = __('Options:');
    if (!groups[defaultGroup]) groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup);
    const isLongSwitch = (sw) => /^--/.test(getText(sw));
    const displayedGroups = Object.keys(groups)
      .filter((groupName) => groups[groupName].length > 0)
      .map((groupName) => {
        const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
          if (aliasKeys.includes(key)) return key;
          for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
            if ((options.alias[aliasKey] || []).includes(key)) return aliasKey;
          }
          return key;
        });
        return { groupName, normalizedKeys };
      })
      .filter(({ normalizedKeys }) => normalizedKeys.length > 0)
      .map(({ groupName, normalizedKeys }) => {
        const switches = normalizedKeys.reduce((acc, key) => {
          acc[key] = [key]
            .concat(options.alias[key] || [])
            .map((sw) => {
              if (groupName === self2.getPositionalGroupName()) return sw;
              else {
                return (
                  (/^[0-9]$/.test(sw)
                    ? options.boolean.includes(key)
                      ? '-'
                      : '--'
                    : sw.length > 1
                      ? '--'
                      : '-') + sw
                );
              }
            })
            .sort((sw1, sw2) =>
              isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1
            )
            .join(', ');
          return acc;
        }, {});
        return { groupName, normalizedKeys, switches };
      });
    const shortSwitchesUsed = displayedGroups
      .filter(({ groupName }) => groupName !== self2.getPositionalGroupName())
      .some(
        ({ normalizedKeys, switches }) =>
          !normalizedKeys.every((key) => isLongSwitch(switches[key]))
      );
    if (shortSwitchesUsed) {
      displayedGroups
        .filter(({ groupName }) => groupName !== self2.getPositionalGroupName())
        .forEach(({ normalizedKeys, switches }) => {
          normalizedKeys.forEach((key) => {
            if (isLongSwitch(switches[key])) {
              switches[key] = addIndentation(switches[key], '-x, '.length);
            }
          });
        });
    }
    displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
      ui2.div(groupName);
      normalizedKeys.forEach((key) => {
        const kswitch = switches[key];
        let desc = descriptions[key] || '';
        let type = null;
        if (desc.includes(deferY18nLookupPrefix))
          desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (options.boolean.includes(key)) type = `[${__('boolean')}]`;
        if (options.count.includes(key)) type = `[${__('count')}]`;
        if (options.string.includes(key)) type = `[${__('string')}]`;
        if (options.normalize.includes(key)) type = `[${__('string')}]`;
        if (options.array.includes(key)) type = `[${__('array')}]`;
        if (options.number.includes(key)) type = `[${__('number')}]`;
        const deprecatedExtra = (deprecated) =>
          typeof deprecated === 'string'
            ? `[${__('deprecated: %s', deprecated)}]`
            : `[${__('deprecated')}]`;
        const extra = [
          key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
          type,
          key in demandedOptions ? `[${__('required')}]` : null,
          options.choices && options.choices[key]
            ? `[${__('choices:')} ${self2.stringifiedValues(options.choices[key])}]`
            : null,
          defaultString(options.default[key], options.defaultDescription[key]),
        ]
          .filter(Boolean)
          .join(' ');
        ui2.span(
          {
            text: getText(kswitch),
            padding: [0, 2, 0, 2 + getIndentation(kswitch)],
            width: maxWidth(switches, theWrap) + 4,
          },
          desc
        );
        const shouldHideOptionExtras =
          yargs.getInternalMethods().getUsageConfiguration()['hide-types'] === true;
        if (extra && !shouldHideOptionExtras)
          ui2.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' });
        else ui2.div();
      });
      ui2.div();
    });
    if (examples.length) {
      ui2.div(__('Examples:'));
      examples.forEach((example) => {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach((example) => {
        if (example[1] === '') {
          ui2.div({
            text: example[0],
            padding: [0, 2, 0, 2],
          });
        } else {
          ui2.div(
            {
              text: example[0],
              padding: [0, 2, 0, 2],
              width: maxWidth(examples, theWrap) + 4,
            },
            {
              text: example[1],
            }
          );
        }
      });
      ui2.div();
    }
    if (epilogs.length > 0) {
      const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join(`
`);
      ui2.div(`${e}
`);
    }
    return ui2.toString().replace(/\s*$/, '');
  };
  function maxWidth(table, theWrap, modifier) {
    let width = 0;
    if (!Array.isArray(table)) {
      table = Object.values(table).map((v) => [v]);
    }
    table.forEach((v) => {
      width = Math.max(
        shim3.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) +
          getIndentation(v[0]),
        width
      );
    });
    if (theWrap) width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  }
  function normalizeAliases() {
    const demandedOptions = yargs.getDemandedOptions();
    const options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach((key) => {
      options.alias[key].forEach((alias) => {
        if (descriptions[alias]) self2.describe(key, descriptions[alias]);
        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);
        if (options.boolean.includes(alias)) yargs.boolean(key);
        if (options.count.includes(alias)) yargs.count(key);
        if (options.string.includes(alias)) yargs.string(key);
        if (options.normalize.includes(alias)) yargs.normalize(key);
        if (options.array.includes(alias)) yargs.array(key);
        if (options.number.includes(alias)) yargs.number(key);
      });
    });
  }
  let cachedHelpMessage;
  self2.cacheHelpMessage = function () {
    cachedHelpMessage = this.help();
  };
  self2.clearCachedHelpMessage = function () {
    cachedHelpMessage = undefined;
  };
  self2.hasCachedHelpMessage = function () {
    return !!cachedHelpMessage;
  };
  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    let groupedKeys = [];
    let toCheck = null;
    Object.keys(groups).forEach((group) => {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach((key) => {
      toCheck = [key].concat(aliases[key]);
      if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }
  function filterHiddenOptions(key) {
    return (
      yargs.getOptions().hiddenOptions.indexOf(key) < 0 ||
      yargs.parsed.argv[yargs.getOptions().showHiddenOpt]
    );
  }
  self2.showHelp = (level) => {
    const logger3 = yargs.getInternalMethods().getLoggerInstance();
    if (!level) level = 'error';
    const emit = typeof level === 'function' ? level : logger3[level];
    emit(self2.help());
  };
  self2.functionDescription = (fn) => {
    const description = fn.name ? shim3.Parser.decamelize(fn.name, '-') : __('generated-value');
    return ['(', description, ')'].join('');
  };
  self2.stringifiedValues = function stringifiedValues(values, separator) {
    let string = '';
    const sep = separator || ', ';
    const array = [].concat(values);
    if (!values || !array.length) return string;
    array.forEach((value) => {
      if (string.length) string += sep;
      string += JSON.stringify(value);
    });
    return string;
  };
  function defaultString(value, defaultDescription) {
    let string = `[${__('default:')} `;
    if (value === undefined && !defaultDescription) return null;
    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (typeof value) {
        case 'string':
          string += `"${value}"`;
          break;
        case 'object':
          string += JSON.stringify(value);
          break;
        default:
          string += value;
      }
    }
    return `${string}]`;
  }
  function windowWidth() {
    const maxWidth2 = 80;
    if (shim3.process.stdColumns) {
      return Math.min(maxWidth2, shim3.process.stdColumns);
    } else {
      return maxWidth2;
    }
  }
  let version = null;
  self2.version = (ver) => {
    version = ver;
  };
  self2.showVersion = (level) => {
    const logger3 = yargs.getInternalMethods().getLoggerInstance();
    if (!level) level = 'error';
    const emit = typeof level === 'function' ? level : logger3[level];
    emit(version);
  };
  self2.reset = function reset(localLookup) {
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = objFilter(descriptions, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      failMessage,
      failureOutput,
      usages,
      usageDisabled,
      epilogs,
      examples,
      commands,
      descriptions,
    });
  };
  self2.unfreeze = function unfreeze(defaultCommand = false) {
    const frozen = frozens.pop();
    if (!frozen) return;
    if (defaultCommand) {
      descriptions = { ...frozen.descriptions, ...descriptions };
      commands = [...frozen.commands, ...commands];
      usages = [...frozen.usages, ...usages];
      examples = [...frozen.examples, ...examples];
      epilogs = [...frozen.epilogs, ...epilogs];
    } else {
      ({
        failMessage,
        failureOutput,
        usages,
        usageDisabled,
        epilogs,
        examples,
        commands,
        descriptions,
      } = frozen);
    }
  };
  return self2;
}
function isIndentedText(text) {
  return typeof text === 'object';
}
function addIndentation(text, indent) {
  return isIndentedText(text)
    ? { text: text.text, indentation: text.indentation + indent }
    : { text, indentation: indent };
}
function getIndentation(text) {
  return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) {
  return isIndentedText(text) ? text.text : text;
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/completion-templates.js
var completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
var completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/completion.js
class Completion {
  constructor(yargs, usage2, command2, shim3) {
    var _a2, _b2, _c2;
    this.yargs = yargs;
    this.usage = usage2;
    this.command = command2;
    this.shim = shim3;
    this.completionKey = 'get-yargs-completions';
    this.aliases = null;
    this.customCompletionFunction = null;
    this.indexAfterLastReset = 0;
    this.zshShell =
      (_c2 =
        ((_a2 = this.shim.getEnv('SHELL')) === null || _a2 === undefined
          ? undefined
          : _a2.includes('zsh')) ||
        ((_b2 = this.shim.getEnv('ZSH_NAME')) === null || _b2 === undefined
          ? undefined
          : _b2.includes('zsh'))) !== null && _c2 !== undefined
        ? _c2
        : false;
  }
  defaultCompletion(args, argv, current, done) {
    const handlers = this.command.getCommandHandlers();
    for (let i = 0, ii = args.length; i < ii; ++i) {
      if (handlers[args[i]] && handlers[args[i]].builder) {
        const builder = handlers[args[i]].builder;
        if (isCommandBuilderCallback(builder)) {
          this.indexAfterLastReset = i + 1;
          const y = this.yargs.getInternalMethods().reset();
          builder(y, true);
          return y.argv;
        }
      }
    }
    const completions = [];
    this.commandCompletions(completions, args, current);
    this.optionCompletions(completions, args, argv, current);
    this.choicesFromOptionsCompletions(completions, args, argv, current);
    this.choicesFromPositionalsCompletions(completions, args, argv, current);
    done(null, completions);
  }
  commandCompletions(completions, args, current) {
    const parentCommands = this.yargs.getInternalMethods().getContext().commands;
    if (
      !current.match(/^-/) &&
      parentCommands[parentCommands.length - 1] !== current &&
      !this.previousArgHasChoices(args)
    ) {
      this.usage.getCommands().forEach((usageCommand) => {
        const commandName = parseCommand(usageCommand[0]).cmd;
        if (args.indexOf(commandName) === -1) {
          if (!this.zshShell) {
            completions.push(commandName);
          } else {
            const desc = usageCommand[1] || '';
            completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
          }
        }
      });
    }
  }
  optionCompletions(completions, args, argv, current) {
    if (
      (current.match(/^-/) || (current === '' && completions.length === 0)) &&
      !this.previousArgHasChoices(args)
    ) {
      const options = this.yargs.getOptions();
      const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
      Object.keys(options.key).forEach((key) => {
        const negable =
          !!options.configuration['boolean-negation'] && options.boolean.includes(key);
        const isPositionalKey = positionalKeys.includes(key);
        if (
          !isPositionalKey &&
          !options.hiddenOptions.includes(key) &&
          !this.argsContainKey(args, key, negable)
        ) {
          this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
        }
      });
    }
  }
  choicesFromOptionsCompletions(completions, args, argv, current) {
    if (this.previousArgHasChoices(args)) {
      const choices = this.getPreviousArgChoices(args);
      if (choices && choices.length > 0) {
        completions.push(...choices.map((c) => c.replace(/:/g, '\\:')));
      }
    }
  }
  choicesFromPositionalsCompletions(completions, args, argv, current) {
    if (current === '' && completions.length > 0 && this.previousArgHasChoices(args)) {
      return;
    }
    const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
    const offset = Math.max(
      this.indexAfterLastReset,
      this.yargs.getInternalMethods().getContext().commands.length + 1
    );
    const positionalKey = positionalKeys[argv._.length - offset - 1];
    if (!positionalKey) {
      return;
    }
    const choices = this.yargs.getOptions().choices[positionalKey] || [];
    for (const choice of choices) {
      if (choice.startsWith(current)) {
        completions.push(choice.replace(/:/g, '\\:'));
      }
    }
  }
  getPreviousArgChoices(args) {
    if (args.length < 1) return;
    let previousArg = args[args.length - 1];
    let filter = '';
    if (!previousArg.startsWith('-') && args.length > 1) {
      filter = previousArg;
      previousArg = args[args.length - 2];
    }
    if (!previousArg.startsWith('-')) return;
    const previousArgKey = previousArg.replace(/^-+/, '');
    const options = this.yargs.getOptions();
    const possibleAliases = [previousArgKey, ...(this.yargs.getAliases()[previousArgKey] || [])];
    let choices;
    for (const possibleAlias of possibleAliases) {
      if (
        Object.prototype.hasOwnProperty.call(options.key, possibleAlias) &&
        Array.isArray(options.choices[possibleAlias])
      ) {
        choices = options.choices[possibleAlias];
        break;
      }
    }
    if (choices) {
      return choices.filter((choice) => !filter || choice.startsWith(filter));
    }
  }
  previousArgHasChoices(args) {
    const choices = this.getPreviousArgChoices(args);
    return choices !== undefined && choices.length > 0;
  }
  argsContainKey(args, key, negable) {
    const argsContains = (s) => args.indexOf((/^[^0-9]$/.test(s) ? '-' : '--') + s) !== -1;
    if (argsContains(key)) return true;
    if (negable && argsContains(`no-${key}`)) return true;
    if (this.aliases) {
      for (const alias of this.aliases[key]) {
        if (argsContains(alias)) return true;
      }
    }
    return false;
  }
  completeOptionKey(key, completions, current, negable) {
    var _a2, _b2, _c2, _d;
    let keyWithDesc = key;
    if (this.zshShell) {
      const descs = this.usage.getDescriptions();
      const aliasKey =
        (_b2 =
          (_a2 = this === null || this === undefined ? undefined : this.aliases) === null ||
          _a2 === undefined
            ? undefined
            : _a2[key]) === null || _b2 === undefined
          ? undefined
          : _b2.find((alias) => {
              const desc2 = descs[alias];
              return typeof desc2 === 'string' && desc2.length > 0;
            });
      const descFromAlias = aliasKey ? descs[aliasKey] : undefined;
      const desc =
        (_d = (_c2 = descs[key]) !== null && _c2 !== undefined ? _c2 : descFromAlias) !== null &&
        _d !== undefined
          ? _d
          : '';
      keyWithDesc = `${key.replace(/:/g, '\\:')}:${desc.replace('__yargsString__:', '').replace(/(\r\n|\n|\r)/gm, ' ')}`;
    }
    const startsByTwoDashes = (s) => /^--/.test(s);
    const isShortOption = (s) => /^[^0-9]$/.test(s);
    const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
    completions.push(dashes + keyWithDesc);
    if (negable) {
      completions.push(dashes + 'no-' + keyWithDesc);
    }
  }
  customCompletion(args, argv, current, done) {
    assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
    if (isSyncCompletionFunction(this.customCompletionFunction)) {
      const result = this.customCompletionFunction(current, argv);
      if (isPromise(result)) {
        return result
          .then((list) => {
            this.shim.process.nextTick(() => {
              done(null, list);
            });
          })
          .catch((err) => {
            this.shim.process.nextTick(() => {
              done(err, undefined);
            });
          });
      }
      return done(null, result);
    } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
      return this.customCompletionFunction(
        current,
        argv,
        (onCompleted = done) => this.defaultCompletion(args, argv, current, onCompleted),
        (completions) => {
          done(null, completions);
        }
      );
    } else {
      return this.customCompletionFunction(current, argv, (completions) => {
        done(null, completions);
      });
    }
  }
  getCompletion(args, done) {
    const current = args.length ? args[args.length - 1] : '';
    const argv = this.yargs.parse(args, true);
    const completionFunction = this.customCompletionFunction
      ? (argv2) => this.customCompletion(args, argv2, current, done)
      : (argv2) => this.defaultCompletion(args, argv2, current, done);
    return isPromise(argv) ? argv.then(completionFunction) : completionFunction(argv);
  }
  generateCompletionScript($0, cmd) {
    let script = this.zshShell ? completionZshTemplate : completionShTemplate;
    const name = this.shim.path.basename($0);
    if ($0.match(/\.js$/)) $0 = `./${$0}`;
    script = script.replace(/{{app_name}}/g, name);
    script = script.replace(/{{completion_command}}/g, cmd);
    return script.replace(/{{app_path}}/g, $0);
  }
  registerFunction(fn) {
    this.customCompletionFunction = fn;
  }
  setParsed(parsed) {
    this.aliases = parsed.aliases;
  }
}
function completion(yargs, usage2, command2, shim3) {
  return new Completion(yargs, usage2, command2, shim3);
}
function isSyncCompletionFunction(completionFunction) {
  return completionFunction.length < 3;
}
function isFallbackCompletionFunction(completionFunction) {
  return completionFunction.length > 3;
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/utils/levenshtein.js
function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  const matrix = [];
  let i;
  for (i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  let j;
  for (j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (i = 1; i <= b.length; i++) {
    for (j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        if (
          i > 1 &&
          j > 1 &&
          b.charAt(i - 2) === a.charAt(j - 1) &&
          b.charAt(i - 1) === a.charAt(j - 2)
        ) {
          matrix[i][j] = matrix[i - 2][j - 2] + 1;
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1)
          );
        }
      }
    }
  }
  return matrix[b.length][a.length];
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/validation.js
var specialKeys = ['$0', '--', '_'];
function validation(yargs, usage2, shim3) {
  const __ = shim3.y18n.__;
  const __n = shim3.y18n.__n;
  const self2 = {};
  self2.nonOptionCount = function nonOptionCount(argv) {
    const demandedCommands = yargs.getDemandedCommands();
    const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== undefined) {
          usage2.fail(
            demandedCommands._.minMsg
              ? demandedCommands._.minMsg
                  .replace(/\$0/g, _s.toString())
                  .replace(/\$1/, demandedCommands._.min.toString())
              : null
          );
        } else {
          usage2.fail(
            __n(
              'Not enough non-option arguments: got %s, need at least %s',
              'Not enough non-option arguments: got %s, need at least %s',
              _s,
              _s.toString(),
              demandedCommands._.min.toString()
            )
          );
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== undefined) {
          usage2.fail(
            demandedCommands._.maxMsg
              ? demandedCommands._.maxMsg
                  .replace(/\$0/g, _s.toString())
                  .replace(/\$1/, demandedCommands._.max.toString())
              : null
          );
        } else {
          usage2.fail(
            __n(
              'Too many non-option arguments: got %s, maximum of %s',
              'Too many non-option arguments: got %s, maximum of %s',
              _s,
              _s.toString(),
              demandedCommands._.max.toString()
            )
          );
        }
      }
    }
  };
  self2.positionalCount = function positionalCount(required, observed) {
    if (observed < required) {
      usage2.fail(
        __n(
          'Not enough non-option arguments: got %s, need at least %s',
          'Not enough non-option arguments: got %s, need at least %s',
          observed,
          observed + '',
          required + ''
        )
      );
    }
  };
  self2.requiredArguments = function requiredArguments(argv, demandedOptions) {
    let missing = null;
    for (const key of Object.keys(demandedOptions)) {
      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {
        missing = missing || {};
        missing[key] = demandedOptions[key];
      }
    }
    if (missing) {
      const customMsgs = [];
      for (const key of Object.keys(missing)) {
        const msg = missing[key];
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }
      const customMsg = customMsgs.length
        ? `
${customMsgs.join(`
`)}`
        : '';
      usage2.fail(
        __n(
          'Missing required argument: %s',
          'Missing required arguments: %s',
          Object.keys(missing).length,
          Object.keys(missing).join(', ') + customMsg
        )
      );
    }
  };
  self2.unknownArguments = function unknownArguments(
    argv,
    aliases,
    positionalMap,
    isDefaultCommand,
    checkPositionals = true
  ) {
    var _a2;
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    Object.keys(argv).forEach((key) => {
      if (
        !specialKeys.includes(key) &&
        !Object.prototype.hasOwnProperty.call(positionalMap, key) &&
        !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) &&
        !self2.isValidAndSomeAliasIsNotNew(key, aliases)
      ) {
        unknown.push(key);
      }
    });
    if (
      checkPositionals &&
      (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)
    ) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes('' + key)) {
          unknown.push('' + key);
        }
      });
    }
    if (checkPositionals) {
      const demandedCommands = yargs.getDemandedCommands();
      const maxNonOptDemanded =
        ((_a2 = demandedCommands._) === null || _a2 === undefined ? undefined : _a2.max) || 0;
      const expected = currentContext.commands.length + maxNonOptDemanded;
      if (expected < argv._.length) {
        argv._.slice(expected).forEach((key) => {
          key = String(key);
          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
            unknown.push(key);
          }
        });
      }
    }
    if (unknown.length) {
      usage2.fail(
        __n(
          'Unknown argument: %s',
          'Unknown arguments: %s',
          unknown.length,
          unknown.map((s) => (s.trim() ? s : `"${s}"`)).join(', ')
        )
      );
    }
  };
  self2.unknownCommands = function unknownCommands(argv) {
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes('' + key)) {
          unknown.push('' + key);
        }
      });
    }
    if (unknown.length > 0) {
      usage2.fail(
        __n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', '))
      );
      return true;
    } else {
      return false;
    }
  };
  self2.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }
    const newAliases = yargs.parsed.newAliases;
    return [key, ...aliases[key]].some(
      (a) => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]
    );
  };
  self2.limitedChoices = function limitedChoices(argv) {
    const options = yargs.getOptions();
    const invalid = {};
    if (!Object.keys(options.choices).length) return;
    Object.keys(argv).forEach((key) => {
      if (
        specialKeys.indexOf(key) === -1 &&
        Object.prototype.hasOwnProperty.call(options.choices, key)
      ) {
        [].concat(argv[key]).forEach((value) => {
          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {
            invalid[key] = (invalid[key] || []).concat(value);
          }
        });
      }
    });
    const invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length) return;
    let msg = __('Invalid values:');
    invalidKeys.forEach((key) => {
      msg += `
  ${__('Argument: %s, Given: %s, Choices: %s', key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
    });
    usage2.fail(msg);
  };
  let implied = {};
  self2.implies = function implies(key, value) {
    argsert('<string|object> [array|number|string]', [key, value], arguments.length);
    if (typeof key === 'object') {
      Object.keys(key).forEach((k) => {
        self2.implies(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!implied[key]) {
        implied[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self2.implies(key, i));
      } else {
        assertNotStrictEqual(value, undefined, shim3);
        implied[key].push(value);
      }
    }
  };
  self2.getImplied = function getImplied() {
    return implied;
  };
  function keyExists(argv, val) {
    const num = Number(val);
    val = isNaN(num) ? val : num;
    if (typeof val === 'number') {
      val = argv._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      val = val.match(/^--no-(.+)/)[1];
      val = !Object.prototype.hasOwnProperty.call(argv, val);
    } else {
      val = Object.prototype.hasOwnProperty.call(argv, val);
    }
    return val;
  }
  self2.implications = function implications(argv) {
    const implyFail = [];
    Object.keys(implied).forEach((key) => {
      const origKey = key;
      (implied[key] || []).forEach((value) => {
        let key2 = origKey;
        const origValue = value;
        key2 = keyExists(argv, key2);
        value = keyExists(argv, value);
        if (key2 && !value) {
          implyFail.push(` ${origKey} -> ${origValue}`);
        }
      });
    });
    if (implyFail.length) {
      let msg = `${__('Implications failed:')}
`;
      implyFail.forEach((value) => {
        msg += value;
      });
      usage2.fail(msg);
    }
  };
  let conflicting = {};
  self2.conflicts = function conflicts(key, value) {
    argsert('<string|object> [array|string]', [key, value], arguments.length);
    if (typeof key === 'object') {
      Object.keys(key).forEach((k) => {
        self2.conflicts(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!conflicting[key]) {
        conflicting[key] = [];
      }
      if (Array.isArray(value)) {
        value.forEach((i) => self2.conflicts(key, i));
      } else {
        conflicting[key].push(value);
      }
    }
  };
  self2.getConflicting = () => conflicting;
  self2.conflicting = function conflictingFn(argv) {
    Object.keys(argv).forEach((key) => {
      if (conflicting[key]) {
        conflicting[key].forEach((value) => {
          if (value && argv[key] !== undefined && argv[value] !== undefined) {
            usage2.fail(__('Arguments %s and %s are mutually exclusive', key, value));
          }
        });
      }
    });
    if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {
      Object.keys(conflicting).forEach((key) => {
        conflicting[key].forEach((value) => {
          if (
            value &&
            argv[shim3.Parser.camelCase(key)] !== undefined &&
            argv[shim3.Parser.camelCase(value)] !== undefined
          ) {
            usage2.fail(__('Arguments %s and %s are mutually exclusive', key, value));
          }
        });
      });
    }
  };
  self2.recommendCommands = function recommendCommands(cmd, potentialCommands) {
    const threshold = 3;
    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
    let recommended = null;
    let bestDistance = Infinity;
    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {
      const d = levenshtein(cmd, candidate);
      if (d <= threshold && d < bestDistance) {
        bestDistance = d;
        recommended = candidate;
      }
    }
    if (recommended) usage2.fail(__('Did you mean %s?', recommended));
  };
  self2.reset = function reset(localLookup) {
    implied = objFilter(implied, (k) => !localLookup[k]);
    conflicting = objFilter(conflicting, (k) => !localLookup[k]);
    return self2;
  };
  const frozens = [];
  self2.freeze = function freeze() {
    frozens.push({
      implied,
      conflicting,
    });
  };
  self2.unfreeze = function unfreeze() {
    const frozen = frozens.pop();
    assertNotStrictEqual(frozen, undefined, shim3);
    ({ implied, conflicting } = frozen);
  };
  return self2;
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/build/lib/yargs-factory.js
var __classPrivateFieldSet2 = function (receiver, state, value, kind, f) {
  if (kind === 'm') throw new TypeError('Private method is not writable');
  if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a setter');
  if (typeof state === 'function' ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError('Cannot write private member to an object whose class did not declare it');
  return (
    kind === 'a' ? f.call(receiver, value) : f ? (f.value = value) : state.set(receiver, value),
    value
  );
};
var __classPrivateFieldGet2 = function (receiver, state, kind, f) {
  if (kind === 'a' && !f) throw new TypeError('Private accessor was defined without a getter');
  if (typeof state === 'function' ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError('Cannot read private member from an object whose class did not declare it');
  return kind === 'm' ? f : kind === 'a' ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _YargsInstance_command;
var _YargsInstance_cwd;
var _YargsInstance_context;
var _YargsInstance_completion;
var _YargsInstance_completionCommand;
var _YargsInstance_defaultShowHiddenOpt;
var _YargsInstance_exitError;
var _YargsInstance_detectLocale;
var _YargsInstance_emittedWarnings;
var _YargsInstance_exitProcess;
var _YargsInstance_frozens;
var _YargsInstance_globalMiddleware;
var _YargsInstance_groups;
var _YargsInstance_hasOutput;
var _YargsInstance_helpOpt;
var _YargsInstance_isGlobalContext;
var _YargsInstance_logger;
var _YargsInstance_output;
var _YargsInstance_options;
var _YargsInstance_parentRequire;
var _YargsInstance_parserConfig;
var _YargsInstance_parseFn;
var _YargsInstance_parseContext;
var _YargsInstance_pkgs;
var _YargsInstance_preservedGroups;
var _YargsInstance_processArgs;
var _YargsInstance_recommendCommands;
var _YargsInstance_shim;
var _YargsInstance_strict;
var _YargsInstance_strictCommands;
var _YargsInstance_strictOptions;
var _YargsInstance_usage;
var _YargsInstance_usageConfig;
var _YargsInstance_versionOpt;
var _YargsInstance_validation;
function YargsFactory(_shim) {
  return (processArgs = [], cwd = _shim.process.cwd(), parentRequire) => {
    const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
    Object.defineProperty(yargs, 'argv', {
      get: () => {
        return yargs.parse();
      },
      enumerable: true,
    });
    yargs.help();
    yargs.version();
    return yargs;
  };
}
var kCopyDoubleDash = Symbol('copyDoubleDash');
var kCreateLogger = Symbol('copyDoubleDash');
var kDeleteFromParserHintObject = Symbol('deleteFromParserHintObject');
var kEmitWarning = Symbol('emitWarning');
var kFreeze = Symbol('freeze');
var kGetDollarZero = Symbol('getDollarZero');
var kGetParserConfiguration = Symbol('getParserConfiguration');
var kGetUsageConfiguration = Symbol('getUsageConfiguration');
var kGuessLocale = Symbol('guessLocale');
var kGuessVersion = Symbol('guessVersion');
var kParsePositionalNumbers = Symbol('parsePositionalNumbers');
var kPkgUp = Symbol('pkgUp');
var kPopulateParserHintArray = Symbol('populateParserHintArray');
var kPopulateParserHintSingleValueDictionary = Symbol('populateParserHintSingleValueDictionary');
var kPopulateParserHintArrayDictionary = Symbol('populateParserHintArrayDictionary');
var kPopulateParserHintDictionary = Symbol('populateParserHintDictionary');
var kSanitizeKey = Symbol('sanitizeKey');
var kSetKey = Symbol('setKey');
var kUnfreeze = Symbol('unfreeze');
var kValidateAsync = Symbol('validateAsync');
var kGetCommandInstance = Symbol('getCommandInstance');
var kGetContext = Symbol('getContext');
var kGetHasOutput = Symbol('getHasOutput');
var kGetLoggerInstance = Symbol('getLoggerInstance');
var kGetParseContext = Symbol('getParseContext');
var kGetUsageInstance = Symbol('getUsageInstance');
var kGetValidationInstance = Symbol('getValidationInstance');
var kHasParseCallback = Symbol('hasParseCallback');
var kIsGlobalContext = Symbol('isGlobalContext');
var kPostProcess = Symbol('postProcess');
var kRebase = Symbol('rebase');
var kReset = Symbol('reset');
var kRunYargsParserAndExecuteCommands = Symbol('runYargsParserAndExecuteCommands');
var kRunValidation = Symbol('runValidation');
var kSetHasOutput = Symbol('setHasOutput');
var kTrackManuallySetKeys = Symbol('kTrackManuallySetKeys');

class YargsInstance {
  constructor(processArgs = [], cwd, parentRequire, shim3) {
    this.customScriptName = false;
    this.parsed = false;
    _YargsInstance_command.set(this, undefined);
    _YargsInstance_cwd.set(this, undefined);
    _YargsInstance_context.set(this, { commands: [], fullCommands: [] });
    _YargsInstance_completion.set(this, null);
    _YargsInstance_completionCommand.set(this, null);
    _YargsInstance_defaultShowHiddenOpt.set(this, 'show-hidden');
    _YargsInstance_exitError.set(this, null);
    _YargsInstance_detectLocale.set(this, true);
    _YargsInstance_emittedWarnings.set(this, {});
    _YargsInstance_exitProcess.set(this, true);
    _YargsInstance_frozens.set(this, []);
    _YargsInstance_globalMiddleware.set(this, undefined);
    _YargsInstance_groups.set(this, {});
    _YargsInstance_hasOutput.set(this, false);
    _YargsInstance_helpOpt.set(this, null);
    _YargsInstance_isGlobalContext.set(this, true);
    _YargsInstance_logger.set(this, undefined);
    _YargsInstance_output.set(this, '');
    _YargsInstance_options.set(this, undefined);
    _YargsInstance_parentRequire.set(this, undefined);
    _YargsInstance_parserConfig.set(this, {});
    _YargsInstance_parseFn.set(this, null);
    _YargsInstance_parseContext.set(this, null);
    _YargsInstance_pkgs.set(this, {});
    _YargsInstance_preservedGroups.set(this, {});
    _YargsInstance_processArgs.set(this, undefined);
    _YargsInstance_recommendCommands.set(this, false);
    _YargsInstance_shim.set(this, undefined);
    _YargsInstance_strict.set(this, false);
    _YargsInstance_strictCommands.set(this, false);
    _YargsInstance_strictOptions.set(this, false);
    _YargsInstance_usage.set(this, undefined);
    _YargsInstance_usageConfig.set(this, {});
    _YargsInstance_versionOpt.set(this, null);
    _YargsInstance_validation.set(this, undefined);
    __classPrivateFieldSet2(this, _YargsInstance_shim, shim3, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_processArgs, processArgs, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_cwd, cwd, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_parentRequire, parentRequire, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), 'f');
    this.$0 = this[kGetDollarZero]();
    this[kReset]();
    __classPrivateFieldSet2(
      this,
      _YargsInstance_command,
      __classPrivateFieldGet2(this, _YargsInstance_command, 'f'),
      'f'
    );
    __classPrivateFieldSet2(
      this,
      _YargsInstance_usage,
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f'),
      'f'
    );
    __classPrivateFieldSet2(
      this,
      _YargsInstance_validation,
      __classPrivateFieldGet2(this, _YargsInstance_validation, 'f'),
      'f'
    );
    __classPrivateFieldSet2(
      this,
      _YargsInstance_options,
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f'),
      'f'
    );
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').showHiddenOpt =
      __classPrivateFieldGet2(this, _YargsInstance_defaultShowHiddenOpt, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_logger, this[kCreateLogger](), 'f');
  }
  addHelpOpt(opt, msg) {
    const defaultHelpOpt = 'help';
    argsert('[string|boolean] [string]', [opt, msg], arguments.length);
    if (__classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f')) {
      this[kDeleteFromParserHintObject](__classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f'));
      __classPrivateFieldSet2(this, _YargsInstance_helpOpt, null, 'f');
    }
    if (opt === false && msg === undefined) return this;
    __classPrivateFieldSet2(
      this,
      _YargsInstance_helpOpt,
      typeof opt === 'string' ? opt : defaultHelpOpt,
      'f'
    );
    this.boolean(__classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f'));
    this.describe(
      __classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f'),
      msg || __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').deferY18nLookup('Show help')
    );
    return this;
  }
  help(opt, msg) {
    return this.addHelpOpt(opt, msg);
  }
  addShowHiddenOpt(opt, msg) {
    argsert('[string|boolean] [string]', [opt, msg], arguments.length);
    if (opt === false && msg === undefined) return this;
    const showHiddenOpt =
      typeof opt === 'string'
        ? opt
        : __classPrivateFieldGet2(this, _YargsInstance_defaultShowHiddenOpt, 'f');
    this.boolean(showHiddenOpt);
    this.describe(
      showHiddenOpt,
      msg ||
        __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').deferY18nLookup(
          'Show hidden options'
        )
    );
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').showHiddenOpt = showHiddenOpt;
    return this;
  }
  showHidden(opt, msg) {
    return this.addShowHiddenOpt(opt, msg);
  }
  alias(key, value) {
    argsert('<object|string|array> [string|array]', [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.alias.bind(this), 'alias', key, value);
    return this;
  }
  array(keys) {
    argsert('<array|string>', [keys], arguments.length);
    this[kPopulateParserHintArray]('array', keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  boolean(keys) {
    argsert('<array|string>', [keys], arguments.length);
    this[kPopulateParserHintArray]('boolean', keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  check(f, global3) {
    argsert('<function> [boolean]', [f, global3], arguments.length);
    this.middleware(
      (argv, _yargs) => {
        return maybeAsyncResult(
          () => {
            return f(argv, _yargs.getOptions());
          },
          (result) => {
            if (!result) {
              __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').fail(
                __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').y18n.__(
                  'Argument check failed: %s',
                  f.toString()
                )
              );
            } else if (typeof result === 'string' || result instanceof Error) {
              __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').fail(
                result.toString(),
                result
              );
            }
            return argv;
          },
          (err) => {
            __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').fail(
              err.message ? err.message : err.toString(),
              err
            );
            return argv;
          }
        );
      },
      false,
      global3
    );
    return this;
  }
  choices(key, value) {
    argsert('<object|string|array> [string|array]', [key, value], arguments.length);
    this[kPopulateParserHintArrayDictionary](this.choices.bind(this), 'choices', key, value);
    return this;
  }
  coerce(keys, value) {
    argsert('<object|string|array> [function]', [keys, value], arguments.length);
    if (Array.isArray(keys)) {
      if (!value) {
        throw new YError('coerce callback must be provided');
      }
      for (const key of keys) {
        this.coerce(key, value);
      }
      return this;
    } else if (typeof keys === 'object') {
      for (const key of Object.keys(keys)) {
        this.coerce(key, keys[key]);
      }
      return this;
    }
    if (!value) {
      throw new YError('coerce callback must be provided');
    }
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').key[keys] = true;
    __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').addCoerceMiddleware(
      (argv, yargs) => {
        let aliases;
        const shouldCoerce = Object.prototype.hasOwnProperty.call(argv, keys);
        if (!shouldCoerce) {
          return argv;
        }
        return maybeAsyncResult(
          () => {
            aliases = yargs.getAliases();
            return value(argv[keys]);
          },
          (result) => {
            argv[keys] = result;
            const stripAliased = yargs.getInternalMethods().getParserConfiguration()[
              'strip-aliased'
            ];
            if (aliases[keys] && stripAliased !== true) {
              for (const alias of aliases[keys]) {
                argv[alias] = result;
              }
            }
            return argv;
          },
          (err) => {
            throw new YError(err.message);
          }
        );
      },
      keys
    );
    return this;
  }
  conflicts(key1, key2) {
    argsert('<string|object> [string|array]', [key1, key2], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').conflicts(key1, key2);
    return this;
  }
  config(key = 'config', msg, parseFn) {
    argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);
    if (typeof key === 'object' && !Array.isArray(key)) {
      key = applyExtends(
        key,
        __classPrivateFieldGet2(this, _YargsInstance_cwd, 'f'),
        this[kGetParserConfiguration]()['deep-merge-config'] || false,
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
      );
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configObjects = (
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configObjects || []
      ).concat(key);
      return this;
    }
    if (typeof msg === 'function') {
      parseFn = msg;
      msg = undefined;
    }
    this.describe(
      key,
      msg ||
        __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').deferY18nLookup(
          'Path to JSON config file'
        )
    );
    (Array.isArray(key) ? key : [key]).forEach((k) => {
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').config[k] = parseFn || true;
    });
    return this;
  }
  completion(cmd, desc, fn) {
    argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);
    if (typeof desc === 'function') {
      fn = desc;
      desc = undefined;
    }
    __classPrivateFieldSet2(
      this,
      _YargsInstance_completionCommand,
      cmd || __classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f') || 'completion',
      'f'
    );
    if (!desc && desc !== false) {
      desc = 'generate completion script';
    }
    this.command(__classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f'), desc);
    if (fn) __classPrivateFieldGet2(this, _YargsInstance_completion, 'f').registerFunction(fn);
    return this;
  }
  command(cmd, description, builder, handler, middlewares, deprecated) {
    argsert(
      '<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]',
      [cmd, description, builder, handler, middlewares, deprecated],
      arguments.length
    );
    __classPrivateFieldGet2(this, _YargsInstance_command, 'f').addHandler(
      cmd,
      description,
      builder,
      handler,
      middlewares,
      deprecated
    );
    return this;
  }
  commands(cmd, description, builder, handler, middlewares, deprecated) {
    return this.command(cmd, description, builder, handler, middlewares, deprecated);
  }
  commandDir(dir, opts) {
    argsert('<string> [object]', [dir, opts], arguments.length);
    const req =
      __classPrivateFieldGet2(this, _YargsInstance_parentRequire, 'f') ||
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').require;
    __classPrivateFieldGet2(this, _YargsInstance_command, 'f').addDirectory(
      dir,
      req,
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getCallerFile(),
      opts
    );
    return this;
  }
  count(keys) {
    argsert('<array|string>', [keys], arguments.length);
    this[kPopulateParserHintArray]('count', keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  default(key, value, defaultDescription) {
    argsert(
      '<object|string|array> [*] [string]',
      [key, value, defaultDescription],
      arguments.length
    );
    if (defaultDescription) {
      assertSingleKey(key, __classPrivateFieldGet2(this, _YargsInstance_shim, 'f'));
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').defaultDescription[key] =
        defaultDescription;
    }
    if (typeof value === 'function') {
      assertSingleKey(key, __classPrivateFieldGet2(this, _YargsInstance_shim, 'f'));
      if (!__classPrivateFieldGet2(this, _YargsInstance_options, 'f').defaultDescription[key])
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f').defaultDescription[key] =
          __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').functionDescription(value);
      value = value.call();
    }
    this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), 'default', key, value);
    return this;
  }
  defaults(key, value, defaultDescription) {
    return this.default(key, value, defaultDescription);
  }
  demandCommand(min = 1, max, minMsg, maxMsg) {
    argsert(
      '[number] [number|string] [string|null|undefined] [string|null|undefined]',
      [min, max, minMsg, maxMsg],
      arguments.length
    );
    if (typeof max !== 'number') {
      minMsg = max;
      max = Infinity;
    }
    this.global('_', false);
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').demandedCommands._ = {
      min,
      max,
      minMsg,
      maxMsg,
    };
    return this;
  }
  demand(keys, max, msg) {
    if (Array.isArray(max)) {
      max.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet2(this, _YargsInstance_shim, 'f'));
        this.demandOption(key, msg);
      });
      max = Infinity;
    } else if (typeof max !== 'number') {
      msg = max;
      max = Infinity;
    }
    if (typeof keys === 'number') {
      assertNotStrictEqual(msg, true, __classPrivateFieldGet2(this, _YargsInstance_shim, 'f'));
      this.demandCommand(keys, max, msg, msg);
    } else if (Array.isArray(keys)) {
      keys.forEach((key) => {
        assertNotStrictEqual(msg, true, __classPrivateFieldGet2(this, _YargsInstance_shim, 'f'));
        this.demandOption(key, msg);
      });
    } else {
      if (typeof msg === 'string') {
        this.demandOption(keys, msg);
      } else if (msg === true || typeof msg === 'undefined') {
        this.demandOption(keys);
      }
    }
    return this;
  }
  demandOption(keys, msg) {
    argsert('<object|string|array> [string]', [keys, msg], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](
      this.demandOption.bind(this),
      'demandedOptions',
      keys,
      msg
    );
    return this;
  }
  deprecateOption(option, message) {
    argsert('<string> [string|boolean]', [option, message], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').deprecatedOptions[option] = message;
    return this;
  }
  describe(keys, description) {
    argsert('<object|string|array> [string]', [keys, description], arguments.length);
    this[kSetKey](keys, true);
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').describe(keys, description);
    return this;
  }
  detectLocale(detect) {
    argsert('<boolean>', [detect], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_detectLocale, detect, 'f');
    return this;
  }
  env(prefix) {
    argsert('[string|boolean]', [prefix], arguments.length);
    if (prefix === false)
      delete __classPrivateFieldGet2(this, _YargsInstance_options, 'f').envPrefix;
    else __classPrivateFieldGet2(this, _YargsInstance_options, 'f').envPrefix = prefix || '';
    return this;
  }
  epilogue(msg) {
    argsert('<string>', [msg], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').epilog(msg);
    return this;
  }
  epilog(msg) {
    return this.epilogue(msg);
  }
  example(cmd, description) {
    argsert('<string|array> [string]', [cmd, description], arguments.length);
    if (Array.isArray(cmd)) {
      cmd.forEach((exampleParams) => this.example(...exampleParams));
    } else {
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').example(cmd, description);
    }
    return this;
  }
  exit(code, err) {
    __classPrivateFieldSet2(this, _YargsInstance_hasOutput, true, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_exitError, err, 'f');
    if (__classPrivateFieldGet2(this, _YargsInstance_exitProcess, 'f'))
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').process.exit(code);
  }
  exitProcess(enabled = true) {
    argsert('[boolean]', [enabled], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_exitProcess, enabled, 'f');
    return this;
  }
  fail(f) {
    argsert('<function|boolean>', [f], arguments.length);
    if (typeof f === 'boolean' && f !== false) {
      throw new YError("Invalid first argument. Expected function or boolean 'false'");
    }
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').failFn(f);
    return this;
  }
  getAliases() {
    return this.parsed ? this.parsed.aliases : {};
  }
  async getCompletion(args, done) {
    argsert('<array> [function]', [args, done], arguments.length);
    if (!done) {
      return new Promise((resolve11, reject) => {
        __classPrivateFieldGet2(this, _YargsInstance_completion, 'f').getCompletion(
          args,
          (err, completions) => {
            if (err) reject(err);
            else resolve11(completions);
          }
        );
      });
    } else {
      return __classPrivateFieldGet2(this, _YargsInstance_completion, 'f').getCompletion(
        args,
        done
      );
    }
  }
  getDemandedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet2(this, _YargsInstance_options, 'f').demandedOptions;
  }
  getDemandedCommands() {
    argsert([], 0);
    return __classPrivateFieldGet2(this, _YargsInstance_options, 'f').demandedCommands;
  }
  getDeprecatedOptions() {
    argsert([], 0);
    return __classPrivateFieldGet2(this, _YargsInstance_options, 'f').deprecatedOptions;
  }
  getDetectLocale() {
    return __classPrivateFieldGet2(this, _YargsInstance_detectLocale, 'f');
  }
  getExitProcess() {
    return __classPrivateFieldGet2(this, _YargsInstance_exitProcess, 'f');
  }
  getGroups() {
    return Object.assign(
      {},
      __classPrivateFieldGet2(this, _YargsInstance_groups, 'f'),
      __classPrivateFieldGet2(this, _YargsInstance_preservedGroups, 'f')
    );
  }
  getHelp() {
    __classPrivateFieldSet2(this, _YargsInstance_hasOutput, true, 'f');
    if (!__classPrivateFieldGet2(this, _YargsInstance_usage, 'f').hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](
          __classPrivateFieldGet2(this, _YargsInstance_processArgs, 'f'),
          undefined,
          undefined,
          0,
          true
        );
        if (isPromise(parse)) {
          return parse.then(() => {
            return __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').help();
          });
        }
      }
      const builderResponse = __classPrivateFieldGet2(
        this,
        _YargsInstance_command,
        'f'
      ).runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        return builderResponse.then(() => {
          return __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').help();
        });
      }
    }
    return Promise.resolve(__classPrivateFieldGet2(this, _YargsInstance_usage, 'f').help());
  }
  getOptions() {
    return __classPrivateFieldGet2(this, _YargsInstance_options, 'f');
  }
  getStrict() {
    return __classPrivateFieldGet2(this, _YargsInstance_strict, 'f');
  }
  getStrictCommands() {
    return __classPrivateFieldGet2(this, _YargsInstance_strictCommands, 'f');
  }
  getStrictOptions() {
    return __classPrivateFieldGet2(this, _YargsInstance_strictOptions, 'f');
  }
  global(globals, global3) {
    argsert('<string|array> [boolean]', [globals, global3], arguments.length);
    globals = [].concat(globals);
    if (global3 !== false) {
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').local = __classPrivateFieldGet2(
        this,
        _YargsInstance_options,
        'f'
      ).local.filter((l) => globals.indexOf(l) === -1);
    } else {
      globals.forEach((g) => {
        if (!__classPrivateFieldGet2(this, _YargsInstance_options, 'f').local.includes(g))
          __classPrivateFieldGet2(this, _YargsInstance_options, 'f').local.push(g);
      });
    }
    return this;
  }
  group(opts, groupName) {
    argsert('<string|array> <string>', [opts, groupName], arguments.length);
    const existing =
      __classPrivateFieldGet2(this, _YargsInstance_preservedGroups, 'f')[groupName] ||
      __classPrivateFieldGet2(this, _YargsInstance_groups, 'f')[groupName];
    if (__classPrivateFieldGet2(this, _YargsInstance_preservedGroups, 'f')[groupName]) {
      delete __classPrivateFieldGet2(this, _YargsInstance_preservedGroups, 'f')[groupName];
    }
    const seen = {};
    __classPrivateFieldGet2(this, _YargsInstance_groups, 'f')[groupName] = (existing || [])
      .concat(opts)
      .filter((key) => {
        if (seen[key]) return false;
        return (seen[key] = true);
      });
    return this;
  }
  hide(key) {
    argsert('<string>', [key], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').hiddenOptions.push(key);
    return this;
  }
  implies(key, value) {
    argsert('<string|object> [number|string|array]', [key, value], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').implies(key, value);
    return this;
  }
  locale(locale) {
    argsert('[string]', [locale], arguments.length);
    if (locale === undefined) {
      this[kGuessLocale]();
      return __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').y18n.getLocale();
    }
    __classPrivateFieldSet2(this, _YargsInstance_detectLocale, false, 'f');
    __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').y18n.setLocale(locale);
    return this;
  }
  middleware(callback, applyBeforeValidation, global3) {
    return __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').addMiddleware(
      callback,
      !!applyBeforeValidation,
      global3
    );
  }
  nargs(key, value) {
    argsert('<string|object|array> [number]', [key, value], arguments.length);
    this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), 'narg', key, value);
    return this;
  }
  normalize(keys) {
    argsert('<array|string>', [keys], arguments.length);
    this[kPopulateParserHintArray]('normalize', keys);
    return this;
  }
  number(keys) {
    argsert('<array|string>', [keys], arguments.length);
    this[kPopulateParserHintArray]('number', keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  option(key, opt) {
    argsert('<string|object> [object]', [key, opt], arguments.length);
    if (typeof key === 'object') {
      Object.keys(key).forEach((k) => {
        this.options(k, key[k]);
      });
    } else {
      if (typeof opt !== 'object') {
        opt = {};
      }
      this[kTrackManuallySetKeys](key);
      if (
        __classPrivateFieldGet2(this, _YargsInstance_versionOpt, 'f') &&
        (key === 'version' ||
          (opt === null || opt === undefined ? undefined : opt.alias) === 'version')
      ) {
        this[kEmitWarning](
          [
            '"version" is a reserved word.',
            'Please do one of the following:',
            '- Disable version with `yargs.version(false)` if using "version" as an option',
            '- Use the built-in `yargs.version` method instead (if applicable)',
            '- Use a different option key',
            'https://yargs.js.org/docs/#api-reference-version',
          ].join(`
`),
          undefined,
          'versionWarning'
        );
      }
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').key[key] = true;
      if (opt.alias) this.alias(key, opt.alias);
      const deprecate = opt.deprecate || opt.deprecated;
      if (deprecate) {
        this.deprecateOption(key, deprecate);
      }
      const demand = opt.demand || opt.required || opt.require;
      if (demand) {
        this.demand(key, demand);
      }
      if (opt.demandOption) {
        this.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);
      }
      if (opt.conflicts) {
        this.conflicts(key, opt.conflicts);
      }
      if ('default' in opt) {
        this.default(key, opt.default);
      }
      if (opt.implies !== undefined) {
        this.implies(key, opt.implies);
      }
      if (opt.nargs !== undefined) {
        this.nargs(key, opt.nargs);
      }
      if (opt.config) {
        this.config(key, opt.configParser);
      }
      if (opt.normalize) {
        this.normalize(key);
      }
      if (opt.choices) {
        this.choices(key, opt.choices);
      }
      if (opt.coerce) {
        this.coerce(key, opt.coerce);
      }
      if (opt.group) {
        this.group(key, opt.group);
      }
      if (opt.boolean || opt.type === 'boolean') {
        this.boolean(key);
        if (opt.alias) this.boolean(opt.alias);
      }
      if (opt.array || opt.type === 'array') {
        this.array(key);
        if (opt.alias) this.array(opt.alias);
      }
      if (opt.number || opt.type === 'number') {
        this.number(key);
        if (opt.alias) this.number(opt.alias);
      }
      if (opt.string || opt.type === 'string') {
        this.string(key);
        if (opt.alias) this.string(opt.alias);
      }
      if (opt.count || opt.type === 'count') {
        this.count(key);
      }
      if (typeof opt.global === 'boolean') {
        this.global(key, opt.global);
      }
      if (opt.defaultDescription) {
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f').defaultDescription[key] =
          opt.defaultDescription;
      }
      if (opt.skipValidation) {
        this.skipValidation(key);
      }
      const desc = opt.describe || opt.description || opt.desc;
      const descriptions = __classPrivateFieldGet2(
        this,
        _YargsInstance_usage,
        'f'
      ).getDescriptions();
      if (!Object.prototype.hasOwnProperty.call(descriptions, key) || typeof desc === 'string') {
        this.describe(key, desc);
      }
      if (opt.hidden) {
        this.hide(key);
      }
      if (opt.requiresArg) {
        this.requiresArg(key);
      }
    }
    return this;
  }
  options(key, opt) {
    return this.option(key, opt);
  }
  parse(args, shortCircuit, _parseFn) {
    argsert(
      '[string|array] [function|boolean|object] [function]',
      [args, shortCircuit, _parseFn],
      arguments.length
    );
    this[kFreeze]();
    if (typeof args === 'undefined') {
      args = __classPrivateFieldGet2(this, _YargsInstance_processArgs, 'f');
    }
    if (typeof shortCircuit === 'object') {
      __classPrivateFieldSet2(this, _YargsInstance_parseContext, shortCircuit, 'f');
      shortCircuit = _parseFn;
    }
    if (typeof shortCircuit === 'function') {
      __classPrivateFieldSet2(this, _YargsInstance_parseFn, shortCircuit, 'f');
      shortCircuit = false;
    }
    if (!shortCircuit) __classPrivateFieldSet2(this, _YargsInstance_processArgs, args, 'f');
    if (__classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f'))
      __classPrivateFieldSet2(this, _YargsInstance_exitProcess, false, 'f');
    const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
    const tmpParsed = this.parsed;
    __classPrivateFieldGet2(this, _YargsInstance_completion, 'f').setParsed(this.parsed);
    if (isPromise(parsed)) {
      return parsed
        .then((argv) => {
          if (__classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f'))
            __classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f').call(
              this,
              __classPrivateFieldGet2(this, _YargsInstance_exitError, 'f'),
              argv,
              __classPrivateFieldGet2(this, _YargsInstance_output, 'f')
            );
          return argv;
        })
        .catch((err) => {
          if (__classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f')) {
            __classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f')(
              err,
              this.parsed.argv,
              __classPrivateFieldGet2(this, _YargsInstance_output, 'f')
            );
          }
          throw err;
        })
        .finally(() => {
          this[kUnfreeze]();
          this.parsed = tmpParsed;
        });
    } else {
      if (__classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f'))
        __classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f').call(
          this,
          __classPrivateFieldGet2(this, _YargsInstance_exitError, 'f'),
          parsed,
          __classPrivateFieldGet2(this, _YargsInstance_output, 'f')
        );
      this[kUnfreeze]();
      this.parsed = tmpParsed;
    }
    return parsed;
  }
  parseAsync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
  }
  parseSync(args, shortCircuit, _parseFn) {
    const maybePromise = this.parse(args, shortCircuit, _parseFn);
    if (isPromise(maybePromise)) {
      throw new YError(
        '.parseSync() must not be used with asynchronous builders, handlers, or middleware'
      );
    }
    return maybePromise;
  }
  parserConfiguration(config2) {
    argsert('<object>', [config2], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_parserConfig, config2, 'f');
    return this;
  }
  pkgConf(key, rootPath) {
    argsert('<string> [string]', [key, rootPath], arguments.length);
    let conf = null;
    const obj = this[kPkgUp](rootPath || __classPrivateFieldGet2(this, _YargsInstance_cwd, 'f'));
    if (obj[key] && typeof obj[key] === 'object') {
      conf = applyExtends(
        obj[key],
        rootPath || __classPrivateFieldGet2(this, _YargsInstance_cwd, 'f'),
        this[kGetParserConfiguration]()['deep-merge-config'] || false,
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
      );
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configObjects = (
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configObjects || []
      ).concat(conf);
    }
    return this;
  }
  positional(key, opts) {
    argsert('<string> <object>', [key, opts], arguments.length);
    const supportedOpts = [
      'default',
      'defaultDescription',
      'implies',
      'normalize',
      'choices',
      'conflicts',
      'coerce',
      'type',
      'describe',
      'desc',
      'description',
      'alias',
    ];
    opts = objFilter(opts, (k, v) => {
      if (k === 'type' && !['string', 'number', 'boolean'].includes(v)) return false;
      return supportedOpts.includes(k);
    });
    const fullCommand = __classPrivateFieldGet2(this, _YargsInstance_context, 'f').fullCommands[
      __classPrivateFieldGet2(this, _YargsInstance_context, 'f').fullCommands.length - 1
    ];
    const parseOptions = fullCommand
      ? __classPrivateFieldGet2(this, _YargsInstance_command, 'f').cmdToParseOptions(fullCommand)
      : {
          array: [],
          alias: {},
          default: {},
          demand: {},
        };
    objectKeys(parseOptions).forEach((pk) => {
      const parseOption = parseOptions[pk];
      if (Array.isArray(parseOption)) {
        if (parseOption.indexOf(key) !== -1) opts[pk] = true;
      } else {
        if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];
      }
    });
    this.group(
      key,
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').getPositionalGroupName()
    );
    return this.option(key, opts);
  }
  recommendCommands(recommend = true) {
    argsert('[boolean]', [recommend], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_recommendCommands, recommend, 'f');
    return this;
  }
  required(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  require(keys, max, msg) {
    return this.demand(keys, max, msg);
  }
  requiresArg(keys) {
    argsert('<array|string|object> [number]', [keys], arguments.length);
    if (
      typeof keys === 'string' &&
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').narg[keys]
    ) {
      return this;
    } else {
      this[kPopulateParserHintSingleValueDictionary](
        this.requiresArg.bind(this),
        'narg',
        keys,
        NaN
      );
    }
    return this;
  }
  showCompletionScript($0, cmd) {
    argsert('[string] [string]', [$0, cmd], arguments.length);
    $0 = $0 || this.$0;
    __classPrivateFieldGet2(this, _YargsInstance_logger, 'f').log(
      __classPrivateFieldGet2(this, _YargsInstance_completion, 'f').generateCompletionScript(
        $0,
        cmd || __classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f') || 'completion'
      )
    );
    return this;
  }
  showHelp(level) {
    argsert('[string|function]', [level], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_hasOutput, true, 'f');
    if (!__classPrivateFieldGet2(this, _YargsInstance_usage, 'f').hasCachedHelpMessage()) {
      if (!this.parsed) {
        const parse = this[kRunYargsParserAndExecuteCommands](
          __classPrivateFieldGet2(this, _YargsInstance_processArgs, 'f'),
          undefined,
          undefined,
          0,
          true
        );
        if (isPromise(parse)) {
          parse.then(() => {
            __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').showHelp(level);
          });
          return this;
        }
      }
      const builderResponse = __classPrivateFieldGet2(
        this,
        _YargsInstance_command,
        'f'
      ).runDefaultBuilderOn(this);
      if (isPromise(builderResponse)) {
        builderResponse.then(() => {
          __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').showHelp(level);
        });
        return this;
      }
    }
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').showHelp(level);
    return this;
  }
  scriptName(scriptName) {
    this.customScriptName = true;
    this.$0 = scriptName;
    return this;
  }
  showHelpOnFail(enabled, message) {
    argsert('[boolean|string] [string]', [enabled, message], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').showHelpOnFail(enabled, message);
    return this;
  }
  showVersion(level) {
    argsert('[string|function]', [level], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').showVersion(level);
    return this;
  }
  skipValidation(keys) {
    argsert('<array|string>', [keys], arguments.length);
    this[kPopulateParserHintArray]('skipValidation', keys);
    return this;
  }
  strict(enabled) {
    argsert('[boolean]', [enabled], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_strict, enabled !== false, 'f');
    return this;
  }
  strictCommands(enabled) {
    argsert('[boolean]', [enabled], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_strictCommands, enabled !== false, 'f');
    return this;
  }
  strictOptions(enabled) {
    argsert('[boolean]', [enabled], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_strictOptions, enabled !== false, 'f');
    return this;
  }
  string(keys) {
    argsert('<array|string>', [keys], arguments.length);
    this[kPopulateParserHintArray]('string', keys);
    this[kTrackManuallySetKeys](keys);
    return this;
  }
  terminalWidth() {
    argsert([], 0);
    return __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').process.stdColumns;
  }
  updateLocale(obj) {
    return this.updateStrings(obj);
  }
  updateStrings(obj) {
    argsert('<object>', [obj], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_detectLocale, false, 'f');
    __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').y18n.updateLocale(obj);
    return this;
  }
  usage(msg, description, builder, handler) {
    argsert(
      '<string|null|undefined> [string|boolean] [function|object] [function]',
      [msg, description, builder, handler],
      arguments.length
    );
    if (description !== undefined) {
      assertNotStrictEqual(msg, null, __classPrivateFieldGet2(this, _YargsInstance_shim, 'f'));
      if ((msg || '').match(/^\$0( |$)/)) {
        return this.command(msg, description, builder, handler);
      } else {
        throw new YError(
          '.usage() description must start with $0 if being used as alias for .command()'
        );
      }
    } else {
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').usage(msg);
      return this;
    }
  }
  usageConfiguration(config2) {
    argsert('<object>', [config2], arguments.length);
    __classPrivateFieldSet2(this, _YargsInstance_usageConfig, config2, 'f');
    return this;
  }
  version(opt, msg, ver) {
    const defaultVersionOpt = 'version';
    argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);
    if (__classPrivateFieldGet2(this, _YargsInstance_versionOpt, 'f')) {
      this[kDeleteFromParserHintObject](
        __classPrivateFieldGet2(this, _YargsInstance_versionOpt, 'f')
      );
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').version(undefined);
      __classPrivateFieldSet2(this, _YargsInstance_versionOpt, null, 'f');
    }
    if (arguments.length === 0) {
      ver = this[kGuessVersion]();
      opt = defaultVersionOpt;
    } else if (arguments.length === 1) {
      if (opt === false) {
        return this;
      }
      ver = opt;
      opt = defaultVersionOpt;
    } else if (arguments.length === 2) {
      ver = msg;
      msg = undefined;
    }
    __classPrivateFieldSet2(
      this,
      _YargsInstance_versionOpt,
      typeof opt === 'string' ? opt : defaultVersionOpt,
      'f'
    );
    msg =
      msg ||
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').deferY18nLookup(
        'Show version number'
      );
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').version(ver || undefined);
    this.boolean(__classPrivateFieldGet2(this, _YargsInstance_versionOpt, 'f'));
    this.describe(__classPrivateFieldGet2(this, _YargsInstance_versionOpt, 'f'), msg);
    return this;
  }
  wrap(cols) {
    argsert('<number|null|undefined>', [cols], arguments.length);
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').wrap(cols);
    return this;
  }
  [((_YargsInstance_command = new WeakMap()),
  (_YargsInstance_cwd = new WeakMap()),
  (_YargsInstance_context = new WeakMap()),
  (_YargsInstance_completion = new WeakMap()),
  (_YargsInstance_completionCommand = new WeakMap()),
  (_YargsInstance_defaultShowHiddenOpt = new WeakMap()),
  (_YargsInstance_exitError = new WeakMap()),
  (_YargsInstance_detectLocale = new WeakMap()),
  (_YargsInstance_emittedWarnings = new WeakMap()),
  (_YargsInstance_exitProcess = new WeakMap()),
  (_YargsInstance_frozens = new WeakMap()),
  (_YargsInstance_globalMiddleware = new WeakMap()),
  (_YargsInstance_groups = new WeakMap()),
  (_YargsInstance_hasOutput = new WeakMap()),
  (_YargsInstance_helpOpt = new WeakMap()),
  (_YargsInstance_isGlobalContext = new WeakMap()),
  (_YargsInstance_logger = new WeakMap()),
  (_YargsInstance_output = new WeakMap()),
  (_YargsInstance_options = new WeakMap()),
  (_YargsInstance_parentRequire = new WeakMap()),
  (_YargsInstance_parserConfig = new WeakMap()),
  (_YargsInstance_parseFn = new WeakMap()),
  (_YargsInstance_parseContext = new WeakMap()),
  (_YargsInstance_pkgs = new WeakMap()),
  (_YargsInstance_preservedGroups = new WeakMap()),
  (_YargsInstance_processArgs = new WeakMap()),
  (_YargsInstance_recommendCommands = new WeakMap()),
  (_YargsInstance_shim = new WeakMap()),
  (_YargsInstance_strict = new WeakMap()),
  (_YargsInstance_strictCommands = new WeakMap()),
  (_YargsInstance_strictOptions = new WeakMap()),
  (_YargsInstance_usage = new WeakMap()),
  (_YargsInstance_usageConfig = new WeakMap()),
  (_YargsInstance_versionOpt = new WeakMap()),
  (_YargsInstance_validation = new WeakMap()),
  kCopyDoubleDash)](argv) {
    if (!argv._ || !argv['--']) return argv;
    argv._.push.apply(argv._, argv['--']);
    try {
      delete argv['--'];
    } catch (_err) {}
    return argv;
  }
  [kCreateLogger]() {
    return {
      log: (...args) => {
        if (!this[kHasParseCallback]()) console.log(...args);
        __classPrivateFieldSet2(this, _YargsInstance_hasOutput, true, 'f');
        if (__classPrivateFieldGet2(this, _YargsInstance_output, 'f').length)
          __classPrivateFieldSet2(
            this,
            _YargsInstance_output,
            __classPrivateFieldGet2(this, _YargsInstance_output, 'f') +
              `
`,
            'f'
          );
        __classPrivateFieldSet2(
          this,
          _YargsInstance_output,
          __classPrivateFieldGet2(this, _YargsInstance_output, 'f') + args.join(' '),
          'f'
        );
      },
      error: (...args) => {
        if (!this[kHasParseCallback]()) console.error(...args);
        __classPrivateFieldSet2(this, _YargsInstance_hasOutput, true, 'f');
        if (__classPrivateFieldGet2(this, _YargsInstance_output, 'f').length)
          __classPrivateFieldSet2(
            this,
            _YargsInstance_output,
            __classPrivateFieldGet2(this, _YargsInstance_output, 'f') +
              `
`,
            'f'
          );
        __classPrivateFieldSet2(
          this,
          _YargsInstance_output,
          __classPrivateFieldGet2(this, _YargsInstance_output, 'f') + args.join(' '),
          'f'
        );
      },
    };
  }
  [kDeleteFromParserHintObject](optionKey) {
    objectKeys(__classPrivateFieldGet2(this, _YargsInstance_options, 'f')).forEach((hintKey) => {
      if (((key) => key === 'configObjects')(hintKey)) return;
      const hint = __classPrivateFieldGet2(this, _YargsInstance_options, 'f')[hintKey];
      if (Array.isArray(hint)) {
        if (hint.includes(optionKey)) hint.splice(hint.indexOf(optionKey), 1);
      } else if (typeof hint === 'object') {
        delete hint[optionKey];
      }
    });
    delete __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').getDescriptions()[optionKey];
  }
  [kEmitWarning](warning, type, deduplicationId) {
    if (!__classPrivateFieldGet2(this, _YargsInstance_emittedWarnings, 'f')[deduplicationId]) {
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').process.emitWarning(warning, type);
      __classPrivateFieldGet2(this, _YargsInstance_emittedWarnings, 'f')[deduplicationId] = true;
    }
  }
  [kFreeze]() {
    __classPrivateFieldGet2(this, _YargsInstance_frozens, 'f').push({
      options: __classPrivateFieldGet2(this, _YargsInstance_options, 'f'),
      configObjects: __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configObjects.slice(
        0
      ),
      exitProcess: __classPrivateFieldGet2(this, _YargsInstance_exitProcess, 'f'),
      groups: __classPrivateFieldGet2(this, _YargsInstance_groups, 'f'),
      strict: __classPrivateFieldGet2(this, _YargsInstance_strict, 'f'),
      strictCommands: __classPrivateFieldGet2(this, _YargsInstance_strictCommands, 'f'),
      strictOptions: __classPrivateFieldGet2(this, _YargsInstance_strictOptions, 'f'),
      completionCommand: __classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f'),
      output: __classPrivateFieldGet2(this, _YargsInstance_output, 'f'),
      exitError: __classPrivateFieldGet2(this, _YargsInstance_exitError, 'f'),
      hasOutput: __classPrivateFieldGet2(this, _YargsInstance_hasOutput, 'f'),
      parsed: this.parsed,
      parseFn: __classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f'),
      parseContext: __classPrivateFieldGet2(this, _YargsInstance_parseContext, 'f'),
    });
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').freeze();
    __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').freeze();
    __classPrivateFieldGet2(this, _YargsInstance_command, 'f').freeze();
    __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').freeze();
  }
  [kGetDollarZero]() {
    let $0 = '';
    let default$0;
    if (
      /\b(node|iojs|electron)(\.exe)?$/.test(
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').process.argv()[0]
      )
    ) {
      default$0 = __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
        .process.argv()
        .slice(1, 2);
    } else {
      default$0 = __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
        .process.argv()
        .slice(0, 1);
    }
    $0 = default$0
      .map((x) => {
        const b = this[kRebase](__classPrivateFieldGet2(this, _YargsInstance_cwd, 'f'), x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
      })
      .join(' ')
      .trim();
    if (
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getEnv('_') &&
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getProcessArgvBin() ===
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getEnv('_')
    ) {
      $0 = __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
        .getEnv('_')
        .replace(
          `${__classPrivateFieldGet2(this, _YargsInstance_shim, 'f').path.dirname(__classPrivateFieldGet2(this, _YargsInstance_shim, 'f').process.execPath())}/`,
          ''
        );
    }
    return $0;
  }
  [kGetParserConfiguration]() {
    return __classPrivateFieldGet2(this, _YargsInstance_parserConfig, 'f');
  }
  [kGetUsageConfiguration]() {
    return __classPrivateFieldGet2(this, _YargsInstance_usageConfig, 'f');
  }
  [kGuessLocale]() {
    if (!__classPrivateFieldGet2(this, _YargsInstance_detectLocale, 'f')) return;
    const locale =
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getEnv('LC_ALL') ||
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getEnv('LC_MESSAGES') ||
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getEnv('LANG') ||
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').getEnv('LANGUAGE') ||
      'en_US';
    this.locale(locale.replace(/[.:].*/, ''));
  }
  [kGuessVersion]() {
    const obj = this[kPkgUp]();
    return obj.version || 'unknown';
  }
  [kParsePositionalNumbers](argv) {
    const args = argv['--'] ? argv['--'] : argv._;
    for (let i = 0, arg; (arg = args[i]) !== undefined; i++) {
      if (
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').Parser.looksLikeNumber(arg) &&
        Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))
      ) {
        args[i] = Number(arg);
      }
    }
    return argv;
  }
  [kPkgUp](rootPath) {
    const npath = rootPath || '*';
    if (__classPrivateFieldGet2(this, _YargsInstance_pkgs, 'f')[npath])
      return __classPrivateFieldGet2(this, _YargsInstance_pkgs, 'f')[npath];
    let obj = {};
    try {
      let startDir =
        rootPath || __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').mainFilename;
      if (
        !rootPath &&
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').path.extname(startDir)
      ) {
        startDir = __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').path.dirname(startDir);
      }
      const pkgJsonPath = __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').findUp(
        startDir,
        (dir, names) => {
          if (names.includes('package.json')) {
            return 'package.json';
          } else {
            return;
          }
        }
      );
      assertNotStrictEqual(
        pkgJsonPath,
        undefined,
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
      );
      obj = JSON.parse(
        __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').readFileSync(pkgJsonPath, 'utf8')
      );
    } catch (_noop) {}
    __classPrivateFieldGet2(this, _YargsInstance_pkgs, 'f')[npath] = obj || {};
    return __classPrivateFieldGet2(this, _YargsInstance_pkgs, 'f')[npath];
  }
  [kPopulateParserHintArray](type, keys) {
    keys = [].concat(keys);
    keys.forEach((key) => {
      key = this[kSanitizeKey](key);
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f')[type].push(key);
    });
  }
  [kPopulateParserHintSingleValueDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f')[type2][key2] = value2;
    });
  }
  [kPopulateParserHintArrayDictionary](builder, type, key, value) {
    this[kPopulateParserHintDictionary](builder, type, key, value, (type2, key2, value2) => {
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f')[type2][key2] = (
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f')[type2][key2] || []
      ).concat(value2);
    });
  }
  [kPopulateParserHintDictionary](builder, type, key, value, singleKeyHandler) {
    if (Array.isArray(key)) {
      key.forEach((k) => {
        builder(k, value);
      });
    } else if (((key2) => typeof key2 === 'object')(key)) {
      for (const k of objectKeys(key)) {
        builder(k, key[k]);
      }
    } else {
      singleKeyHandler(type, this[kSanitizeKey](key), value);
    }
  }
  [kSanitizeKey](key) {
    if (key === '__proto__') return '___proto___';
    return key;
  }
  [kSetKey](key, set) {
    this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), 'key', key, set);
    return this;
  }
  [kUnfreeze]() {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const frozen = __classPrivateFieldGet2(this, _YargsInstance_frozens, 'f').pop();
    assertNotStrictEqual(
      frozen,
      undefined,
      __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
    );
    let configObjects;
    ((_a2 = this),
      (_b2 = this),
      (_c2 = this),
      (_d = this),
      (_e = this),
      (_f = this),
      (_g = this),
      (_h = this),
      (_j = this),
      (_k = this),
      (_l = this),
      (_m = this),
      ({
        options: {
          set value(_o) {
            __classPrivateFieldSet2(_a2, _YargsInstance_options, _o, 'f');
          },
        }.value,
        configObjects,
        exitProcess: {
          set value(_o) {
            __classPrivateFieldSet2(_b2, _YargsInstance_exitProcess, _o, 'f');
          },
        }.value,
        groups: {
          set value(_o) {
            __classPrivateFieldSet2(_c2, _YargsInstance_groups, _o, 'f');
          },
        }.value,
        output: {
          set value(_o) {
            __classPrivateFieldSet2(_d, _YargsInstance_output, _o, 'f');
          },
        }.value,
        exitError: {
          set value(_o) {
            __classPrivateFieldSet2(_e, _YargsInstance_exitError, _o, 'f');
          },
        }.value,
        hasOutput: {
          set value(_o) {
            __classPrivateFieldSet2(_f, _YargsInstance_hasOutput, _o, 'f');
          },
        }.value,
        parsed: this.parsed,
        strict: {
          set value(_o) {
            __classPrivateFieldSet2(_g, _YargsInstance_strict, _o, 'f');
          },
        }.value,
        strictCommands: {
          set value(_o) {
            __classPrivateFieldSet2(_h, _YargsInstance_strictCommands, _o, 'f');
          },
        }.value,
        strictOptions: {
          set value(_o) {
            __classPrivateFieldSet2(_j, _YargsInstance_strictOptions, _o, 'f');
          },
        }.value,
        completionCommand: {
          set value(_o) {
            __classPrivateFieldSet2(_k, _YargsInstance_completionCommand, _o, 'f');
          },
        }.value,
        parseFn: {
          set value(_o) {
            __classPrivateFieldSet2(_l, _YargsInstance_parseFn, _o, 'f');
          },
        }.value,
        parseContext: {
          set value(_o) {
            __classPrivateFieldSet2(_m, _YargsInstance_parseContext, _o, 'f');
          },
        }.value,
      } = frozen));
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configObjects = configObjects;
    __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').unfreeze();
    __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').unfreeze();
    __classPrivateFieldGet2(this, _YargsInstance_command, 'f').unfreeze();
    __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').unfreeze();
  }
  [kValidateAsync](validation2, argv) {
    return maybeAsyncResult(argv, (result) => {
      validation2(result);
      return result;
    });
  }
  getInternalMethods() {
    return {
      getCommandInstance: this[kGetCommandInstance].bind(this),
      getContext: this[kGetContext].bind(this),
      getHasOutput: this[kGetHasOutput].bind(this),
      getLoggerInstance: this[kGetLoggerInstance].bind(this),
      getParseContext: this[kGetParseContext].bind(this),
      getParserConfiguration: this[kGetParserConfiguration].bind(this),
      getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
      getUsageInstance: this[kGetUsageInstance].bind(this),
      getValidationInstance: this[kGetValidationInstance].bind(this),
      hasParseCallback: this[kHasParseCallback].bind(this),
      isGlobalContext: this[kIsGlobalContext].bind(this),
      postProcess: this[kPostProcess].bind(this),
      reset: this[kReset].bind(this),
      runValidation: this[kRunValidation].bind(this),
      runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
      setHasOutput: this[kSetHasOutput].bind(this),
    };
  }
  [kGetCommandInstance]() {
    return __classPrivateFieldGet2(this, _YargsInstance_command, 'f');
  }
  [kGetContext]() {
    return __classPrivateFieldGet2(this, _YargsInstance_context, 'f');
  }
  [kGetHasOutput]() {
    return __classPrivateFieldGet2(this, _YargsInstance_hasOutput, 'f');
  }
  [kGetLoggerInstance]() {
    return __classPrivateFieldGet2(this, _YargsInstance_logger, 'f');
  }
  [kGetParseContext]() {
    return __classPrivateFieldGet2(this, _YargsInstance_parseContext, 'f') || {};
  }
  [kGetUsageInstance]() {
    return __classPrivateFieldGet2(this, _YargsInstance_usage, 'f');
  }
  [kGetValidationInstance]() {
    return __classPrivateFieldGet2(this, _YargsInstance_validation, 'f');
  }
  [kHasParseCallback]() {
    return !!__classPrivateFieldGet2(this, _YargsInstance_parseFn, 'f');
  }
  [kIsGlobalContext]() {
    return __classPrivateFieldGet2(this, _YargsInstance_isGlobalContext, 'f');
  }
  [kPostProcess](argv, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
    if (calledFromCommand) return argv;
    if (isPromise(argv)) return argv;
    if (!populateDoubleDash) {
      argv = this[kCopyDoubleDash](argv);
    }
    const parsePositionalNumbers =
      this[kGetParserConfiguration]()['parse-positional-numbers'] ||
      this[kGetParserConfiguration]()['parse-positional-numbers'] === undefined;
    if (parsePositionalNumbers) {
      argv = this[kParsePositionalNumbers](argv);
    }
    if (runGlobalMiddleware) {
      argv = applyMiddleware(
        argv,
        this,
        __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').getMiddleware(),
        false
      );
    }
    return argv;
  }
  [kReset](aliases = {}) {
    __classPrivateFieldSet2(
      this,
      _YargsInstance_options,
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f') || {},
      'f'
    );
    const tmpOptions = {};
    tmpOptions.local = __classPrivateFieldGet2(this, _YargsInstance_options, 'f').local || [];
    tmpOptions.configObjects =
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configObjects || [];
    const localLookup = {};
    tmpOptions.local.forEach((l) => {
      localLookup[l] = true;
      (aliases[l] || []).forEach((a) => {
        localLookup[a] = true;
      });
    });
    Object.assign(
      __classPrivateFieldGet2(this, _YargsInstance_preservedGroups, 'f'),
      Object.keys(__classPrivateFieldGet2(this, _YargsInstance_groups, 'f')).reduce(
        (acc, groupName) => {
          const keys = __classPrivateFieldGet2(this, _YargsInstance_groups, 'f')[groupName].filter(
            (key) => !(key in localLookup)
          );
          if (keys.length > 0) {
            acc[groupName] = keys;
          }
          return acc;
        },
        {}
      )
    );
    __classPrivateFieldSet2(this, _YargsInstance_groups, {}, 'f');
    const arrayOptions = [
      'array',
      'boolean',
      'string',
      'skipValidation',
      'count',
      'normalize',
      'number',
      'hiddenOptions',
    ];
    const objectOptions = [
      'narg',
      'key',
      'alias',
      'default',
      'defaultDescription',
      'config',
      'choices',
      'demandedOptions',
      'demandedCommands',
      'deprecatedOptions',
    ];
    arrayOptions.forEach((k) => {
      tmpOptions[k] = (__classPrivateFieldGet2(this, _YargsInstance_options, 'f')[k] || []).filter(
        (k2) => !localLookup[k2]
      );
    });
    objectOptions.forEach((k) => {
      tmpOptions[k] = objFilter(
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f')[k],
        (k2) => !localLookup[k2]
      );
    });
    tmpOptions.envPrefix = __classPrivateFieldGet2(this, _YargsInstance_options, 'f').envPrefix;
    __classPrivateFieldSet2(this, _YargsInstance_options, tmpOptions, 'f');
    __classPrivateFieldSet2(
      this,
      _YargsInstance_usage,
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f')
        ? __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').reset(localLookup)
        : usage(this, __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')),
      'f'
    );
    __classPrivateFieldSet2(
      this,
      _YargsInstance_validation,
      __classPrivateFieldGet2(this, _YargsInstance_validation, 'f')
        ? __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').reset(localLookup)
        : validation(
            this,
            __classPrivateFieldGet2(this, _YargsInstance_usage, 'f'),
            __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
          ),
      'f'
    );
    __classPrivateFieldSet2(
      this,
      _YargsInstance_command,
      __classPrivateFieldGet2(this, _YargsInstance_command, 'f')
        ? __classPrivateFieldGet2(this, _YargsInstance_command, 'f').reset()
        : command(
            __classPrivateFieldGet2(this, _YargsInstance_usage, 'f'),
            __classPrivateFieldGet2(this, _YargsInstance_validation, 'f'),
            __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f'),
            __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
          ),
      'f'
    );
    if (!__classPrivateFieldGet2(this, _YargsInstance_completion, 'f'))
      __classPrivateFieldSet2(
        this,
        _YargsInstance_completion,
        completion(
          this,
          __classPrivateFieldGet2(this, _YargsInstance_usage, 'f'),
          __classPrivateFieldGet2(this, _YargsInstance_command, 'f'),
          __classPrivateFieldGet2(this, _YargsInstance_shim, 'f')
        ),
        'f'
      );
    __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').reset();
    __classPrivateFieldSet2(this, _YargsInstance_completionCommand, null, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_output, '', 'f');
    __classPrivateFieldSet2(this, _YargsInstance_exitError, null, 'f');
    __classPrivateFieldSet2(this, _YargsInstance_hasOutput, false, 'f');
    this.parsed = false;
    return this;
  }
  [kRebase](base, dir) {
    return __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').path.relative(base, dir);
  }
  [kRunYargsParserAndExecuteCommands](
    args,
    shortCircuit,
    calledFromCommand,
    commandIndex = 0,
    helpOnly = false
  ) {
    let skipValidation = !!calledFromCommand || helpOnly;
    args = args || __classPrivateFieldGet2(this, _YargsInstance_processArgs, 'f');
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').__ = __classPrivateFieldGet2(
      this,
      _YargsInstance_shim,
      'f'
    ).y18n.__;
    __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configuration =
      this[kGetParserConfiguration]();
    const populateDoubleDash = !!__classPrivateFieldGet2(this, _YargsInstance_options, 'f')
      .configuration['populate--'];
    const config2 = Object.assign(
      {},
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').configuration,
      {
        'populate--': true,
      }
    );
    const parsed = __classPrivateFieldGet2(this, _YargsInstance_shim, 'f').Parser.detailed(
      args,
      Object.assign({}, __classPrivateFieldGet2(this, _YargsInstance_options, 'f'), {
        configuration: { 'parse-positional-numbers': false, ...config2 },
      })
    );
    const argv = Object.assign(
      parsed.argv,
      __classPrivateFieldGet2(this, _YargsInstance_parseContext, 'f')
    );
    let argvPromise = undefined;
    const aliases = parsed.aliases;
    let helpOptSet = false;
    let versionOptSet = false;
    Object.keys(argv).forEach((key) => {
      if (key === __classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f') && argv[key]) {
        helpOptSet = true;
      } else if (
        key === __classPrivateFieldGet2(this, _YargsInstance_versionOpt, 'f') &&
        argv[key]
      ) {
        versionOptSet = true;
      }
    });
    argv.$0 = this.$0;
    this.parsed = parsed;
    if (commandIndex === 0) {
      __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').clearCachedHelpMessage();
    }
    try {
      this[kGuessLocale]();
      if (shortCircuit) {
        return this[kPostProcess](argv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (__classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f')) {
        const helpCmds = [__classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f')]
          .concat(aliases[__classPrivateFieldGet2(this, _YargsInstance_helpOpt, 'f')] || [])
          .filter((k) => k.length > 1);
        if (helpCmds.includes('' + argv._[argv._.length - 1])) {
          argv._.pop();
          helpOptSet = true;
        }
      }
      __classPrivateFieldSet2(this, _YargsInstance_isGlobalContext, false, 'f');
      const handlerKeys = __classPrivateFieldGet2(this, _YargsInstance_command, 'f').getCommands();
      const requestCompletions =
        __classPrivateFieldGet2(this, _YargsInstance_completion, 'f').completionKey in argv;
      const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
      if (argv._.length) {
        if (handlerKeys.length) {
          let firstUnknownCommand;
          for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {
            cmd = String(argv._[i]);
            if (
              handlerKeys.includes(cmd) &&
              cmd !== __classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f')
            ) {
              const innerArgv = __classPrivateFieldGet2(
                this,
                _YargsInstance_command,
                'f'
              ).runCommand(
                cmd,
                this,
                parsed,
                i + 1,
                helpOnly,
                helpOptSet || versionOptSet || helpOnly
              );
              return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
            } else if (
              !firstUnknownCommand &&
              cmd !== __classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f')
            ) {
              firstUnknownCommand = cmd;
              break;
            }
          }
          if (
            !__classPrivateFieldGet2(this, _YargsInstance_command, 'f').hasDefaultCommand() &&
            __classPrivateFieldGet2(this, _YargsInstance_recommendCommands, 'f') &&
            firstUnknownCommand &&
            !skipRecommendation
          ) {
            __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').recommendCommands(
              firstUnknownCommand,
              handlerKeys
            );
          }
        }
        if (
          __classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f') &&
          argv._.includes(__classPrivateFieldGet2(this, _YargsInstance_completionCommand, 'f')) &&
          !requestCompletions
        ) {
          if (__classPrivateFieldGet2(this, _YargsInstance_exitProcess, 'f')) setBlocking(true);
          this.showCompletionScript();
          this.exit(0);
        }
      }
      if (
        __classPrivateFieldGet2(this, _YargsInstance_command, 'f').hasDefaultCommand() &&
        !skipRecommendation
      ) {
        const innerArgv = __classPrivateFieldGet2(this, _YargsInstance_command, 'f').runCommand(
          null,
          this,
          parsed,
          0,
          helpOnly,
          helpOptSet || versionOptSet || helpOnly
        );
        return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
      }
      if (requestCompletions) {
        if (__classPrivateFieldGet2(this, _YargsInstance_exitProcess, 'f')) setBlocking(true);
        args = [].concat(args);
        const completionArgs = args.slice(
          args.indexOf(
            `--${__classPrivateFieldGet2(this, _YargsInstance_completion, 'f').completionKey}`
          ) + 1
        );
        __classPrivateFieldGet2(this, _YargsInstance_completion, 'f').getCompletion(
          completionArgs,
          (err, completions) => {
            if (err) throw new YError(err.message);
            (completions || []).forEach((completion2) => {
              __classPrivateFieldGet2(this, _YargsInstance_logger, 'f').log(completion2);
            });
            this.exit(0);
          }
        );
        return this[kPostProcess](argv, !populateDoubleDash, !!calledFromCommand, false);
      }
      if (!__classPrivateFieldGet2(this, _YargsInstance_hasOutput, 'f')) {
        if (helpOptSet) {
          if (__classPrivateFieldGet2(this, _YargsInstance_exitProcess, 'f')) setBlocking(true);
          skipValidation = true;
          this.showHelp('log');
          this.exit(0);
        } else if (versionOptSet) {
          if (__classPrivateFieldGet2(this, _YargsInstance_exitProcess, 'f')) setBlocking(true);
          skipValidation = true;
          __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').showVersion('log');
          this.exit(0);
        }
      }
      if (
        !skipValidation &&
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f').skipValidation.length > 0
      ) {
        skipValidation = Object.keys(argv).some(
          (key) =>
            __classPrivateFieldGet2(this, _YargsInstance_options, 'f').skipValidation.indexOf(
              key
            ) >= 0 && argv[key] === true
        );
      }
      if (!skipValidation) {
        if (parsed.error) throw new YError(parsed.error.message);
        if (!requestCompletions) {
          const validation2 = this[kRunValidation](aliases, {}, parsed.error);
          if (!calledFromCommand) {
            argvPromise = applyMiddleware(
              argv,
              this,
              __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').getMiddleware(),
              true
            );
          }
          argvPromise = this[kValidateAsync](
            validation2,
            argvPromise !== null && argvPromise !== undefined ? argvPromise : argv
          );
          if (isPromise(argvPromise) && !calledFromCommand) {
            argvPromise = argvPromise.then(() => {
              return applyMiddleware(
                argv,
                this,
                __classPrivateFieldGet2(this, _YargsInstance_globalMiddleware, 'f').getMiddleware(),
                false
              );
            });
          }
        }
      }
    } catch (err) {
      if (err instanceof YError)
        __classPrivateFieldGet2(this, _YargsInstance_usage, 'f').fail(err.message, err);
      else throw err;
    }
    return this[kPostProcess](
      argvPromise !== null && argvPromise !== undefined ? argvPromise : argv,
      populateDoubleDash,
      !!calledFromCommand,
      true
    );
  }
  [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
    const demandedOptions = { ...this.getDemandedOptions() };
    return (argv) => {
      if (parseErrors) throw new YError(parseErrors.message);
      __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').nonOptionCount(argv);
      __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').requiredArguments(
        argv,
        demandedOptions
      );
      let failedStrictCommands = false;
      if (__classPrivateFieldGet2(this, _YargsInstance_strictCommands, 'f')) {
        failedStrictCommands = __classPrivateFieldGet2(
          this,
          _YargsInstance_validation,
          'f'
        ).unknownCommands(argv);
      }
      if (__classPrivateFieldGet2(this, _YargsInstance_strict, 'f') && !failedStrictCommands) {
        __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').unknownArguments(
          argv,
          aliases,
          positionalMap,
          !!isDefaultCommand
        );
      } else if (__classPrivateFieldGet2(this, _YargsInstance_strictOptions, 'f')) {
        __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').unknownArguments(
          argv,
          aliases,
          {},
          false,
          false
        );
      }
      __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').limitedChoices(argv);
      __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').implications(argv);
      __classPrivateFieldGet2(this, _YargsInstance_validation, 'f').conflicting(argv);
    };
  }
  [kSetHasOutput]() {
    __classPrivateFieldSet2(this, _YargsInstance_hasOutput, true, 'f');
  }
  [kTrackManuallySetKeys](keys) {
    if (typeof keys === 'string') {
      __classPrivateFieldGet2(this, _YargsInstance_options, 'f').key[keys] = true;
    } else {
      for (const k of keys) {
        __classPrivateFieldGet2(this, _YargsInstance_options, 'f').key[k] = true;
      }
    }
  }
}
function isYargsInstance(y) {
  return !!y && typeof y.getInternalMethods === 'function';
}

// ../../node_modules/.bun/yargs@17.7.2/node_modules/yargs/index.mjs
var Yargs = YargsFactory(esm_default);
var yargs_default = Yargs;

// src/cli-builder.ts
class YargsCliBuilder {
  instance = null;
  ensureInstance() {
    if (!this.instance) {
      throw new Error('CLI instance not created. Call create() first.');
    }
    return this.instance;
  }
  create(argv) {
    this.instance = yargs_default(argv);
    return this;
  }
  scriptName(name) {
    this.instance = this.ensureInstance().scriptName(name);
    return this;
  }
  version(version) {
    this.instance = this.ensureInstance().version(version);
    return this;
  }
  usage(usage2) {
    this.instance = this.ensureInstance().usage(usage2);
    return this;
  }
  command(command2) {
    this.instance = this.ensureInstance().command(command2);
    return this;
  }
  option(key, config2) {
    this.instance = this.ensureInstance().option(key, config2);
    return this;
  }
  demandCommand(count, message) {
    this.instance = this.ensureInstance().demandCommand(count, message);
    return this;
  }
  help(option) {
    this.instance = this.ensureInstance().help(option);
    return this;
  }
  alias(key, alias) {
    this.instance = this.ensureInstance().alias(key, alias);
    return this;
  }
  strict() {
    this.instance = this.ensureInstance().strict();
    return this;
  }
  wrap(columns) {
    this.instance = this.ensureInstance().wrap(columns);
    return this;
  }
  epilogue(text) {
    this.instance = this.ensureInstance().epilogue(text);
    return this;
  }
  exitProcess(enabled) {
    this.instance = this.ensureInstance().exitProcess(enabled);
    return this;
  }
  showHelpOnFail(enabled) {
    this.instance = this.ensureInstance().showHelpOnFail(enabled);
    return this;
  }
  fail(handler) {
    this.instance = this.ensureInstance().fail(handler);
    return this;
  }
  async parse() {
    await this.ensureInstance().parse();
  }
}
YargsCliBuilder = __legacyDecorateClassTS([injectable_default()], YargsCliBuilder);

// src/output.ts
init_esm5();
class ConsoleOutputWriter {
  stdout(message) {
    process.stdout.write(message);
  }
  stderr(message) {
    process.stderr.write(message);
  }
  log(...messages) {
    process.stdout.write(`${messages.map(String).join(' ')}
`);
  }
  error(...messages) {
    process.stderr.write(`${messages.map(String).join(' ')}
`);
  }
  success(message) {
    process.stdout.write(`${message}
`);
  }
  info(message) {
    process.stdout.write(`${message}
`);
  }
}
ConsoleOutputWriter = __legacyDecorateClassTS(
  [injectable_default(), singleton_default()],
  ConsoleOutputWriter
);

class SilentOutputWriter {
  stdout(_message) {}
  stderr(_message) {}
  log(..._messages) {}
  error(..._messages) {}
  success(_message) {}
  info(_message) {}
}
SilentOutputWriter = __legacyDecorateClassTS([injectable_default()], SilentOutputWriter);

// src/container.ts
function configureContainer() {
  instance.register('OutputWriter', {
    useClass: ConsoleOutputWriter,
  });
  instance.register('CliBuilder', {
    useClass: YargsCliBuilder,
  });
}

// src/index.ts
if (import.meta.main) {
  configureContainer();
  const app = instance.resolve(CliApp);
  app.run().catch((error) => {
    process.stderr.write(`Fatal error: ${error}
`);
    process.exit(EXIT_CODES.CONFIG_ERROR);
  });
}
export { EXIT_CODES };

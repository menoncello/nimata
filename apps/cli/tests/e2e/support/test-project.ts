import { existsSync } from 'node:fs';
import { mkdtemp, rm, writeFile, readFile, mkdir, chmod } from 'node:fs/promises';
import { tmpdir } from 'node:os';
import { join } from 'node:path';

/**
 * Isolated test project for E2E tests
 * Creates temporary directory with cleanup
 */
export class TestProject {
  public readonly path: string;
  private cleaned = false;

  private constructor(path: string) {
    this.path = path;
  }

  /**
   * Create new isolated test project
   */
  static async create(prefix = 'nimata-test-'): Promise<TestProject> {
    const tmpDir = await mkdtemp(join(tmpdir(), prefix));
    // Set more permissive permissions on the temp directory to avoid permission issues
    try {
      await chmod(tmpDir, 0o777);
    } catch {
      // If chmod fails, continue with default permissions
      // Silently ignore permission errors in test environment
    }
    return new TestProject(tmpDir);
  }

  /**
   * Write file to project directory
   */
  async writeFile(relativePath: string, content: string): Promise<void> {
    const fullPath = join(this.path, relativePath);
    const dir = join(fullPath, '..');

    // Create parent directories if needed
    try {
      await mkdir(dir, { recursive: true, mode: 0o755 });
      await writeFile(fullPath, content, { mode: 0o644, encoding: 'utf-8' });
    } catch (error) {
      // If permission denied, try with more permissive permissions
      if (
        error instanceof Error &&
        (error.message.includes('EACCES') || error.message.includes('permission denied'))
      ) {
        try {
          await mkdir(dir, { recursive: true, mode: 0o777 });
          await writeFile(fullPath, content, { mode: 0o666, encoding: 'utf-8' });
          return;
        } catch (retryError) {
          throw new Error(
            `Failed to write file '${relativePath}': ${retryError instanceof Error ? retryError.message : 'Unknown error'}`
          );
        }
      }
      throw error;
    }
  }

  /**
   * Read file from project directory
   */
  async readFile(relativePath: string): Promise<string> {
    const fullPath = join(this.path, relativePath);
    return readFile(fullPath, 'utf-8');
  }

  /**
   * Check if file exists in project
   */
  fileExists(relativePath: string): boolean {
    const fullPath = join(this.path, relativePath);
    return existsSync(fullPath);
  }

  /**
   * Get full path for relative file
   */
  resolve(relativePath: string): string {
    return join(this.path, relativePath);
  }

  /**
   * Write package.json to project
   */
  async writePackageJson(content: Record<string, unknown>): Promise<void> {
    await this.writeFile('package.json', JSON.stringify(content, null, 2));
  }

  /**
   * Write tsconfig.json to project
   */
  async writeTsConfig(content: Record<string, unknown>): Promise<void> {
    await this.writeFile('tsconfig.json', JSON.stringify(content, null, 2));
  }

  /**
   * Create basic TypeScript project structure
   */
  async scaffold(projectName = 'test-project'): Promise<void> {
    await this.writePackageJson({
      name: projectName,
      version: '0.1.0',
      type: 'module',
      scripts: {
        build: 'tsc',
        test: 'bun test',
      },
    });

    await this.writeTsConfig({
      compilerOptions: {
        target: 'ES2022',
        module: 'ESNext',
        moduleResolution: 'bundler',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        outDir: './dist',
        rootDir: './src',
      },
      include: ['src/**/*'],
      exclude: ['node_modules', 'dist'],
    });

    await this.writeFile('src/index.ts', '// Generated by test scaffold\n');
  }

  /**
   * Clean up test project directory
   */
  async cleanup(): Promise<void> {
    if (this.cleaned) return;

    try {
      await rm(this.path, { recursive: true, force: true });
      this.cleaned = true;
    } catch (error) {
      // Best effort cleanup
      process.stderr.write(`Failed to cleanup test project: ${error}\n`);
    }
  }
}

/**
 * Create isolated test project with auto-cleanup
 * Use with afterEach hook
 */
export async function createTestProject(prefix?: string): Promise<TestProject> {
  return TestProject.create(prefix);
}

{
  "name": "library",
  "description": "Library package template for distribution to npm",
  "version": "1.0.0",
  "supportedProjectTypes": ["library"],
  "variables": [
    {
      "name": "name",
      "type": "string",
      "description": "Project name",
      "required": true
    },
    {
      "name": "description",
      "type": "string",
      "description": "Project description",
      "required": false,
      "default": ""
    },
    {
      "name": "author",
      "type": "string",
      "description": "Project author",
      "required": false,
      "default": ""
    },
    {
      "name": "license",
      "type": "string",
      "description": "Project license",
      "required": false,
      "default": "MIT"
    },
    {
      "name": "qualityLevel",
      "type": "select",
      "description": "Code quality level",
      "required": true,
      "default": "medium"
    },
    {
      "name": "aiAssistants",
      "type": "multiselect",
      "description": "AI assistants to configure",
      "required": true,
      "default": ["claude-code"]
    },
    {
      "name": "year",
      "type": "string",
      "description": "Current year",
      "required": false,
      "default": "{{helper:year}}"
    }
  ],
  "files": [
    {
      "path": "package.json",
      "template": "{\n  \"name\": \"{{name}}\",\n  \"version\": \"1.0.0\",\n  \"description\": \"{{description}}\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.esm.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"files\": [\n    \"dist\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"scripts\": {\n    \"build\": \"bun run build:cjs && bun run build:esm\",\n    \"build:cjs\": \"tsc --project tsconfig.cjs.json\",\n    \"build:esm\": \"tsc --project tsconfig.esm.json\",\n    \"build:types\": \"tsc --project tsconfig.types.json\",\n    \"build:all\": \"bun run build:types && bun run build:cjs && bun run build:esm\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"dev\": \"tsc --project tsconfig.types.json --watch\",\n    \"test\": \"bun test\",\n    \"test:unit\": \"bun test tests/unit/\",\n    \"test:integration\": \"bun test tests/integration/\",\n    \"test:coverage\": \"bun test --coverage\",\n    \"test:watch\": \"bun test --watch\",\n    \"lint\": \"eslint \\\"src/**/*.ts\\\" \\\"tests/**/*.ts\\\"\",\n    \"lint:fix\": \"eslint \\\"src/**/*.ts\\\" \\\"tests/**/*.ts\\\" --fix\",\n    \"format\": \"prettier --write \\\"src/**/*.ts\\\" \\\"tests/**/*.ts\\\"\",\n    \"format:check\": \"prettier --check \\\"src/**/*.ts\\\" \\\"tests/**/*.ts\\\"\",\n    \"prepublishOnly\": \"bun run build:all && bun run test\",\n    \"prepack\": \"bun run build:all\",\n    \"clean\": \"rm -rf dist node_modules coverage\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {\n    \"@types/node\": \"^24.8.0\",\n    \"typescript\": \"^5.3.3\",\n    \"bun\": \"latest\",\n    \"eslint\": \"^8.56.0\",\n    \"prettier\": \"^3.1.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.21.0\",\n    \"@typescript-eslint/parser\": \"^6.21.0\"\n  },\n  \"peerDependencies\": {\n    \"typescript\": \">=4.5.0\"\n  },\n  \"engines\": {\n    \"bun\": \">=1.3.0\",\n    \"node\": \">=16.0.0\"\n  },\n  \"keywords\": [\n    \"typescript\",\n    \"library\",\n    \"{{helper:kebabCase name}}\"\n  ],\n  \"author\": \"{{author}}\",\n  \"license\": \"{{license}}\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/username/{{name}}.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/username/{{name}}/issues\"\n  },\n  \"homepage\": \"https://github.com/username/{{name}}#readme\"\n}",
      "permissions": "644"
    },
    {
      "path": "tsconfig.json",
      "template": "{\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"removeComments\": false,\n    \"noImplicitAny\": {{#if (eq qualityLevel 'strict')}}true{{else}}false{{/if}},\n    \"noImplicitReturns\": {{#if (eq qualityLevel 'medium')}}true{{else}}{{#if (eq qualityLevel 'strict')}}true{{else}}false{{/if}}{{/if}},\n    \"noImplicitThis\": {{#if (eq qualityLevel 'strict')}}true{{else}}false{{/if}},\n    \"noUnusedLocals\": {{#if (eq qualityLevel 'strict')}}true{{else}}false{{/if}},\n    \"noUnusedParameters\": {{#if (eq qualityLevel 'strict')}}true{{else}}false{{/if}},\n    \"exactOptionalPropertyTypes\": {{#if (eq qualityLevel 'strict')}}true{{else}}false{{/if}}\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"coverage\",\n    \"tests\"\n  ]\n}",
      "permissions": "644"
    },
    {
      "path": "tsconfig.base.json",
      "template": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"lib\": [\"ES2020\"],\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    \"allowJs\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true\n  }\n}",
      "permissions": "644"
    },
    {
      "path": "tsconfig.cjs.json",
      "template": "{\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"module\": \"CommonJS\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"coverage\",\n    \"tests\"\n  ]\n}",
      "permissions": "644"
    },
    {
      "path": "tsconfig.esm.json",
      "template": "{\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"module\": \"ESNext\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\"\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"coverage\",\n    \"tests\"\n  ]\n}",
      "permissions": "644"
    },
    {
      "path": "tsconfig.types.json",
      "template": "{\n  \"extends\": \"./tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"declarationOnly\": true,\n    \"emitDeclarationOnly\": true,\n    \"outDir\": \"./dist\"\n  },\n  \"include\": [\n    \"src/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"coverage\",\n    \"tests\"\n  ]\n}",
      "permissions": "644"
    },
    {
      "path": "src/index.ts",
      "template": "/**\n * {{helper:pascalCase name}} Library\n *\n * {{description}}\n *\n * @author {{author}}\n * @license {{license}}\n * @version 1.0.0\n * @since {{year}}\n */\n\n// Export main functionality\nexport { {{helper:pascalCase name}}, version } from './{{name}}.js';\n\n// Export types\nexport type { {{helper:pascalCase name}}Config, {{helper:pascalCase name}}Options } from './types.js';\n\n// Export utilities\nexport * from './utils.js';",
      "permissions": "644"
    },
    {
      "path": "src/{{name}}.ts",
      "template": "/**\n * Main {{helper:pascalCase name}} class\n */\n\nimport type { {{helper:pascalCase name}}Config, {{helper:pascalCase name}}Options } from './types.js';\nimport { validateConfig, validateOptions } from './utils.js';\n\n/**\n * Library version\n */\nexport const version = '1.0.0';\n\n/**\n * Main {{helper:pascalCase name}} class\n */\nexport class {{helper:pascalCase name}} {\n  private config: {{helper:pascalCase name}}Config;\n  private initialized: boolean = false;\n\n  /**\n   * Create a new {{helper:pascalCase name}} instance\n   *\n   * @param config - Configuration options\n   */\n  constructor(config?: Partial<{{helper:pascalCase name}}Config>) {\n    const defaultConfig: {{helper:pascalCase name}}Config = {\n      debug: false,\n      timeout: 5000,\n      retries: 3\n    };\n\n    this.config = { ...defaultConfig, ...config };\n    this.validateConfiguration();\n  }\n\n  /**\n   * Initialize the library\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) {\n      return;\n    }\n\n    if (this.config.debug) {\n      console.log('Initializing {{helper:pascalCase name}} library...');\n    }\n\n    // Perform initialization logic here\n    await this.performInitialization();\n\n    this.initialized = true;\n\n    if (this.config.debug) {\n      console.log('{{helper:pascalCase name}} library initialized successfully');\n    }\n  }\n\n  /**\n   * Main processing method\n   *\n   * @param input - Input data to process\n   * @param options - Processing options\n   * @returns Processed result\n   */\n  async process<T>(input: T, options?: {{helper:pascalCase name}}Options): Promise<T> {\n    this.ensureInitialized();\n    \n    const validation = validateOptions(options || {});\n    if (!validation.valid) {\n      throw new Error(`Invalid options: ${validation.errors.join(', ')}`);\n    }\n\n    if (this.config.debug) {\n      console.log('Processing input:', input);\n      console.log('Using options:', options);\n    }\n\n    try {\n      const result = await this.performProcessing(input, options);\n      \n      if (this.config.debug) {\n        console.log('Processing completed successfully');\n      }\n      \n      return result;\n    } catch (error) {\n      if (this.config.debug) {\n        console.error('Processing failed:', error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Get current configuration\n   *\n   * @returns Current configuration (readonly)\n   */\n  getConfig(): Readonly<{{helper:pascalCase name}}Config> {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration\n   *\n   * @param newConfig - New configuration values\n   */\n  updateConfig(newConfig: Partial<{{helper:pascalCase name}}Config>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.validateConfiguration();\n  }\n\n  /**\n   * Reset the library to uninitialized state\n   */\n  reset(): void {\n    this.initialized = false;\n    if (this.config.debug) {\n      console.log('{{helper:pascalCase name}} library reset');\n    }\n  }\n\n  /**\n   * Dispose of resources\n   */\n  async dispose(): Promise<void> {\n    if (this.config.debug) {\n      console.log('Disposing {{helper:pascalCase name}} library...');\n    }\n\n    // Perform cleanup here\n    await this.performCleanup();\n\n    this.initialized = false;\n\n    if (this.config.debug) {\n      console.log('{{helper:pascalCase name}} library disposed');\n    }\n  }\n\n  /**\n   * Ensure library is initialized\n   */\n  private ensureInitialized(): void {\n    if (!this.initialized) {\n      throw new Error('{{helper:pascalCase name}} library not initialized. Call initialize() first.');\n    }\n  }\n\n  /**\n   * Validate configuration\n   */\n  private validateConfiguration(): void {\n    const validation = validateConfig(this.config);\n    if (!validation.valid) {\n      throw new Error(`Invalid configuration: ${validation.errors.join(', ')}`);\n    }\n  }\n\n  /**\n   * Perform actual initialization\n   */\n  private async performInitialization(): Promise<void> {\n    // Add your initialization logic here\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n\n  /**\n   * Perform actual processing\n   */\n  private async performProcessing<T>(input: T, options?: {{helper:pascalCase name}}Options): Promise<T> {\n    // Add your processing logic here\n    // This is a placeholder implementation\n    await new Promise(resolve => setTimeout(resolve, 10));\n    return input;\n  }\n\n  /**\n   * Perform cleanup\n   */\n  private async performCleanup(): Promise<void> {\n    // Add your cleanup logic here\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n}\n\n/**\n * Factory function to create and initialize a {{helper:pascalCase name}} instance\n *\n * @param config - Configuration options\n * @returns Initialized {{helper:pascalCase name}} instance\n */\nexport async function create{{helper:pascalCase name}}(config?: Partial<{{helper:pascalCase name}}Config>): Promise<{{helper:pascalCase name}}> {\n  const instance = new {{helper:pascalCase name}}(config);\n  await instance.initialize();\n  return instance;\n}",
      "permissions": "644"
    },
    {
      "path": "src/types.ts",
      "template": "/**\n * Type definitions for {{helper:pascalCase name}}\n */\n\n/**\n * Configuration options for {{helper:pascalCase name}}\n */\nexport interface {{helper:pascalCase name}}Config {\n  /**\n   * Enable debug logging\n   */\n  debug: boolean;\n  \n  /**\n   * Operation timeout in milliseconds\n   */\n  timeout: number;\n  \n  /**\n   * Number of retry attempts\n   */\n  retries: number;\n  \n  /**\n   * Custom user agent string\n   */\n  userAgent?: string;\n  \n  /**\n   * Additional custom options\n   */\n  [key: string]: unknown;\n}\n\n/**\n * Options for processing operations\n */\nexport interface {{helper:pascalCase name}}Options {\n  /**\n   * Enable verbose output\n   */\n  verbose?: boolean;\n  \n  /**\n   * Custom timeout for this operation\n   */\n  timeout?: number;\n  \n  /**\n   * Skip validation\n   */\n  skipValidation?: boolean;\n  \n  /**\n   * Custom metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Processing result interface\n */\nexport interface {{helper:pascalCase name}}Result<T> {\n  /**\n   * Processed data\n   */\n  data: T;\n  \n  /**\n   * Processing duration in milliseconds\n   */\n  duration: number;\n  \n  /**\n   * Processing timestamp\n   */\n  timestamp: string;\n  \n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Validation result interface\n */\nexport interface ValidationResult {\n  /**\n   * Whether validation passed\n   */\n  valid: boolean;\n  \n  /**\n   * Validation errors\n   */\n  errors: string[];\n  \n  /**\n   * Validation warnings\n   */\n  warnings: string[];\n}\n\n/**\n * Error class for {{helper:pascalCase name}}\n */\nexport class {{helper:pascalCase name}}Error extends Error {\n  constructor(\n    message: string,\n    public readonly code?: string,\n    public readonly details?: unknown\n  ) {\n    super(message);\n    this.name = '{{helper:pascalCase name}}Error';\n  }\n}\n\n/**\n * Event types\n */\nexport type {{helper:camelCase name}}EventType = \n  | 'initialized'\n  | 'processing-start'\n  | 'processing-complete'\n  | 'processing-error'\n  | 'disposed';\n\n/**\n * Event payload interface\n */\nexport interface {{helper:camelCase name}}Event<T = unknown> {\n  type: {{helper:camelCase name}}EventType;\n  timestamp: string;\n  data?: T;\n  error?: Error;\n}\n\n/**\n * Event listener type\n */\nexport type {{helper:camelCase name}}EventListener<T = unknown> = (event: {{helper:camelCase name}}Event<T>) => void;",
      "permissions": "644"
    },
    {
      "path": "src/utils.ts",
      "template": "/**\n * Utility functions for {{helper:pascalCase name}}\n */\n\nimport type { {{helper:pascalCase name}}Config, {{helper:pascalCase name}}Options, ValidationResult } from './types.js';\n\n/**\n * Validate configuration\n *\n * @param config - Configuration to validate\n * @returns Validation result\n */\nexport function validateConfig(config: {{helper:pascalCase name}}Config): ValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Validate timeout\n  if (config.timeout <= 0) {\n    errors.push('Timeout must be greater than 0');\n  } else if (config.timeout > 300000) {\n    warnings.push('Timeout is very high (over 5 minutes)');\n  }\n\n  // Validate retries\n  if (config.retries < 0) {\n    errors.push('Retries cannot be negative');\n  } else if (config.retries > 10) {\n    warnings.push('High retry count may cause performance issues');\n  }\n\n  // Validate user agent if provided\n  if (config.userAgent && config.userAgent.length > 200) {\n    errors.push('User agent string is too long (max 200 characters)');\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings\n  };\n}\n\n/**\n * Validate options\n *\n * @param options - Options to validate\n * @returns Validation result\n */\nexport function validateOptions(options: {{helper:pascalCase name}}Options): ValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Validate timeout if provided\n  if (options.timeout !== undefined) {\n    if (options.timeout <= 0) {\n      errors.push('Timeout must be greater than 0');\n    } else if (options.timeout > 300000) {\n      warnings.push('Timeout is very high (over 5 minutes)');\n    }\n  }\n\n  // Validate metadata if provided\n  if (options.metadata) {\n    try {\n      JSON.stringify(options.metadata);\n    } catch {\n      errors.push('Metadata must be serializable');\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings\n  };\n}\n\n/**\n * Create a delay\n *\n * @param ms - Milliseconds to delay\n * @returns Promise that resolves after delay\n */\nexport function delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Retry a function with exponential backoff\n *\n * @param fn - Function to retry\n * @param maxRetries - Maximum number of retries\n * @param baseDelay - Base delay in milliseconds\n * @returns Promise with function result\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  baseDelay: number = 1000\n): Promise<T> {\n  let lastError: Error;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      \n      if (attempt === maxRetries) {\n        throw lastError;\n      }\n      \n      const delayMs = baseDelay * Math.pow(2, attempt);\n      await delay(delayMs);\n    }\n  }\n  \n  throw lastError!;\n}\n\n/**\n * Format bytes to human-readable string\n *\n * @param bytes - Number of bytes\n * @param decimals - Number of decimal places\n * @returns Formatted string\n */\nexport function formatBytes(bytes: number, decimals: number = 2): string {\n  if (bytes === 0) return '0 Bytes';\n\n  const k = 1024;\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\n/**\n * Generate a random ID\n *\n * @param length - Length of the ID\n * @returns Random ID string\n */\nexport function generateId(length: number = 8): string {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  let result = '';\n  \n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  \n  return result;\n}\n\n/**\n * Deep clone an object\n *\n * @param obj - Object to clone\n * @returns Cloned object\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as T;\n  }\n  \n  if (obj instanceof Array) {\n    return obj.map(item => deepClone(item)) as T;\n  }\n  \n  if (typeof obj === 'object') {\n    const clonedObj = {} as T;\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        clonedObj[key] = deepClone(obj[key]);\n      }\n    }\n    return clonedObj;\n  }\n  \n  return obj;\n}",
      "permissions": "644"
    },
    {
      "path": "tests/index.test.ts",
      "template": "/**\n * Unit tests for {{helper:pascalCase name}} library\n */\n\nimport { describe, it, expect, beforeEach, afterEach } from 'bun:test';\nimport { {{helper:pascalCase name}}, create{{helper:pascalCase name}}, version } from '../src/index.js';\nimport type { {{helper:pascalCase name}}Config } from '../src/types.js';\n\ndescribe('{{helper:pascalCase name}} Library', () => {\n  let instance: {{helper:pascalCase name}};\n\n  beforeEach(() => {\n    instance = new {{helper:pascalCase name}}({ debug: false });\n  });\n\n  afterEach(async () => {\n    if (instance) {\n      await instance.dispose();\n    }\n  });\n\n  describe('Constructor', () => {\n    it('should create instance with default config', () => {\n      const defaultInstance = new {{helper:pascalCase name}}();\n      const config = defaultInstance.getConfig();\n      \n      expect(config.debug).toBe(false);\n      expect(config.timeout).toBe(5000);\n      expect(config.retries).toBe(3);\n    });\n\n    it('should create instance with custom config', () => {\n      const customConfig: Partial<{{helper:pascalCase name}}Config> = {\n        debug: true,\n        timeout: 10000,\n        retries: 5\n      };\n      \n      const customInstance = new {{helper:pascalCase name}}(customConfig);\n      const config = customInstance.getConfig();\n      \n      expect(config.debug).toBe(true);\n      expect(config.timeout).toBe(10000);\n      expect(config.retries).toBe(5);\n    });\n\n    it('should reject invalid configuration', () => {\n      expect(() => {\n        new {{helper:pascalCase name}}({ timeout: -1 });\n      }).toThrow('Invalid configuration');\n    });\n  });\n\n  describe('Initialization', () => {\n    it('should initialize successfully', async () => {\n      await instance.initialize();\n      \n      // Should not throw when calling process after initialization\n      await expect(instance.process('test')).resolves.toBe('test');\n    });\n\n    it('should handle multiple initialize calls', async () => {\n      await instance.initialize();\n      await instance.initialize(); // Should not throw\n    });\n  });\n\n  describe('Processing', () => {\n    beforeEach(async () => {\n      await instance.initialize();\n    });\n\n    it('should process data successfully', async () => {\n      const input = 'test data';\n      const result = await instance.process(input);\n      \n      expect(result).toBe(input);\n    });\n\n    it('should process data with options', async () => {\n      const input = 'test data';\n      const options = { verbose: true, timeout: 1000 };\n      const result = await instance.process(input, options);\n      \n      expect(result).toBe(input);\n    });\n\n    it('should reject processing when not initialized', async () => {\n      const uninitializedInstance = new {{helper:pascalCase name}}();\n      \n      await expect(uninitializedInstance.process('test')).rejects.toThrow('not initialized');\n    });\n\n    it('should reject invalid options', async () => {\n      const invalidOptions = { timeout: -1 };\n      \n      await expect(instance.process('test', invalidOptions)).rejects.toThrow('Invalid options');\n    });\n  });\n\n  describe('Configuration Management', () => {\n    it('should get readonly config', () => {\n      const config = instance.getConfig();\n      expect(config).toHaveProperty('debug');\n      expect(config).toHaveProperty('timeout');\n      expect(config).toHaveProperty('retries');\n    });\n\n    it('should update config', () => {\n      instance.updateConfig({ debug: true, timeout: 8000 });\n      const config = instance.getConfig();\n      \n      expect(config.debug).toBe(true);\n      expect(config.timeout).toBe(8000);\n      expect(config.retries).toBe(3); // Should preserve existing value\n    });\n\n    it('should reject invalid config updates', () => {\n      expect(() => {\n        instance.updateConfig({ retries: -1 });\n      }).toThrow('Invalid configuration');\n    });\n  });\n\n  describe('Lifecycle', () => {\n    it('should reset properly', async () => {\n      await instance.initialize();\n      instance.reset();\n      \n      // Should reject processing after reset\n      await expect(instance.process('test')).rejects.toThrow('not initialized');\n    });\n\n    it('should dispose properly', async () => {\n      await instance.initialize();\n      await instance.dispose();\n      \n      // Should reject processing after dispose\n      await expect(instance.process('test')).rejects.toThrow('not initialized');\n    });\n  });\n\n  describe('Factory Function', () => {\n    it('should create initialized instance', async () => {\n      const factoryInstance = await create{{helper:pascalCase name}}({ debug: true });\n      \n      // Should be able to process immediately\n      await expect(factoryInstance.process('test')).resolves.toBe('test');\n      \n      await factoryInstance.dispose();\n    });\n  });\n\n  describe('Version', () => {\n    it('should have correct version', () => {\n      expect(version).toBe('1.0.0');\n    });\n  });\n});",
      "permissions": "644"
    },
    {
      "path": "tests/utils.test.ts",
      "template": "/**\n * Unit tests for utility functions\n */\n\nimport { describe, it, expect } from 'bun:test';\nimport { validateConfig, validateOptions, delay, formatBytes, generateId } from '../src/utils.js';\nimport type { {{helper:pascalCase name}}Config, {{helper:pascalCase name}}Options } from '../src/types.js';\n\ndescribe('Utility Functions', () => {\n  describe('validateConfig', () => {\n    it('should validate valid config', () => {\n      const config: {{helper:pascalCase name}}Config = {\n        debug: false,\n        timeout: 5000,\n        retries: 3\n      };\n      \n      const result = validateConfig(config);\n      expect(result.valid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    it('should reject invalid timeout', () => {\n      const config: {{helper:pascalCase name}}Config = {\n        debug: false,\n        timeout: -1,\n        retries: 3\n      };\n      \n      const result = validateConfig(config);\n      expect(result.valid).toBe(false);\n      expect(result.errors).toContain('Timeout must be greater than 0');\n    });\n\n    it('should warn about high timeout', () => {\n      const config: {{helper:pascalCase name}}Config = {\n        debug: false,\n        timeout: 400000,\n        retries: 3\n      };\n      \n      const result = validateConfig(config);\n      expect(result.valid).toBe(true);\n      expect(result.warnings).toContain('Timeout is very high (over 5 minutes)');\n    });\n\n    it('should reject negative retries', () => {\n      const config: {{helper:pascalCase name}}Config = {\n        debug: false,\n        timeout: 5000,\n        retries: -1\n      };\n      \n      const result = validateConfig(config);\n      expect(result.valid).toBe(false);\n      expect(result.errors).toContain('Retries cannot be negative');\n    });\n  });\n\n  describe('validateOptions', () => {\n    it('should validate valid options', () => {\n      const options: {{helper:pascalCase name}}Options = {\n        verbose: true,\n        timeout: 1000\n      };\n      \n      const result = validateOptions(options);\n      expect(result.valid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    it('should validate empty options', () => {\n      const result = validateOptions({});\n      expect(result.valid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n\n    it('should reject invalid timeout', () => {\n      const options: {{helper:pascalCase name}}Options = {\n        timeout: -1\n      };\n      \n      const result = validateOptions(options);\n      expect(result.valid).toBe(false);\n      expect(result.errors).toContain('Timeout must be greater than 0');\n    });\n\n    it('should reject non-serializable metadata', () => {\n      const options: {{helper:pascalCase name}}Options = {\n        metadata: {\n          circular: null as any\n        }\n      };\n      \n      // Create circular reference\n      options.metadata.circular = options.metadata;\n      \n      const result = validateOptions(options);\n      expect(result.valid).toBe(false);\n      expect(result.errors).toContain('Metadata must be serializable');\n    });\n  });\n\n  describe('delay', () => {\n    it('should delay for specified time', async () => {\n      const start = Date.now();\n      await delay(100);\n      const end = Date.now();\n      \n      expect(end - start).toBeGreaterThanOrEqual(90); // Allow some tolerance\n      expect(end - start).toBeLessThan(150); // Should not take much longer\n    });\n  });\n\n  describe('formatBytes', () => {\n    it('should format bytes correctly', () => {\n      expect(formatBytes(0)).toBe('0 Bytes');\n      expect(formatBytes(1024)).toBe('1 KB');\n      expect(formatBytes(1048576)).toBe('1 MB');\n      expect(formatBytes(1073741824)).toBe('1 GB');\n    });\n\n    it('should handle decimal places', () => {\n      expect(formatBytes(1536, 2)).toBe('1.5 KB');\n      expect(formatBytes(1536, 1)).toBe('1.5 KB');\n      expect(formatBytes(1536, 0)).toBe('2 KB');\n    });\n  });\n\n  describe('generateId', () => {\n    it('should generate ID with default length', () => {\n      const id = generateId();\n      expect(id).toHaveLength(8);\n      expect(/^[A-Za-z0-9]+$/.test(id)).toBe(true);\n    });\n\n    it('should generate ID with custom length', () => {\n      const id = generateId(16);\n      expect(id).toHaveLength(16);\n      expect(/^[A-Za-z0-9]+$/.test(id)).toBe(true);\n    });\n\n    it('should generate different IDs', () => {\n      const id1 = generateId();\n      const id2 = generateId();\n      expect(id1).not.toBe(id2);\n    });\n  });\n});",
      "permissions": "644"
    },
    {
      "path": "README.md",
      "template": "# {{helper:pascalCase name}}\n\n{{description}}\n\n## Installation\n\n```bash\n# npm\nnpm install {{name}}\n\n# yarn\nyarn add {{name}}\n\n# pnpm\npnpm add {{name}}\n\n# bun\nbun add {{name}}\n```\n\n## Quick Start\n\n```typescript\nimport { {{helper:pascalCase name}}, create{{helper:pascalCase name}} } from '{{name}}';\n\n// Using constructor\nconst instance = new {{helper:pascalCase name}}({\n  debug: true,\n  timeout: 10000\n});\n\nawait instance.initialize();\nconst result = await instance.process('your data');\n\n// Using factory function\nconst instance2 = await create{{helper:pascalCase name}}({\n  debug: true,\n  timeout: 10000\n});\n\nconst result2 = await instance2.process('your data', {\n  verbose: true\n});\n```\n\n## API Documentation\n\n### Constructor\n\n```typescript\nnew {{helper:pascalCase name}}(config?: Partial<{{helper:pascalCase name}}Config>)\n```\n\nCreate a new {{helper:pascalCase name}} instance.\n\n#### Configuration Options\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `debug` | `boolean` | `false` | Enable debug logging |\n| `timeout` | `number` | `5000` | Operation timeout in milliseconds |\n| `retries` | `number` | `3` | Number of retry attempts |\n| `userAgent` | `string` | - | Custom user agent string |\n\n### Methods\n\n#### `initialize(): Promise<void>`\n\nInitialize the library. Must be called before processing.\n\n#### `process<T>(input: T, options?: {{helper:pascalCase name}}Options): Promise<T>`\n\nProcess input data.\n\n#### `getConfig(): Readonly<{{helper:pascalCase name}}Config>`\n\nGet current configuration (readonly).\n\n#### `updateConfig(newConfig: Partial<{{helper:pascalCase name}}Config>): void`\n\nUpdate configuration.\n\n#### `reset(): void`\n\nReset the library to uninitialized state.\n\n#### `dispose(): Promise<void>`\n\nDispose of resources and clean up.\n\n### Processing Options\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `verbose` | `boolean` | `false` | Enable verbose output |\n| `timeout` | `number` | - | Custom timeout for this operation |\n| `skipValidation` | `boolean` | `false` | Skip validation |\n| `metadata` | `Record<string, unknown>` | - | Custom metadata |\n\n### Factory Function\n\n```typescript\ncreate{{helper:pascalCase name}}(config?: Partial<{{helper:pascalCase name}}Config>): Promise<{{helper:pascalCase name}}>\n```\n\nCreate and initialize a {{helper:pascalCase name}} instance in one step.\n\n## Usage Examples\n\n### Basic Usage\n\n```typescript\nimport { {{helper:pascalCase name}} } from '{{name}}';\n\nconst processor = new {{helper:pascalCase name}}();\nawait processor.initialize();\n\ntry {\n  const result = await processor.process('Hello, World!');\n  console.log('Result:', result);\n} finally {\n  await processor.dispose();\n}\n```\n\n### Advanced Configuration\n\n```typescript\nimport { {{helper:pascalCase name}} } from '{{name}}';\n\nconst processor = new {{helper:pascalCase name}}({\n  debug: true,\n  timeout: 15000,\n  retries: 5,\n  userAgent: 'MyApp/1.0'\n});\n\nawait processor.initialize();\n\nconst result = await processor.process(data, {\n  verbose: true,\n  metadata: { requestId: '12345' }\n});\n```\n\n### Error Handling\n\n```typescript\nimport { {{helper:pascalCase name}}, {{helper:pascalCase name}}Error } from '{{name}}';\n\nconst processor = new {{helper:pascalCase name}}();\nawait processor.initialize();\n\ntry {\n  const result = await processor.process(data);\n} catch (error) {\n  if (error instanceof {{helper:pascalCase name}}Error) {\n    console.error('Library error:', error.message, error.code);\n    console.error('Details:', error.details);\n  } else {\n    console.error('Unexpected error:', error);\n  }\n}\n```\n\n## Development\n\n```bash\n# Install dependencies\nbun install\n\n# Run tests\nbun test\n\n# Run tests with coverage\nbun run test:coverage\n\n# Build the library\nbun run build:all\n\n# Type checking\nbun run typecheck\n\n# Linting\nbun run lint\n\n# Formatting\nbun run format\n```\n\n## Build Output\n\nThis library builds to multiple formats:\n\n- **CommonJS**: `dist/index.js`\n- **ES Modules**: `dist/index.esm.js`\n- **TypeScript Declarations**: `dist/index.d.ts`\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## License\n\n{{license}} © {{year}} {{author}}",
      "permissions": "644"
    }
  ]
}
